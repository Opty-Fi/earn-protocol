!(function (e) {
  var t = {};
  function n(a) {
    if (t[a]) return t[a].exports;
    var s = (t[a] = { i: a, l: !1, exports: {} });
    return e[a].call(s.exports, s, s.exports, n), (s.l = !0), s.exports;
  }
  (n.m = e),
    (n.c = t),
    (n.d = function (e, t, a) {
      n.o(e, t) || Object.defineProperty(e, t, { enumerable: !0, get: a });
    }),
    (n.r = function (e) {
      "undefined" != typeof Symbol &&
        Symbol.toStringTag &&
        Object.defineProperty(e, Symbol.toStringTag, { value: "Module" }),
        Object.defineProperty(e, "__esModule", { value: !0 });
    }),
    (n.t = function (e, t) {
      if ((1 & t && (e = n(e)), 8 & t)) return e;
      if (4 & t && "object" == typeof e && e && e.__esModule) return e;
      var a = Object.create(null);
      if ((n.r(a), Object.defineProperty(a, "default", { enumerable: !0, value: e }), 2 & t && "string" != typeof e))
        for (var s in e)
          n.d(
            a,
            s,
            function (t) {
              return e[t];
            }.bind(null, s),
          );
      return a;
    }),
    (n.n = function (e) {
      var t =
        e && e.__esModule
          ? function () {
              return e.default;
            }
          : function () {
              return e;
            };
      return n.d(t, "a", t), t;
    }),
    (n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }),
    (n.p = ""),
    n((n.s = 10));
})([
  function (e, t) {
    var n;
    n = (function () {
      return this;
    })();
    try {
      n = n || new Function("return this")();
    } catch (e) {
      "object" == typeof window && (n = window);
    }
    e.exports = n;
  },
  function (e, t, n) {
    "use strict";
    (function (e, n) {
      /*!
       * Vue.js v2.6.12
       * (c) 2014-2020 Evan You
       * Released under the MIT License.
       */
      var a = Object.freeze({});
      function s(e) {
        return null == e;
      }
      function i(e) {
        return null != e;
      }
      function r(e) {
        return !0 === e;
      }
      function o(e) {
        return "string" == typeof e || "number" == typeof e || "symbol" == typeof e || "boolean" == typeof e;
      }
      function d(e) {
        return null !== e && "object" == typeof e;
      }
      var p = Object.prototype.toString;
      function u(e) {
        return "[object Object]" === p.call(e);
      }
      function l(e) {
        return "[object RegExp]" === p.call(e);
      }
      function y(e) {
        var t = parseFloat(String(e));
        return t >= 0 && Math.floor(t) === t && isFinite(e);
      }
      function m(e) {
        return i(e) && "function" == typeof e.then && "function" == typeof e.catch;
      }
      function c(e) {
        return null == e ? "" : Array.isArray(e) || (u(e) && e.toString === p) ? JSON.stringify(e, null, 2) : String(e);
      }
      function T(e) {
        var t = parseFloat(e);
        return isNaN(t) ? e : t;
      }
      function f(e, t) {
        for (var n = Object.create(null), a = e.split(","), s = 0; s < a.length; s++) n[a[s]] = !0;
        return t
          ? function (e) {
              return n[e.toLowerCase()];
            }
          : function (e) {
              return n[e];
            };
      }
      var b = f("slot,component", !0),
        g = f("key,ref,slot,slot-scope,is");
      function v(e, t) {
        if (e.length) {
          var n = e.indexOf(t);
          if (n > -1) return e.splice(n, 1);
        }
      }
      var h = Object.prototype.hasOwnProperty;
      function _(e, t) {
        return h.call(e, t);
      }
      function w(e) {
        var t = Object.create(null);
        return function (n) {
          return t[n] || (t[n] = e(n));
        };
      }
      var k = /-(\w)/g,
        P = w(function (e) {
          return e.replace(k, function (e, t) {
            return t ? t.toUpperCase() : "";
          });
        }),
        M = w(function (e) {
          return e.charAt(0).toUpperCase() + e.slice(1);
        }),
        A = /\B([A-Z])/g,
        S = w(function (e) {
          return e.replace(A, "-$1").toLowerCase();
        });
      var C = Function.prototype.bind
        ? function (e, t) {
            return e.bind(t);
          }
        : function (e, t) {
            function n(n) {
              var a = arguments.length;
              return a ? (a > 1 ? e.apply(t, arguments) : e.call(t, n)) : e.call(t);
            }
            return (n._length = e.length), n;
          };
      function R(e, t) {
        t = t || 0;
        for (var n = e.length - t, a = new Array(n); n--; ) a[n] = e[n + t];
        return a;
      }
      function D(e, t) {
        for (var n in t) e[n] = t[n];
        return e;
      }
      function x(e) {
        for (var t = {}, n = 0; n < e.length; n++) e[n] && D(t, e[n]);
        return t;
      }
      function O(e, t, n) {}
      var I = function (e, t, n) {
          return !1;
        },
        L = function (e) {
          return e;
        };
      function E(e, t) {
        if (e === t) return !0;
        var n = d(e),
          a = d(t);
        if (!n || !a) return !n && !a && String(e) === String(t);
        try {
          var s = Array.isArray(e),
            i = Array.isArray(t);
          if (s && i)
            return (
              e.length === t.length &&
              e.every(function (e, n) {
                return E(e, t[n]);
              })
            );
          if (e instanceof Date && t instanceof Date) return e.getTime() === t.getTime();
          if (s || i) return !1;
          var r = Object.keys(e),
            o = Object.keys(t);
          return (
            r.length === o.length &&
            r.every(function (n) {
              return E(e[n], t[n]);
            })
          );
        } catch (e) {
          return !1;
        }
      }
      function q(e, t) {
        for (var n = 0; n < e.length; n++) if (E(e[n], t)) return n;
        return -1;
      }
      function V(e) {
        var t = !1;
        return function () {
          t || ((t = !0), e.apply(this, arguments));
        };
      }
      var U = ["component", "directive", "filter"],
        B = [
          "beforeCreate",
          "created",
          "beforeMount",
          "mounted",
          "beforeUpdate",
          "updated",
          "beforeDestroy",
          "destroyed",
          "activated",
          "deactivated",
          "errorCaptured",
          "serverPrefetch",
        ],
        H = {
          optionMergeStrategies: Object.create(null),
          silent: !1,
          productionTip: !1,
          devtools: !1,
          performance: !1,
          errorHandler: null,
          warnHandler: null,
          ignoredElements: [],
          keyCodes: Object.create(null),
          isReservedTag: I,
          isReservedAttr: I,
          isUnknownElement: I,
          getTagNamespace: O,
          parsePlatformTagName: L,
          mustUseProp: I,
          async: !0,
          _lifecycleHooks: B,
        },
        $ = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;
      function W(e) {
        var t = (e + "").charCodeAt(0);
        return 36 === t || 95 === t;
      }
      function F(e, t, n, a) {
        Object.defineProperty(e, t, { value: n, enumerable: !!a, writable: !0, configurable: !0 });
      }
      var N = new RegExp("[^" + $.source + ".$_\\d]");
      var Y,
        j = "__proto__" in {},
        z = "undefined" != typeof window,
        G = "undefined" != typeof WXEnvironment && !!WXEnvironment.platform,
        K = G && WXEnvironment.platform.toLowerCase(),
        J = z && window.navigator.userAgent.toLowerCase(),
        X = J && /msie|trident/.test(J),
        Z = J && J.indexOf("msie 9.0") > 0,
        Q = J && J.indexOf("edge/") > 0,
        ee = (J && J.indexOf("android"), (J && /iphone|ipad|ipod|ios/.test(J)) || "ios" === K),
        te = (J && /chrome\/\d+/.test(J), J && /phantomjs/.test(J), J && J.match(/firefox\/(\d+)/)),
        ne = {}.watch,
        ae = !1;
      if (z)
        try {
          var se = {};
          Object.defineProperty(se, "passive", {
            get: function () {
              ae = !0;
            },
          }),
            window.addEventListener("test-passive", null, se);
        } catch (e) {}
      var ie = function () {
          return void 0 === Y && (Y = !z && !G && void 0 !== e && e.process && "server" === e.process.env.VUE_ENV), Y;
        },
        re = z && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;
      function oe(e) {
        return "function" == typeof e && /native code/.test(e.toString());
      }
      var de,
        pe = "undefined" != typeof Symbol && oe(Symbol) && "undefined" != typeof Reflect && oe(Reflect.ownKeys);
      de =
        "undefined" != typeof Set && oe(Set)
          ? Set
          : (function () {
              function e() {
                this.set = Object.create(null);
              }
              return (
                (e.prototype.has = function (e) {
                  return !0 === this.set[e];
                }),
                (e.prototype.add = function (e) {
                  this.set[e] = !0;
                }),
                (e.prototype.clear = function () {
                  this.set = Object.create(null);
                }),
                e
              );
            })();
      var ue = O,
        le = 0,
        ye = function () {
          (this.id = le++), (this.subs = []);
        };
      (ye.prototype.addSub = function (e) {
        this.subs.push(e);
      }),
        (ye.prototype.removeSub = function (e) {
          v(this.subs, e);
        }),
        (ye.prototype.depend = function () {
          ye.target && ye.target.addDep(this);
        }),
        (ye.prototype.notify = function () {
          var e = this.subs.slice();
          for (var t = 0, n = e.length; t < n; t++) e[t].update();
        }),
        (ye.target = null);
      var me = [];
      function ce(e) {
        me.push(e), (ye.target = e);
      }
      function Te() {
        me.pop(), (ye.target = me[me.length - 1]);
      }
      var fe = function (e, t, n, a, s, i, r, o) {
          (this.tag = e),
            (this.data = t),
            (this.children = n),
            (this.text = a),
            (this.elm = s),
            (this.ns = void 0),
            (this.context = i),
            (this.fnContext = void 0),
            (this.fnOptions = void 0),
            (this.fnScopeId = void 0),
            (this.key = t && t.key),
            (this.componentOptions = r),
            (this.componentInstance = void 0),
            (this.parent = void 0),
            (this.raw = !1),
            (this.isStatic = !1),
            (this.isRootInsert = !0),
            (this.isComment = !1),
            (this.isCloned = !1),
            (this.isOnce = !1),
            (this.asyncFactory = o),
            (this.asyncMeta = void 0),
            (this.isAsyncPlaceholder = !1);
        },
        be = { child: { configurable: !0 } };
      (be.child.get = function () {
        return this.componentInstance;
      }),
        Object.defineProperties(fe.prototype, be);
      var ge = function (e) {
        void 0 === e && (e = "");
        var t = new fe();
        return (t.text = e), (t.isComment = !0), t;
      };
      function ve(e) {
        return new fe(void 0, void 0, void 0, String(e));
      }
      function he(e) {
        var t = new fe(
          e.tag,
          e.data,
          e.children && e.children.slice(),
          e.text,
          e.elm,
          e.context,
          e.componentOptions,
          e.asyncFactory,
        );
        return (
          (t.ns = e.ns),
          (t.isStatic = e.isStatic),
          (t.key = e.key),
          (t.isComment = e.isComment),
          (t.fnContext = e.fnContext),
          (t.fnOptions = e.fnOptions),
          (t.fnScopeId = e.fnScopeId),
          (t.asyncMeta = e.asyncMeta),
          (t.isCloned = !0),
          t
        );
      }
      var _e = Array.prototype,
        we = Object.create(_e);
      ["push", "pop", "shift", "unshift", "splice", "sort", "reverse"].forEach(function (e) {
        var t = _e[e];
        F(we, e, function () {
          for (var n = [], a = arguments.length; a--; ) n[a] = arguments[a];
          var s,
            i = t.apply(this, n),
            r = this.__ob__;
          switch (e) {
            case "push":
            case "unshift":
              s = n;
              break;
            case "splice":
              s = n.slice(2);
          }
          return s && r.observeArray(s), r.dep.notify(), i;
        });
      });
      var ke = Object.getOwnPropertyNames(we),
        Pe = !0;
      function Me(e) {
        Pe = e;
      }
      var Ae = function (e) {
        (this.value = e),
          (this.dep = new ye()),
          (this.vmCount = 0),
          F(e, "__ob__", this),
          Array.isArray(e)
            ? (j
                ? (function (e, t) {
                    e.__proto__ = t;
                  })(e, we)
                : (function (e, t, n) {
                    for (var a = 0, s = n.length; a < s; a++) {
                      var i = n[a];
                      F(e, i, t[i]);
                    }
                  })(e, we, ke),
              this.observeArray(e))
            : this.walk(e);
      };
      function Se(e, t) {
        var n;
        if (d(e) && !(e instanceof fe))
          return (
            _(e, "__ob__") && e.__ob__ instanceof Ae
              ? (n = e.__ob__)
              : Pe && !ie() && (Array.isArray(e) || u(e)) && Object.isExtensible(e) && !e._isVue && (n = new Ae(e)),
            t && n && n.vmCount++,
            n
          );
      }
      function Ce(e, t, n, a, s) {
        var i = new ye(),
          r = Object.getOwnPropertyDescriptor(e, t);
        if (!r || !1 !== r.configurable) {
          var o = r && r.get,
            d = r && r.set;
          (o && !d) || 2 !== arguments.length || (n = e[t]);
          var p = !s && Se(n);
          Object.defineProperty(e, t, {
            enumerable: !0,
            configurable: !0,
            get: function () {
              var t = o ? o.call(e) : n;
              return ye.target && (i.depend(), p && (p.dep.depend(), Array.isArray(t) && xe(t))), t;
            },
            set: function (t) {
              var a = o ? o.call(e) : n;
              t === a || (t != t && a != a) || (o && !d) || (d ? d.call(e, t) : (n = t), (p = !s && Se(t)), i.notify());
            },
          });
        }
      }
      function Re(e, t, n) {
        if (Array.isArray(e) && y(t)) return (e.length = Math.max(e.length, t)), e.splice(t, 1, n), n;
        if (t in e && !(t in Object.prototype)) return (e[t] = n), n;
        var a = e.__ob__;
        return e._isVue || (a && a.vmCount) ? n : a ? (Ce(a.value, t, n), a.dep.notify(), n) : ((e[t] = n), n);
      }
      function De(e, t) {
        if (Array.isArray(e) && y(t)) e.splice(t, 1);
        else {
          var n = e.__ob__;
          e._isVue || (n && n.vmCount) || (_(e, t) && (delete e[t], n && n.dep.notify()));
        }
      }
      function xe(e) {
        for (var t = void 0, n = 0, a = e.length; n < a; n++)
          (t = e[n]) && t.__ob__ && t.__ob__.dep.depend(), Array.isArray(t) && xe(t);
      }
      (Ae.prototype.walk = function (e) {
        for (var t = Object.keys(e), n = 0; n < t.length; n++) Ce(e, t[n]);
      }),
        (Ae.prototype.observeArray = function (e) {
          for (var t = 0, n = e.length; t < n; t++) Se(e[t]);
        });
      var Oe = H.optionMergeStrategies;
      function Ie(e, t) {
        if (!t) return e;
        for (var n, a, s, i = pe ? Reflect.ownKeys(t) : Object.keys(t), r = 0; r < i.length; r++)
          "__ob__" !== (n = i[r]) &&
            ((a = e[n]), (s = t[n]), _(e, n) ? a !== s && u(a) && u(s) && Ie(a, s) : Re(e, n, s));
        return e;
      }
      function Le(e, t, n) {
        return n
          ? function () {
              var a = "function" == typeof t ? t.call(n, n) : t,
                s = "function" == typeof e ? e.call(n, n) : e;
              return a ? Ie(a, s) : s;
            }
          : t
          ? e
            ? function () {
                return Ie(
                  "function" == typeof t ? t.call(this, this) : t,
                  "function" == typeof e ? e.call(this, this) : e,
                );
              }
            : t
          : e;
      }
      function Ee(e, t) {
        var n = t ? (e ? e.concat(t) : Array.isArray(t) ? t : [t]) : e;
        return n
          ? (function (e) {
              for (var t = [], n = 0; n < e.length; n++) -1 === t.indexOf(e[n]) && t.push(e[n]);
              return t;
            })(n)
          : n;
      }
      function qe(e, t, n, a) {
        var s = Object.create(e || null);
        return t ? D(s, t) : s;
      }
      (Oe.data = function (e, t, n) {
        return n ? Le(e, t, n) : t && "function" != typeof t ? e : Le(e, t);
      }),
        B.forEach(function (e) {
          Oe[e] = Ee;
        }),
        U.forEach(function (e) {
          Oe[e + "s"] = qe;
        }),
        (Oe.watch = function (e, t, n, a) {
          if ((e === ne && (e = void 0), t === ne && (t = void 0), !t)) return Object.create(e || null);
          if (!e) return t;
          var s = {};
          for (var i in (D(s, e), t)) {
            var r = s[i],
              o = t[i];
            r && !Array.isArray(r) && (r = [r]), (s[i] = r ? r.concat(o) : Array.isArray(o) ? o : [o]);
          }
          return s;
        }),
        (Oe.props = Oe.methods = Oe.inject = Oe.computed = function (e, t, n, a) {
          if (!e) return t;
          var s = Object.create(null);
          return D(s, e), t && D(s, t), s;
        }),
        (Oe.provide = Le);
      var Ve = function (e, t) {
        return void 0 === t ? e : t;
      };
      function Ue(e, t, n) {
        if (
          ("function" == typeof t && (t = t.options),
          (function (e, t) {
            var n = e.props;
            if (n) {
              var a,
                s,
                i = {};
              if (Array.isArray(n))
                for (a = n.length; a--; ) "string" == typeof (s = n[a]) && (i[P(s)] = { type: null });
              else if (u(n)) for (var r in n) (s = n[r]), (i[P(r)] = u(s) ? s : { type: s });
              else 0;
              e.props = i;
            }
          })(t),
          (function (e, t) {
            var n = e.inject;
            if (n) {
              var a = (e.inject = {});
              if (Array.isArray(n)) for (var s = 0; s < n.length; s++) a[n[s]] = { from: n[s] };
              else if (u(n))
                for (var i in n) {
                  var r = n[i];
                  a[i] = u(r) ? D({ from: i }, r) : { from: r };
                }
              else 0;
            }
          })(t),
          (function (e) {
            var t = e.directives;
            if (t)
              for (var n in t) {
                var a = t[n];
                "function" == typeof a && (t[n] = { bind: a, update: a });
              }
          })(t),
          !t._base && (t.extends && (e = Ue(e, t.extends, n)), t.mixins))
        )
          for (var a = 0, s = t.mixins.length; a < s; a++) e = Ue(e, t.mixins[a], n);
        var i,
          r = {};
        for (i in e) o(i);
        for (i in t) _(e, i) || o(i);
        function o(a) {
          var s = Oe[a] || Ve;
          r[a] = s(e[a], t[a], n, a);
        }
        return r;
      }
      function Be(e, t, n, a) {
        if ("string" == typeof n) {
          var s = e[t];
          if (_(s, n)) return s[n];
          var i = P(n);
          if (_(s, i)) return s[i];
          var r = M(i);
          return _(s, r) ? s[r] : s[n] || s[i] || s[r];
        }
      }
      function He(e, t, n, a) {
        var s = t[e],
          i = !_(n, e),
          r = n[e],
          o = Fe(Boolean, s.type);
        if (o > -1)
          if (i && !_(s, "default")) r = !1;
          else if ("" === r || r === S(e)) {
            var d = Fe(String, s.type);
            (d < 0 || o < d) && (r = !0);
          }
        if (void 0 === r) {
          r = (function (e, t, n) {
            if (!_(t, "default")) return;
            var a = t.default;
            0;
            if (e && e.$options.propsData && void 0 === e.$options.propsData[n] && void 0 !== e._props[n])
              return e._props[n];
            return "function" == typeof a && "Function" !== $e(t.type) ? a.call(e) : a;
          })(a, s, e);
          var p = Pe;
          Me(!0), Se(r), Me(p);
        }
        return r;
      }
      function $e(e) {
        var t = e && e.toString().match(/^\s*function (\w+)/);
        return t ? t[1] : "";
      }
      function We(e, t) {
        return $e(e) === $e(t);
      }
      function Fe(e, t) {
        if (!Array.isArray(t)) return We(t, e) ? 0 : -1;
        for (var n = 0, a = t.length; n < a; n++) if (We(t[n], e)) return n;
        return -1;
      }
      function Ne(e, t, n) {
        ce();
        try {
          if (t)
            for (var a = t; (a = a.$parent); ) {
              var s = a.$options.errorCaptured;
              if (s)
                for (var i = 0; i < s.length; i++)
                  try {
                    if (!1 === s[i].call(a, e, t, n)) return;
                  } catch (e) {
                    je(e, a, "errorCaptured hook");
                  }
            }
          je(e, t, n);
        } finally {
          Te();
        }
      }
      function Ye(e, t, n, a, s) {
        var i;
        try {
          (i = n ? e.apply(t, n) : e.call(t)) &&
            !i._isVue &&
            m(i) &&
            !i._handled &&
            (i.catch(function (e) {
              return Ne(e, a, s + " (Promise/async)");
            }),
            (i._handled = !0));
        } catch (e) {
          Ne(e, a, s);
        }
        return i;
      }
      function je(e, t, n) {
        if (H.errorHandler)
          try {
            return H.errorHandler.call(null, e, t, n);
          } catch (t) {
            t !== e && ze(t, null, "config.errorHandler");
          }
        ze(e, t, n);
      }
      function ze(e, t, n) {
        if ((!z && !G) || "undefined" == typeof console) throw e;
        console.error(e);
      }
      var Ge,
        Ke = !1,
        Je = [],
        Xe = !1;
      function Ze() {
        Xe = !1;
        var e = Je.slice(0);
        Je.length = 0;
        for (var t = 0; t < e.length; t++) e[t]();
      }
      if ("undefined" != typeof Promise && oe(Promise)) {
        var Qe = Promise.resolve();
        (Ge = function () {
          Qe.then(Ze), ee && setTimeout(O);
        }),
          (Ke = !0);
      } else if (
        X ||
        "undefined" == typeof MutationObserver ||
        (!oe(MutationObserver) && "[object MutationObserverConstructor]" !== MutationObserver.toString())
      )
        Ge =
          void 0 !== n && oe(n)
            ? function () {
                n(Ze);
              }
            : function () {
                setTimeout(Ze, 0);
              };
      else {
        var et = 1,
          tt = new MutationObserver(Ze),
          nt = document.createTextNode(String(et));
        tt.observe(nt, { characterData: !0 }),
          (Ge = function () {
            (et = (et + 1) % 2), (nt.data = String(et));
          }),
          (Ke = !0);
      }
      function at(e, t) {
        var n;
        if (
          (Je.push(function () {
            if (e)
              try {
                e.call(t);
              } catch (e) {
                Ne(e, t, "nextTick");
              }
            else n && n(t);
          }),
          Xe || ((Xe = !0), Ge()),
          !e && "undefined" != typeof Promise)
        )
          return new Promise(function (e) {
            n = e;
          });
      }
      var st = new de();
      function it(e) {
        !(function e(t, n) {
          var a,
            s,
            i = Array.isArray(t);
          if ((!i && !d(t)) || Object.isFrozen(t) || t instanceof fe) return;
          if (t.__ob__) {
            var r = t.__ob__.dep.id;
            if (n.has(r)) return;
            n.add(r);
          }
          if (i) for (a = t.length; a--; ) e(t[a], n);
          else for (s = Object.keys(t), a = s.length; a--; ) e(t[s[a]], n);
        })(e, st),
          st.clear();
      }
      var rt = w(function (e) {
        var t = "&" === e.charAt(0),
          n = "~" === (e = t ? e.slice(1) : e).charAt(0),
          a = "!" === (e = n ? e.slice(1) : e).charAt(0);
        return { name: (e = a ? e.slice(1) : e), once: n, capture: a, passive: t };
      });
      function ot(e, t) {
        function n() {
          var e = arguments,
            a = n.fns;
          if (!Array.isArray(a)) return Ye(a, null, arguments, t, "v-on handler");
          for (var s = a.slice(), i = 0; i < s.length; i++) Ye(s[i], null, e, t, "v-on handler");
        }
        return (n.fns = e), n;
      }
      function dt(e, t, n, a, i, o) {
        var d, p, u, l;
        for (d in e)
          (p = e[d]),
            (u = t[d]),
            (l = rt(d)),
            s(p) ||
              (s(u)
                ? (s(p.fns) && (p = e[d] = ot(p, o)),
                  r(l.once) && (p = e[d] = i(l.name, p, l.capture)),
                  n(l.name, p, l.capture, l.passive, l.params))
                : p !== u && ((u.fns = p), (e[d] = u)));
        for (d in t) s(e[d]) && a((l = rt(d)).name, t[d], l.capture);
      }
      function pt(e, t, n) {
        var a;
        e instanceof fe && (e = e.data.hook || (e.data.hook = {}));
        var o = e[t];
        function d() {
          n.apply(this, arguments), v(a.fns, d);
        }
        s(o) ? (a = ot([d])) : i(o.fns) && r(o.merged) ? (a = o).fns.push(d) : (a = ot([o, d])),
          (a.merged = !0),
          (e[t] = a);
      }
      function ut(e, t, n, a, s) {
        if (i(t)) {
          if (_(t, n)) return (e[n] = t[n]), s || delete t[n], !0;
          if (_(t, a)) return (e[n] = t[a]), s || delete t[a], !0;
        }
        return !1;
      }
      function lt(e) {
        return o(e)
          ? [ve(e)]
          : Array.isArray(e)
          ? (function e(t, n) {
              var a,
                d,
                p,
                u,
                l = [];
              for (a = 0; a < t.length; a++)
                s((d = t[a])) ||
                  "boolean" == typeof d ||
                  ((p = l.length - 1),
                  (u = l[p]),
                  Array.isArray(d)
                    ? d.length > 0 &&
                      (yt((d = e(d, (n || "") + "_" + a))[0]) && yt(u) && ((l[p] = ve(u.text + d[0].text)), d.shift()),
                      l.push.apply(l, d))
                    : o(d)
                    ? yt(u)
                      ? (l[p] = ve(u.text + d))
                      : "" !== d && l.push(ve(d))
                    : yt(d) && yt(u)
                    ? (l[p] = ve(u.text + d.text))
                    : (r(t._isVList) && i(d.tag) && s(d.key) && i(n) && (d.key = "__vlist" + n + "_" + a + "__"),
                      l.push(d)));
              return l;
            })(e)
          : void 0;
      }
      function yt(e) {
        return i(e) && i(e.text) && !1 === e.isComment;
      }
      function mt(e, t) {
        if (e) {
          for (var n = Object.create(null), a = pe ? Reflect.ownKeys(e) : Object.keys(e), s = 0; s < a.length; s++) {
            var i = a[s];
            if ("__ob__" !== i) {
              for (var r = e[i].from, o = t; o; ) {
                if (o._provided && _(o._provided, r)) {
                  n[i] = o._provided[r];
                  break;
                }
                o = o.$parent;
              }
              if (!o)
                if ("default" in e[i]) {
                  var d = e[i].default;
                  n[i] = "function" == typeof d ? d.call(t) : d;
                } else 0;
            }
          }
          return n;
        }
      }
      function ct(e, t) {
        if (!e || !e.length) return {};
        for (var n = {}, a = 0, s = e.length; a < s; a++) {
          var i = e[a],
            r = i.data;
          if (
            (r && r.attrs && r.attrs.slot && delete r.attrs.slot,
            (i.context !== t && i.fnContext !== t) || !r || null == r.slot)
          )
            (n.default || (n.default = [])).push(i);
          else {
            var o = r.slot,
              d = n[o] || (n[o] = []);
            "template" === i.tag ? d.push.apply(d, i.children || []) : d.push(i);
          }
        }
        for (var p in n) n[p].every(Tt) && delete n[p];
        return n;
      }
      function Tt(e) {
        return (e.isComment && !e.asyncFactory) || " " === e.text;
      }
      function ft(e, t, n) {
        var s,
          i = Object.keys(t).length > 0,
          r = e ? !!e.$stable : !i,
          o = e && e.$key;
        if (e) {
          if (e._normalized) return e._normalized;
          if (r && n && n !== a && o === n.$key && !i && !n.$hasNormal) return n;
          for (var d in ((s = {}), e)) e[d] && "$" !== d[0] && (s[d] = bt(t, d, e[d]));
        } else s = {};
        for (var p in t) p in s || (s[p] = gt(t, p));
        return (
          e && Object.isExtensible(e) && (e._normalized = s),
          F(s, "$stable", r),
          F(s, "$key", o),
          F(s, "$hasNormal", i),
          s
        );
      }
      function bt(e, t, n) {
        var a = function () {
          var e = arguments.length ? n.apply(null, arguments) : n({});
          return (e = e && "object" == typeof e && !Array.isArray(e) ? [e] : lt(e)) &&
            (0 === e.length || (1 === e.length && e[0].isComment))
            ? void 0
            : e;
        };
        return n.proxy && Object.defineProperty(e, t, { get: a, enumerable: !0, configurable: !0 }), a;
      }
      function gt(e, t) {
        return function () {
          return e[t];
        };
      }
      function vt(e, t) {
        var n, a, s, r, o;
        if (Array.isArray(e) || "string" == typeof e)
          for (n = new Array(e.length), a = 0, s = e.length; a < s; a++) n[a] = t(e[a], a);
        else if ("number" == typeof e) for (n = new Array(e), a = 0; a < e; a++) n[a] = t(a + 1, a);
        else if (d(e))
          if (pe && e[Symbol.iterator]) {
            n = [];
            for (var p = e[Symbol.iterator](), u = p.next(); !u.done; ) n.push(t(u.value, n.length)), (u = p.next());
          } else
            for (r = Object.keys(e), n = new Array(r.length), a = 0, s = r.length; a < s; a++)
              (o = r[a]), (n[a] = t(e[o], o, a));
        return i(n) || (n = []), (n._isVList = !0), n;
      }
      function ht(e, t, n, a) {
        var s,
          i = this.$scopedSlots[e];
        i ? ((n = n || {}), a && (n = D(D({}, a), n)), (s = i(n) || t)) : (s = this.$slots[e] || t);
        var r = n && n.slot;
        return r ? this.$createElement("template", { slot: r }, s) : s;
      }
      function _t(e) {
        return Be(this.$options, "filters", e) || L;
      }
      function wt(e, t) {
        return Array.isArray(e) ? -1 === e.indexOf(t) : e !== t;
      }
      function kt(e, t, n, a, s) {
        var i = H.keyCodes[t] || n;
        return s && a && !H.keyCodes[t] ? wt(s, a) : i ? wt(i, e) : a ? S(a) !== t : void 0;
      }
      function Pt(e, t, n, a, s) {
        if (n)
          if (d(n)) {
            var i;
            Array.isArray(n) && (n = x(n));
            var r = function (r) {
              if ("class" === r || "style" === r || g(r)) i = e;
              else {
                var o = e.attrs && e.attrs.type;
                i = a || H.mustUseProp(t, o, r) ? e.domProps || (e.domProps = {}) : e.attrs || (e.attrs = {});
              }
              var d = P(r),
                p = S(r);
              d in i ||
                p in i ||
                ((i[r] = n[r]),
                s &&
                  ((e.on || (e.on = {}))["update:" + r] = function (e) {
                    n[r] = e;
                  }));
            };
            for (var o in n) r(o);
          } else;
        return e;
      }
      function Mt(e, t) {
        var n = this._staticTrees || (this._staticTrees = []),
          a = n[e];
        return (
          (a && !t) ||
            St((a = n[e] = this.$options.staticRenderFns[e].call(this._renderProxy, null, this)), "__static__" + e, !1),
          a
        );
      }
      function At(e, t, n) {
        return St(e, "__once__" + t + (n ? "_" + n : ""), !0), e;
      }
      function St(e, t, n) {
        if (Array.isArray(e))
          for (var a = 0; a < e.length; a++) e[a] && "string" != typeof e[a] && Ct(e[a], t + "_" + a, n);
        else Ct(e, t, n);
      }
      function Ct(e, t, n) {
        (e.isStatic = !0), (e.key = t), (e.isOnce = n);
      }
      function Rt(e, t) {
        if (t)
          if (u(t)) {
            var n = (e.on = e.on ? D({}, e.on) : {});
            for (var a in t) {
              var s = n[a],
                i = t[a];
              n[a] = s ? [].concat(s, i) : i;
            }
          } else;
        return e;
      }
      function Dt(e, t, n, a) {
        t = t || { $stable: !n };
        for (var s = 0; s < e.length; s++) {
          var i = e[s];
          Array.isArray(i) ? Dt(i, t, n) : i && (i.proxy && (i.fn.proxy = !0), (t[i.key] = i.fn));
        }
        return a && (t.$key = a), t;
      }
      function xt(e, t) {
        for (var n = 0; n < t.length; n += 2) {
          var a = t[n];
          "string" == typeof a && a && (e[t[n]] = t[n + 1]);
        }
        return e;
      }
      function Ot(e, t) {
        return "string" == typeof e ? t + e : e;
      }
      function It(e) {
        (e._o = At),
          (e._n = T),
          (e._s = c),
          (e._l = vt),
          (e._t = ht),
          (e._q = E),
          (e._i = q),
          (e._m = Mt),
          (e._f = _t),
          (e._k = kt),
          (e._b = Pt),
          (e._v = ve),
          (e._e = ge),
          (e._u = Dt),
          (e._g = Rt),
          (e._d = xt),
          (e._p = Ot);
      }
      function Lt(e, t, n, s, i) {
        var o,
          d = this,
          p = i.options;
        _(s, "_uid") ? ((o = Object.create(s))._original = s) : ((o = s), (s = s._original));
        var u = r(p._compiled),
          l = !u;
        (this.data = e),
          (this.props = t),
          (this.children = n),
          (this.parent = s),
          (this.listeners = e.on || a),
          (this.injections = mt(p.inject, s)),
          (this.slots = function () {
            return d.$slots || ft(e.scopedSlots, (d.$slots = ct(n, s))), d.$slots;
          }),
          Object.defineProperty(this, "scopedSlots", {
            enumerable: !0,
            get: function () {
              return ft(e.scopedSlots, this.slots());
            },
          }),
          u &&
            ((this.$options = p), (this.$slots = this.slots()), (this.$scopedSlots = ft(e.scopedSlots, this.$slots))),
          p._scopeId
            ? (this._c = function (e, t, n, a) {
                var i = $t(o, e, t, n, a, l);
                return i && !Array.isArray(i) && ((i.fnScopeId = p._scopeId), (i.fnContext = s)), i;
              })
            : (this._c = function (e, t, n, a) {
                return $t(o, e, t, n, a, l);
              });
      }
      function Et(e, t, n, a, s) {
        var i = he(e);
        return (i.fnContext = n), (i.fnOptions = a), t.slot && ((i.data || (i.data = {})).slot = t.slot), i;
      }
      function qt(e, t) {
        for (var n in t) e[P(n)] = t[n];
      }
      It(Lt.prototype);
      var Vt = {
          init: function (e, t) {
            if (e.componentInstance && !e.componentInstance._isDestroyed && e.data.keepAlive) {
              var n = e;
              Vt.prepatch(n, n);
            } else {
              (e.componentInstance = (function (e, t) {
                var n = { _isComponent: !0, _parentVnode: e, parent: t },
                  a = e.data.inlineTemplate;
                i(a) && ((n.render = a.render), (n.staticRenderFns = a.staticRenderFns));
                return new e.componentOptions.Ctor(n);
              })(e, Xt)).$mount(t ? e.elm : void 0, t);
            }
          },
          prepatch: function (e, t) {
            var n = t.componentOptions;
            !(function (e, t, n, s, i) {
              0;
              var r = s.data.scopedSlots,
                o = e.$scopedSlots,
                d = !!((r && !r.$stable) || (o !== a && !o.$stable) || (r && e.$scopedSlots.$key !== r.$key)),
                p = !!(i || e.$options._renderChildren || d);
              (e.$options._parentVnode = s), (e.$vnode = s), e._vnode && (e._vnode.parent = s);
              if (
                ((e.$options._renderChildren = i),
                (e.$attrs = s.data.attrs || a),
                (e.$listeners = n || a),
                t && e.$options.props)
              ) {
                Me(!1);
                for (var u = e._props, l = e.$options._propKeys || [], y = 0; y < l.length; y++) {
                  var m = l[y],
                    c = e.$options.props;
                  u[m] = He(m, c, t, e);
                }
                Me(!0), (e.$options.propsData = t);
              }
              n = n || a;
              var T = e.$options._parentListeners;
              (e.$options._parentListeners = n), Jt(e, n, T), p && ((e.$slots = ct(i, s.context)), e.$forceUpdate());
              0;
            })((t.componentInstance = e.componentInstance), n.propsData, n.listeners, t, n.children);
          },
          insert: function (e) {
            var t,
              n = e.context,
              a = e.componentInstance;
            a._isMounted || ((a._isMounted = !0), tn(a, "mounted")),
              e.data.keepAlive && (n._isMounted ? (((t = a)._inactive = !1), an.push(t)) : en(a, !0));
          },
          destroy: function (e) {
            var t = e.componentInstance;
            t._isDestroyed ||
              (e.data.keepAlive
                ? (function e(t, n) {
                    if (n && ((t._directInactive = !0), Qt(t))) return;
                    if (!t._inactive) {
                      t._inactive = !0;
                      for (var a = 0; a < t.$children.length; a++) e(t.$children[a]);
                      tn(t, "deactivated");
                    }
                  })(t, !0)
                : t.$destroy());
          },
        },
        Ut = Object.keys(Vt);
      function Bt(e, t, n, o, p) {
        if (!s(e)) {
          var u = n.$options._base;
          if ((d(e) && (e = u.extend(e)), "function" == typeof e)) {
            var l;
            if (
              s(e.cid) &&
              void 0 ===
                (e = (function (e, t) {
                  if (r(e.error) && i(e.errorComp)) return e.errorComp;
                  if (i(e.resolved)) return e.resolved;
                  var n = Ft;
                  n && i(e.owners) && -1 === e.owners.indexOf(n) && e.owners.push(n);
                  if (r(e.loading) && i(e.loadingComp)) return e.loadingComp;
                  if (n && !i(e.owners)) {
                    var a = (e.owners = [n]),
                      o = !0,
                      p = null,
                      u = null;
                    n.$on("hook:destroyed", function () {
                      return v(a, n);
                    });
                    var l = function (e) {
                        for (var t = 0, n = a.length; t < n; t++) a[t].$forceUpdate();
                        e &&
                          ((a.length = 0),
                          null !== p && (clearTimeout(p), (p = null)),
                          null !== u && (clearTimeout(u), (u = null)));
                      },
                      y = V(function (n) {
                        (e.resolved = Nt(n, t)), o ? (a.length = 0) : l(!0);
                      }),
                      c = V(function (t) {
                        i(e.errorComp) && ((e.error = !0), l(!0));
                      }),
                      T = e(y, c);
                    return (
                      d(T) &&
                        (m(T)
                          ? s(e.resolved) && T.then(y, c)
                          : m(T.component) &&
                            (T.component.then(y, c),
                            i(T.error) && (e.errorComp = Nt(T.error, t)),
                            i(T.loading) &&
                              ((e.loadingComp = Nt(T.loading, t)),
                              0 === T.delay
                                ? (e.loading = !0)
                                : (p = setTimeout(function () {
                                    (p = null), s(e.resolved) && s(e.error) && ((e.loading = !0), l(!1));
                                  }, T.delay || 200))),
                            i(T.timeout) &&
                              (u = setTimeout(function () {
                                (u = null), s(e.resolved) && c(null);
                              }, T.timeout)))),
                      (o = !1),
                      e.loading ? e.loadingComp : e.resolved
                    );
                  }
                })((l = e), u))
            )
              return (function (e, t, n, a, s) {
                var i = ge();
                return (i.asyncFactory = e), (i.asyncMeta = { data: t, context: n, children: a, tag: s }), i;
              })(l, t, n, o, p);
            (t = t || {}),
              Pn(e),
              i(t.model) &&
                (function (e, t) {
                  var n = (e.model && e.model.prop) || "value",
                    a = (e.model && e.model.event) || "input";
                  (t.attrs || (t.attrs = {}))[n] = t.model.value;
                  var s = t.on || (t.on = {}),
                    r = s[a],
                    o = t.model.callback;
                  i(r) ? (Array.isArray(r) ? -1 === r.indexOf(o) : r !== o) && (s[a] = [o].concat(r)) : (s[a] = o);
                })(e.options, t);
            var y = (function (e, t, n) {
              var a = t.options.props;
              if (!s(a)) {
                var r = {},
                  o = e.attrs,
                  d = e.props;
                if (i(o) || i(d))
                  for (var p in a) {
                    var u = S(p);
                    ut(r, d, p, u, !0) || ut(r, o, p, u, !1);
                  }
                return r;
              }
            })(t, e);
            if (r(e.options.functional))
              return (function (e, t, n, s, r) {
                var o = e.options,
                  d = {},
                  p = o.props;
                if (i(p)) for (var u in p) d[u] = He(u, p, t || a);
                else i(n.attrs) && qt(d, n.attrs), i(n.props) && qt(d, n.props);
                var l = new Lt(n, d, r, s, e),
                  y = o.render.call(null, l._c, l);
                if (y instanceof fe) return Et(y, n, l.parent, o, l);
                if (Array.isArray(y)) {
                  for (var m = lt(y) || [], c = new Array(m.length), T = 0; T < m.length; T++)
                    c[T] = Et(m[T], n, l.parent, o, l);
                  return c;
                }
              })(e, y, t, n, o);
            var c = t.on;
            if (((t.on = t.nativeOn), r(e.options.abstract))) {
              var T = t.slot;
              (t = {}), T && (t.slot = T);
            }
            !(function (e) {
              for (var t = e.hook || (e.hook = {}), n = 0; n < Ut.length; n++) {
                var a = Ut[n],
                  s = t[a],
                  i = Vt[a];
                s === i || (s && s._merged) || (t[a] = s ? Ht(i, s) : i);
              }
            })(t);
            var f = e.options.name || p;
            return new fe(
              "vue-component-" + e.cid + (f ? "-" + f : ""),
              t,
              void 0,
              void 0,
              void 0,
              n,
              { Ctor: e, propsData: y, listeners: c, tag: p, children: o },
              l,
            );
          }
        }
      }
      function Ht(e, t) {
        var n = function (n, a) {
          e(n, a), t(n, a);
        };
        return (n._merged = !0), n;
      }
      function $t(e, t, n, a, p, u) {
        return (
          (Array.isArray(n) || o(n)) && ((p = a), (a = n), (n = void 0)),
          r(u) && (p = 2),
          (function (e, t, n, a, o) {
            if (i(n) && i(n.__ob__)) return ge();
            i(n) && i(n.is) && (t = n.is);
            if (!t) return ge();
            0;
            Array.isArray(a) &&
              "function" == typeof a[0] &&
              (((n = n || {}).scopedSlots = { default: a[0] }), (a.length = 0));
            2 === o
              ? (a = lt(a))
              : 1 === o &&
                (a = (function (e) {
                  for (var t = 0; t < e.length; t++)
                    if (Array.isArray(e[t])) return Array.prototype.concat.apply([], e);
                  return e;
                })(a));
            var p, u;
            if ("string" == typeof t) {
              var l;
              (u = (e.$vnode && e.$vnode.ns) || H.getTagNamespace(t)),
                (p = H.isReservedTag(t)
                  ? new fe(H.parsePlatformTagName(t), n, a, void 0, void 0, e)
                  : (n && n.pre) || !i((l = Be(e.$options, "components", t)))
                  ? new fe(t, n, a, void 0, void 0, e)
                  : Bt(l, n, e, a, t));
            } else p = Bt(t, n, e, a);
            return Array.isArray(p)
              ? p
              : i(p)
              ? (i(u) &&
                  (function e(t, n, a) {
                    (t.ns = n), "foreignObject" === t.tag && ((n = void 0), (a = !0));
                    if (i(t.children))
                      for (var o = 0, d = t.children.length; o < d; o++) {
                        var p = t.children[o];
                        i(p.tag) && (s(p.ns) || (r(a) && "svg" !== p.tag)) && e(p, n, a);
                      }
                  })(p, u),
                i(n) &&
                  (function (e) {
                    d(e.style) && it(e.style);
                    d(e.class) && it(e.class);
                  })(n),
                p)
              : ge();
          })(e, t, n, a, p)
        );
      }
      var Wt,
        Ft = null;
      function Nt(e, t) {
        return (e.__esModule || (pe && "Module" === e[Symbol.toStringTag])) && (e = e.default), d(e) ? t.extend(e) : e;
      }
      function Yt(e) {
        return e.isComment && e.asyncFactory;
      }
      function jt(e) {
        if (Array.isArray(e))
          for (var t = 0; t < e.length; t++) {
            var n = e[t];
            if (i(n) && (i(n.componentOptions) || Yt(n))) return n;
          }
      }
      function zt(e, t) {
        Wt.$on(e, t);
      }
      function Gt(e, t) {
        Wt.$off(e, t);
      }
      function Kt(e, t) {
        var n = Wt;
        return function a() {
          var s = t.apply(null, arguments);
          null !== s && n.$off(e, a);
        };
      }
      function Jt(e, t, n) {
        (Wt = e), dt(t, n || {}, zt, Gt, Kt, e), (Wt = void 0);
      }
      var Xt = null;
      function Zt(e) {
        var t = Xt;
        return (
          (Xt = e),
          function () {
            Xt = t;
          }
        );
      }
      function Qt(e) {
        for (; e && (e = e.$parent); ) if (e._inactive) return !0;
        return !1;
      }
      function en(e, t) {
        if (t) {
          if (((e._directInactive = !1), Qt(e))) return;
        } else if (e._directInactive) return;
        if (e._inactive || null === e._inactive) {
          e._inactive = !1;
          for (var n = 0; n < e.$children.length; n++) en(e.$children[n]);
          tn(e, "activated");
        }
      }
      function tn(e, t) {
        ce();
        var n = e.$options[t],
          a = t + " hook";
        if (n) for (var s = 0, i = n.length; s < i; s++) Ye(n[s], e, null, e, a);
        e._hasHookEvent && e.$emit("hook:" + t), Te();
      }
      var nn = [],
        an = [],
        sn = {},
        rn = !1,
        on = !1,
        dn = 0;
      var pn = 0,
        un = Date.now;
      if (z && !X) {
        var ln = window.performance;
        ln &&
          "function" == typeof ln.now &&
          un() > document.createEvent("Event").timeStamp &&
          (un = function () {
            return ln.now();
          });
      }
      function yn() {
        var e, t;
        for (
          pn = un(),
            on = !0,
            nn.sort(function (e, t) {
              return e.id - t.id;
            }),
            dn = 0;
          dn < nn.length;
          dn++
        )
          (e = nn[dn]).before && e.before(), (t = e.id), (sn[t] = null), e.run();
        var n = an.slice(),
          a = nn.slice();
        (dn = nn.length = an.length = 0),
          (sn = {}),
          (rn = on = !1),
          (function (e) {
            for (var t = 0; t < e.length; t++) (e[t]._inactive = !0), en(e[t], !0);
          })(n),
          (function (e) {
            var t = e.length;
            for (; t--; ) {
              var n = e[t],
                a = n.vm;
              a._watcher === n && a._isMounted && !a._isDestroyed && tn(a, "updated");
            }
          })(a),
          re && H.devtools && re.emit("flush");
      }
      var mn = 0,
        cn = function (e, t, n, a, s) {
          (this.vm = e),
            s && (e._watcher = this),
            e._watchers.push(this),
            a
              ? ((this.deep = !!a.deep),
                (this.user = !!a.user),
                (this.lazy = !!a.lazy),
                (this.sync = !!a.sync),
                (this.before = a.before))
              : (this.deep = this.user = this.lazy = this.sync = !1),
            (this.cb = n),
            (this.id = ++mn),
            (this.active = !0),
            (this.dirty = this.lazy),
            (this.deps = []),
            (this.newDeps = []),
            (this.depIds = new de()),
            (this.newDepIds = new de()),
            (this.expression = ""),
            "function" == typeof t
              ? (this.getter = t)
              : ((this.getter = (function (e) {
                  if (!N.test(e)) {
                    var t = e.split(".");
                    return function (e) {
                      for (var n = 0; n < t.length; n++) {
                        if (!e) return;
                        e = e[t[n]];
                      }
                      return e;
                    };
                  }
                })(t)),
                this.getter || (this.getter = O)),
            (this.value = this.lazy ? void 0 : this.get());
        };
      (cn.prototype.get = function () {
        var e;
        ce(this);
        var t = this.vm;
        try {
          e = this.getter.call(t, t);
        } catch (e) {
          if (!this.user) throw e;
          Ne(e, t, 'getter for watcher "' + this.expression + '"');
        } finally {
          this.deep && it(e), Te(), this.cleanupDeps();
        }
        return e;
      }),
        (cn.prototype.addDep = function (e) {
          var t = e.id;
          this.newDepIds.has(t) || (this.newDepIds.add(t), this.newDeps.push(e), this.depIds.has(t) || e.addSub(this));
        }),
        (cn.prototype.cleanupDeps = function () {
          for (var e = this.deps.length; e--; ) {
            var t = this.deps[e];
            this.newDepIds.has(t.id) || t.removeSub(this);
          }
          var n = this.depIds;
          (this.depIds = this.newDepIds),
            (this.newDepIds = n),
            this.newDepIds.clear(),
            (n = this.deps),
            (this.deps = this.newDeps),
            (this.newDeps = n),
            (this.newDeps.length = 0);
        }),
        (cn.prototype.update = function () {
          this.lazy
            ? (this.dirty = !0)
            : this.sync
            ? this.run()
            : (function (e) {
                var t = e.id;
                if (null == sn[t]) {
                  if (((sn[t] = !0), on)) {
                    for (var n = nn.length - 1; n > dn && nn[n].id > e.id; ) n--;
                    nn.splice(n + 1, 0, e);
                  } else nn.push(e);
                  rn || ((rn = !0), at(yn));
                }
              })(this);
        }),
        (cn.prototype.run = function () {
          if (this.active) {
            var e = this.get();
            if (e !== this.value || d(e) || this.deep) {
              var t = this.value;
              if (((this.value = e), this.user))
                try {
                  this.cb.call(this.vm, e, t);
                } catch (e) {
                  Ne(e, this.vm, 'callback for watcher "' + this.expression + '"');
                }
              else this.cb.call(this.vm, e, t);
            }
          }
        }),
        (cn.prototype.evaluate = function () {
          (this.value = this.get()), (this.dirty = !1);
        }),
        (cn.prototype.depend = function () {
          for (var e = this.deps.length; e--; ) this.deps[e].depend();
        }),
        (cn.prototype.teardown = function () {
          if (this.active) {
            this.vm._isBeingDestroyed || v(this.vm._watchers, this);
            for (var e = this.deps.length; e--; ) this.deps[e].removeSub(this);
            this.active = !1;
          }
        });
      var Tn = { enumerable: !0, configurable: !0, get: O, set: O };
      function fn(e, t, n) {
        (Tn.get = function () {
          return this[t][n];
        }),
          (Tn.set = function (e) {
            this[t][n] = e;
          }),
          Object.defineProperty(e, n, Tn);
      }
      function bn(e) {
        e._watchers = [];
        var t = e.$options;
        t.props &&
          (function (e, t) {
            var n = e.$options.propsData || {},
              a = (e._props = {}),
              s = (e.$options._propKeys = []);
            e.$parent && Me(!1);
            var i = function (i) {
              s.push(i);
              var r = He(i, t, n, e);
              Ce(a, i, r), i in e || fn(e, "_props", i);
            };
            for (var r in t) i(r);
            Me(!0);
          })(e, t.props),
          t.methods &&
            (function (e, t) {
              e.$options.props;
              for (var n in t) e[n] = "function" != typeof t[n] ? O : C(t[n], e);
            })(e, t.methods),
          t.data
            ? (function (e) {
                var t = e.$options.data;
                u(
                  (t = e._data =
                    "function" == typeof t
                      ? (function (e, t) {
                          ce();
                          try {
                            return e.call(t, t);
                          } catch (e) {
                            return Ne(e, t, "data()"), {};
                          } finally {
                            Te();
                          }
                        })(t, e)
                      : t || {}),
                ) || (t = {});
                var n = Object.keys(t),
                  a = e.$options.props,
                  s = (e.$options.methods, n.length);
                for (; s--; ) {
                  var i = n[s];
                  0, (a && _(a, i)) || W(i) || fn(e, "_data", i);
                }
                Se(t, !0);
              })(e)
            : Se((e._data = {}), !0),
          t.computed &&
            (function (e, t) {
              var n = (e._computedWatchers = Object.create(null)),
                a = ie();
              for (var s in t) {
                var i = t[s],
                  r = "function" == typeof i ? i : i.get;
                0, a || (n[s] = new cn(e, r || O, O, gn)), s in e || vn(e, s, i);
              }
            })(e, t.computed),
          t.watch &&
            t.watch !== ne &&
            (function (e, t) {
              for (var n in t) {
                var a = t[n];
                if (Array.isArray(a)) for (var s = 0; s < a.length; s++) wn(e, n, a[s]);
                else wn(e, n, a);
              }
            })(e, t.watch);
      }
      var gn = { lazy: !0 };
      function vn(e, t, n) {
        var a = !ie();
        "function" == typeof n
          ? ((Tn.get = a ? hn(t) : _n(n)), (Tn.set = O))
          : ((Tn.get = n.get ? (a && !1 !== n.cache ? hn(t) : _n(n.get)) : O), (Tn.set = n.set || O)),
          Object.defineProperty(e, t, Tn);
      }
      function hn(e) {
        return function () {
          var t = this._computedWatchers && this._computedWatchers[e];
          if (t) return t.dirty && t.evaluate(), ye.target && t.depend(), t.value;
        };
      }
      function _n(e) {
        return function () {
          return e.call(this, this);
        };
      }
      function wn(e, t, n, a) {
        return u(n) && ((a = n), (n = n.handler)), "string" == typeof n && (n = e[n]), e.$watch(t, n, a);
      }
      var kn = 0;
      function Pn(e) {
        var t = e.options;
        if (e.super) {
          var n = Pn(e.super);
          if (n !== e.superOptions) {
            e.superOptions = n;
            var a = (function (e) {
              var t,
                n = e.options,
                a = e.sealedOptions;
              for (var s in n) n[s] !== a[s] && (t || (t = {}), (t[s] = n[s]));
              return t;
            })(e);
            a && D(e.extendOptions, a), (t = e.options = Ue(n, e.extendOptions)).name && (t.components[t.name] = e);
          }
        }
        return t;
      }
      function Mn(e) {
        this._init(e);
      }
      function An(e) {
        e.cid = 0;
        var t = 1;
        e.extend = function (e) {
          e = e || {};
          var n = this,
            a = n.cid,
            s = e._Ctor || (e._Ctor = {});
          if (s[a]) return s[a];
          var i = e.name || n.options.name;
          var r = function (e) {
            this._init(e);
          };
          return (
            ((r.prototype = Object.create(n.prototype)).constructor = r),
            (r.cid = t++),
            (r.options = Ue(n.options, e)),
            (r.super = n),
            r.options.props &&
              (function (e) {
                var t = e.options.props;
                for (var n in t) fn(e.prototype, "_props", n);
              })(r),
            r.options.computed &&
              (function (e) {
                var t = e.options.computed;
                for (var n in t) vn(e.prototype, n, t[n]);
              })(r),
            (r.extend = n.extend),
            (r.mixin = n.mixin),
            (r.use = n.use),
            U.forEach(function (e) {
              r[e] = n[e];
            }),
            i && (r.options.components[i] = r),
            (r.superOptions = n.options),
            (r.extendOptions = e),
            (r.sealedOptions = D({}, r.options)),
            (s[a] = r),
            r
          );
        };
      }
      function Sn(e) {
        return e && (e.Ctor.options.name || e.tag);
      }
      function Cn(e, t) {
        return Array.isArray(e)
          ? e.indexOf(t) > -1
          : "string" == typeof e
          ? e.split(",").indexOf(t) > -1
          : !!l(e) && e.test(t);
      }
      function Rn(e, t) {
        var n = e.cache,
          a = e.keys,
          s = e._vnode;
        for (var i in n) {
          var r = n[i];
          if (r) {
            var o = Sn(r.componentOptions);
            o && !t(o) && Dn(n, i, a, s);
          }
        }
      }
      function Dn(e, t, n, a) {
        var s = e[t];
        !s || (a && s.tag === a.tag) || s.componentInstance.$destroy(), (e[t] = null), v(n, t);
      }
      !(function (e) {
        e.prototype._init = function (e) {
          var t = this;
          (t._uid = kn++),
            (t._isVue = !0),
            e && e._isComponent
              ? (function (e, t) {
                  var n = (e.$options = Object.create(e.constructor.options)),
                    a = t._parentVnode;
                  (n.parent = t.parent), (n._parentVnode = a);
                  var s = a.componentOptions;
                  (n.propsData = s.propsData),
                    (n._parentListeners = s.listeners),
                    (n._renderChildren = s.children),
                    (n._componentTag = s.tag),
                    t.render && ((n.render = t.render), (n.staticRenderFns = t.staticRenderFns));
                })(t, e)
              : (t.$options = Ue(Pn(t.constructor), e || {}, t)),
            (t._renderProxy = t),
            (t._self = t),
            (function (e) {
              var t = e.$options,
                n = t.parent;
              if (n && !t.abstract) {
                for (; n.$options.abstract && n.$parent; ) n = n.$parent;
                n.$children.push(e);
              }
              (e.$parent = n),
                (e.$root = n ? n.$root : e),
                (e.$children = []),
                (e.$refs = {}),
                (e._watcher = null),
                (e._inactive = null),
                (e._directInactive = !1),
                (e._isMounted = !1),
                (e._isDestroyed = !1),
                (e._isBeingDestroyed = !1);
            })(t),
            (function (e) {
              (e._events = Object.create(null)), (e._hasHookEvent = !1);
              var t = e.$options._parentListeners;
              t && Jt(e, t);
            })(t),
            (function (e) {
              (e._vnode = null), (e._staticTrees = null);
              var t = e.$options,
                n = (e.$vnode = t._parentVnode),
                s = n && n.context;
              (e.$slots = ct(t._renderChildren, s)),
                (e.$scopedSlots = a),
                (e._c = function (t, n, a, s) {
                  return $t(e, t, n, a, s, !1);
                }),
                (e.$createElement = function (t, n, a, s) {
                  return $t(e, t, n, a, s, !0);
                });
              var i = n && n.data;
              Ce(e, "$attrs", (i && i.attrs) || a, null, !0), Ce(e, "$listeners", t._parentListeners || a, null, !0);
            })(t),
            tn(t, "beforeCreate"),
            (function (e) {
              var t = mt(e.$options.inject, e);
              t &&
                (Me(!1),
                Object.keys(t).forEach(function (n) {
                  Ce(e, n, t[n]);
                }),
                Me(!0));
            })(t),
            bn(t),
            (function (e) {
              var t = e.$options.provide;
              t && (e._provided = "function" == typeof t ? t.call(e) : t);
            })(t),
            tn(t, "created"),
            t.$options.el && t.$mount(t.$options.el);
        };
      })(Mn),
        (function (e) {
          var t = {
              get: function () {
                return this._data;
              },
            },
            n = {
              get: function () {
                return this._props;
              },
            };
          Object.defineProperty(e.prototype, "$data", t),
            Object.defineProperty(e.prototype, "$props", n),
            (e.prototype.$set = Re),
            (e.prototype.$delete = De),
            (e.prototype.$watch = function (e, t, n) {
              if (u(t)) return wn(this, e, t, n);
              (n = n || {}).user = !0;
              var a = new cn(this, e, t, n);
              if (n.immediate)
                try {
                  t.call(this, a.value);
                } catch (e) {
                  Ne(e, this, 'callback for immediate watcher "' + a.expression + '"');
                }
              return function () {
                a.teardown();
              };
            });
        })(Mn),
        (function (e) {
          var t = /^hook:/;
          (e.prototype.$on = function (e, n) {
            var a = this;
            if (Array.isArray(e)) for (var s = 0, i = e.length; s < i; s++) a.$on(e[s], n);
            else (a._events[e] || (a._events[e] = [])).push(n), t.test(e) && (a._hasHookEvent = !0);
            return a;
          }),
            (e.prototype.$once = function (e, t) {
              var n = this;
              function a() {
                n.$off(e, a), t.apply(n, arguments);
              }
              return (a.fn = t), n.$on(e, a), n;
            }),
            (e.prototype.$off = function (e, t) {
              var n = this;
              if (!arguments.length) return (n._events = Object.create(null)), n;
              if (Array.isArray(e)) {
                for (var a = 0, s = e.length; a < s; a++) n.$off(e[a], t);
                return n;
              }
              var i,
                r = n._events[e];
              if (!r) return n;
              if (!t) return (n._events[e] = null), n;
              for (var o = r.length; o--; )
                if ((i = r[o]) === t || i.fn === t) {
                  r.splice(o, 1);
                  break;
                }
              return n;
            }),
            (e.prototype.$emit = function (e) {
              var t = this,
                n = t._events[e];
              if (n) {
                n = n.length > 1 ? R(n) : n;
                for (var a = R(arguments, 1), s = 'event handler for "' + e + '"', i = 0, r = n.length; i < r; i++)
                  Ye(n[i], t, a, t, s);
              }
              return t;
            });
        })(Mn),
        (function (e) {
          (e.prototype._update = function (e, t) {
            var n = this,
              a = n.$el,
              s = n._vnode,
              i = Zt(n);
            (n._vnode = e),
              (n.$el = s ? n.__patch__(s, e) : n.__patch__(n.$el, e, t, !1)),
              i(),
              a && (a.__vue__ = null),
              n.$el && (n.$el.__vue__ = n),
              n.$vnode && n.$parent && n.$vnode === n.$parent._vnode && (n.$parent.$el = n.$el);
          }),
            (e.prototype.$forceUpdate = function () {
              this._watcher && this._watcher.update();
            }),
            (e.prototype.$destroy = function () {
              var e = this;
              if (!e._isBeingDestroyed) {
                tn(e, "beforeDestroy"), (e._isBeingDestroyed = !0);
                var t = e.$parent;
                !t || t._isBeingDestroyed || e.$options.abstract || v(t.$children, e),
                  e._watcher && e._watcher.teardown();
                for (var n = e._watchers.length; n--; ) e._watchers[n].teardown();
                e._data.__ob__ && e._data.__ob__.vmCount--,
                  (e._isDestroyed = !0),
                  e.__patch__(e._vnode, null),
                  tn(e, "destroyed"),
                  e.$off(),
                  e.$el && (e.$el.__vue__ = null),
                  e.$vnode && (e.$vnode.parent = null);
              }
            });
        })(Mn),
        (function (e) {
          It(e.prototype),
            (e.prototype.$nextTick = function (e) {
              return at(e, this);
            }),
            (e.prototype._render = function () {
              var e,
                t = this,
                n = t.$options,
                a = n.render,
                s = n._parentVnode;
              s && (t.$scopedSlots = ft(s.data.scopedSlots, t.$slots, t.$scopedSlots)), (t.$vnode = s);
              try {
                (Ft = t), (e = a.call(t._renderProxy, t.$createElement));
              } catch (n) {
                Ne(n, t, "render"), (e = t._vnode);
              } finally {
                Ft = null;
              }
              return Array.isArray(e) && 1 === e.length && (e = e[0]), e instanceof fe || (e = ge()), (e.parent = s), e;
            });
        })(Mn);
      var xn = [String, RegExp, Array],
        On = {
          KeepAlive: {
            name: "keep-alive",
            abstract: !0,
            props: { include: xn, exclude: xn, max: [String, Number] },
            created: function () {
              (this.cache = Object.create(null)), (this.keys = []);
            },
            destroyed: function () {
              for (var e in this.cache) Dn(this.cache, e, this.keys);
            },
            mounted: function () {
              var e = this;
              this.$watch("include", function (t) {
                Rn(e, function (e) {
                  return Cn(t, e);
                });
              }),
                this.$watch("exclude", function (t) {
                  Rn(e, function (e) {
                    return !Cn(t, e);
                  });
                });
            },
            render: function () {
              var e = this.$slots.default,
                t = jt(e),
                n = t && t.componentOptions;
              if (n) {
                var a = Sn(n),
                  s = this.include,
                  i = this.exclude;
                if ((s && (!a || !Cn(s, a))) || (i && a && Cn(i, a))) return t;
                var r = this.cache,
                  o = this.keys,
                  d = null == t.key ? n.Ctor.cid + (n.tag ? "::" + n.tag : "") : t.key;
                r[d]
                  ? ((t.componentInstance = r[d].componentInstance), v(o, d), o.push(d))
                  : ((r[d] = t), o.push(d), this.max && o.length > parseInt(this.max) && Dn(r, o[0], o, this._vnode)),
                  (t.data.keepAlive = !0);
              }
              return t || (e && e[0]);
            },
          },
        };
      !(function (e) {
        var t = {
          get: function () {
            return H;
          },
        };
        Object.defineProperty(e, "config", t),
          (e.util = { warn: ue, extend: D, mergeOptions: Ue, defineReactive: Ce }),
          (e.set = Re),
          (e.delete = De),
          (e.nextTick = at),
          (e.observable = function (e) {
            return Se(e), e;
          }),
          (e.options = Object.create(null)),
          U.forEach(function (t) {
            e.options[t + "s"] = Object.create(null);
          }),
          (e.options._base = e),
          D(e.options.components, On),
          (function (e) {
            e.use = function (e) {
              var t = this._installedPlugins || (this._installedPlugins = []);
              if (t.indexOf(e) > -1) return this;
              var n = R(arguments, 1);
              return (
                n.unshift(this),
                "function" == typeof e.install ? e.install.apply(e, n) : "function" == typeof e && e.apply(null, n),
                t.push(e),
                this
              );
            };
          })(e),
          (function (e) {
            e.mixin = function (e) {
              return (this.options = Ue(this.options, e)), this;
            };
          })(e),
          An(e),
          (function (e) {
            U.forEach(function (t) {
              e[t] = function (e, n) {
                return n
                  ? ("component" === t && u(n) && ((n.name = n.name || e), (n = this.options._base.extend(n))),
                    "directive" === t && "function" == typeof n && (n = { bind: n, update: n }),
                    (this.options[t + "s"][e] = n),
                    n)
                  : this.options[t + "s"][e];
              };
            });
          })(e);
      })(Mn),
        Object.defineProperty(Mn.prototype, "$isServer", { get: ie }),
        Object.defineProperty(Mn.prototype, "$ssrContext", {
          get: function () {
            return this.$vnode && this.$vnode.ssrContext;
          },
        }),
        Object.defineProperty(Mn, "FunctionalRenderContext", { value: Lt }),
        (Mn.version = "2.6.12");
      var In = f("style,class"),
        Ln = f("input,textarea,option,select,progress"),
        En = function (e, t, n) {
          return (
            ("value" === n && Ln(e) && "button" !== t) ||
            ("selected" === n && "option" === e) ||
            ("checked" === n && "input" === e) ||
            ("muted" === n && "video" === e)
          );
        },
        qn = f("contenteditable,draggable,spellcheck"),
        Vn = f("events,caret,typing,plaintext-only"),
        Un = f(
          "allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,translate,truespeed,typemustmatch,visible",
        ),
        Bn = "http://www.w3.org/1999/xlink",
        Hn = function (e) {
          return ":" === e.charAt(5) && "xlink" === e.slice(0, 5);
        },
        $n = function (e) {
          return Hn(e) ? e.slice(6, e.length) : "";
        },
        Wn = function (e) {
          return null == e || !1 === e;
        };
      function Fn(e) {
        for (var t = e.data, n = e, a = e; i(a.componentInstance); )
          (a = a.componentInstance._vnode) && a.data && (t = Nn(a.data, t));
        for (; i((n = n.parent)); ) n && n.data && (t = Nn(t, n.data));
        return (function (e, t) {
          if (i(e) || i(t)) return Yn(e, jn(t));
          return "";
        })(t.staticClass, t.class);
      }
      function Nn(e, t) {
        return { staticClass: Yn(e.staticClass, t.staticClass), class: i(e.class) ? [e.class, t.class] : t.class };
      }
      function Yn(e, t) {
        return e ? (t ? e + " " + t : e) : t || "";
      }
      function jn(e) {
        return Array.isArray(e)
          ? (function (e) {
              for (var t, n = "", a = 0, s = e.length; a < s; a++)
                i((t = jn(e[a]))) && "" !== t && (n && (n += " "), (n += t));
              return n;
            })(e)
          : d(e)
          ? (function (e) {
              var t = "";
              for (var n in e) e[n] && (t && (t += " "), (t += n));
              return t;
            })(e)
          : "string" == typeof e
          ? e
          : "";
      }
      var zn = { svg: "http://www.w3.org/2000/svg", math: "http://www.w3.org/1998/Math/MathML" },
        Gn = f(
          "html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot",
        ),
        Kn = f(
          "svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",
          !0,
        ),
        Jn = function (e) {
          return Gn(e) || Kn(e);
        };
      function Xn(e) {
        return Kn(e) ? "svg" : "math" === e ? "math" : void 0;
      }
      var Zn = Object.create(null);
      var Qn = f("text,number,password,search,email,tel,url");
      function ea(e) {
        if ("string" == typeof e) {
          var t = document.querySelector(e);
          return t || document.createElement("div");
        }
        return e;
      }
      var ta = Object.freeze({
          createElement: function (e, t) {
            var n = document.createElement(e);
            return (
              "select" !== e ||
                (t.data && t.data.attrs && void 0 !== t.data.attrs.multiple && n.setAttribute("multiple", "multiple")),
              n
            );
          },
          createElementNS: function (e, t) {
            return document.createElementNS(zn[e], t);
          },
          createTextNode: function (e) {
            return document.createTextNode(e);
          },
          createComment: function (e) {
            return document.createComment(e);
          },
          insertBefore: function (e, t, n) {
            e.insertBefore(t, n);
          },
          removeChild: function (e, t) {
            e.removeChild(t);
          },
          appendChild: function (e, t) {
            e.appendChild(t);
          },
          parentNode: function (e) {
            return e.parentNode;
          },
          nextSibling: function (e) {
            return e.nextSibling;
          },
          tagName: function (e) {
            return e.tagName;
          },
          setTextContent: function (e, t) {
            e.textContent = t;
          },
          setStyleScope: function (e, t) {
            e.setAttribute(t, "");
          },
        }),
        na = {
          create: function (e, t) {
            aa(t);
          },
          update: function (e, t) {
            e.data.ref !== t.data.ref && (aa(e, !0), aa(t));
          },
          destroy: function (e) {
            aa(e, !0);
          },
        };
      function aa(e, t) {
        var n = e.data.ref;
        if (i(n)) {
          var a = e.context,
            s = e.componentInstance || e.elm,
            r = a.$refs;
          t
            ? Array.isArray(r[n])
              ? v(r[n], s)
              : r[n] === s && (r[n] = void 0)
            : e.data.refInFor
            ? Array.isArray(r[n])
              ? r[n].indexOf(s) < 0 && r[n].push(s)
              : (r[n] = [s])
            : (r[n] = s);
        }
      }
      var sa = new fe("", {}, []),
        ia = ["create", "activate", "update", "remove", "destroy"];
      function ra(e, t) {
        return (
          e.key === t.key &&
          ((e.tag === t.tag &&
            e.isComment === t.isComment &&
            i(e.data) === i(t.data) &&
            (function (e, t) {
              if ("input" !== e.tag) return !0;
              var n,
                a = i((n = e.data)) && i((n = n.attrs)) && n.type,
                s = i((n = t.data)) && i((n = n.attrs)) && n.type;
              return a === s || (Qn(a) && Qn(s));
            })(e, t)) ||
            (r(e.isAsyncPlaceholder) && e.asyncFactory === t.asyncFactory && s(t.asyncFactory.error)))
        );
      }
      function oa(e, t, n) {
        var a,
          s,
          r = {};
        for (a = t; a <= n; ++a) i((s = e[a].key)) && (r[s] = a);
        return r;
      }
      var da = {
        create: pa,
        update: pa,
        destroy: function (e) {
          pa(e, sa);
        },
      };
      function pa(e, t) {
        (e.data.directives || t.data.directives) &&
          (function (e, t) {
            var n,
              a,
              s,
              i = e === sa,
              r = t === sa,
              o = la(e.data.directives, e.context),
              d = la(t.data.directives, t.context),
              p = [],
              u = [];
            for (n in d)
              (a = o[n]),
                (s = d[n]),
                a
                  ? ((s.oldValue = a.value),
                    (s.oldArg = a.arg),
                    ma(s, "update", t, e),
                    s.def && s.def.componentUpdated && u.push(s))
                  : (ma(s, "bind", t, e), s.def && s.def.inserted && p.push(s));
            if (p.length) {
              var l = function () {
                for (var n = 0; n < p.length; n++) ma(p[n], "inserted", t, e);
              };
              i ? pt(t, "insert", l) : l();
            }
            u.length &&
              pt(t, "postpatch", function () {
                for (var n = 0; n < u.length; n++) ma(u[n], "componentUpdated", t, e);
              });
            if (!i) for (n in o) d[n] || ma(o[n], "unbind", e, e, r);
          })(e, t);
      }
      var ua = Object.create(null);
      function la(e, t) {
        var n,
          a,
          s = Object.create(null);
        if (!e) return s;
        for (n = 0; n < e.length; n++)
          (a = e[n]).modifiers || (a.modifiers = ua), (s[ya(a)] = a), (a.def = Be(t.$options, "directives", a.name));
        return s;
      }
      function ya(e) {
        return e.rawName || e.name + "." + Object.keys(e.modifiers || {}).join(".");
      }
      function ma(e, t, n, a, s) {
        var i = e.def && e.def[t];
        if (i)
          try {
            i(n.elm, e, n, a, s);
          } catch (a) {
            Ne(a, n.context, "directive " + e.name + " " + t + " hook");
          }
      }
      var ca = [na, da];
      function Ta(e, t) {
        var n = t.componentOptions;
        if (!((i(n) && !1 === n.Ctor.options.inheritAttrs) || (s(e.data.attrs) && s(t.data.attrs)))) {
          var a,
            r,
            o = t.elm,
            d = e.data.attrs || {},
            p = t.data.attrs || {};
          for (a in (i(p.__ob__) && (p = t.data.attrs = D({}, p)), p)) (r = p[a]), d[a] !== r && fa(o, a, r);
          for (a in ((X || Q) && p.value !== d.value && fa(o, "value", p.value), d))
            s(p[a]) && (Hn(a) ? o.removeAttributeNS(Bn, $n(a)) : qn(a) || o.removeAttribute(a));
        }
      }
      function fa(e, t, n) {
        e.tagName.indexOf("-") > -1
          ? ba(e, t, n)
          : Un(t)
          ? Wn(n)
            ? e.removeAttribute(t)
            : ((n = "allowfullscreen" === t && "EMBED" === e.tagName ? "true" : t), e.setAttribute(t, n))
          : qn(t)
          ? e.setAttribute(
              t,
              (function (e, t) {
                return Wn(t) || "false" === t ? "false" : "contenteditable" === e && Vn(t) ? t : "true";
              })(t, n),
            )
          : Hn(t)
          ? Wn(n)
            ? e.removeAttributeNS(Bn, $n(t))
            : e.setAttributeNS(Bn, t, n)
          : ba(e, t, n);
      }
      function ba(e, t, n) {
        if (Wn(n)) e.removeAttribute(t);
        else {
          if (X && !Z && "TEXTAREA" === e.tagName && "placeholder" === t && "" !== n && !e.__ieph) {
            var a = function (t) {
              t.stopImmediatePropagation(), e.removeEventListener("input", a);
            };
            e.addEventListener("input", a), (e.__ieph = !0);
          }
          e.setAttribute(t, n);
        }
      }
      var ga = { create: Ta, update: Ta };
      function va(e, t) {
        var n = t.elm,
          a = t.data,
          r = e.data;
        if (!(s(a.staticClass) && s(a.class) && (s(r) || (s(r.staticClass) && s(r.class))))) {
          var o = Fn(t),
            d = n._transitionClasses;
          i(d) && (o = Yn(o, jn(d))), o !== n._prevClass && (n.setAttribute("class", o), (n._prevClass = o));
        }
      }
      var ha,
        _a,
        wa,
        ka,
        Pa,
        Ma,
        Aa = { create: va, update: va },
        Sa = /[\w).+\-_$\]]/;
      function Ca(e) {
        var t,
          n,
          a,
          s,
          i,
          r = !1,
          o = !1,
          d = !1,
          p = !1,
          u = 0,
          l = 0,
          y = 0,
          m = 0;
        for (a = 0; a < e.length; a++)
          if (((n = t), (t = e.charCodeAt(a)), r)) 39 === t && 92 !== n && (r = !1);
          else if (o) 34 === t && 92 !== n && (o = !1);
          else if (d) 96 === t && 92 !== n && (d = !1);
          else if (p) 47 === t && 92 !== n && (p = !1);
          else if (124 !== t || 124 === e.charCodeAt(a + 1) || 124 === e.charCodeAt(a - 1) || u || l || y) {
            switch (t) {
              case 34:
                o = !0;
                break;
              case 39:
                r = !0;
                break;
              case 96:
                d = !0;
                break;
              case 40:
                y++;
                break;
              case 41:
                y--;
                break;
              case 91:
                l++;
                break;
              case 93:
                l--;
                break;
              case 123:
                u++;
                break;
              case 125:
                u--;
            }
            if (47 === t) {
              for (var c = a - 1, T = void 0; c >= 0 && " " === (T = e.charAt(c)); c--);
              (T && Sa.test(T)) || (p = !0);
            }
          } else void 0 === s ? ((m = a + 1), (s = e.slice(0, a).trim())) : f();
        function f() {
          (i || (i = [])).push(e.slice(m, a).trim()), (m = a + 1);
        }
        if ((void 0 === s ? (s = e.slice(0, a).trim()) : 0 !== m && f(), i))
          for (a = 0; a < i.length; a++) s = Ra(s, i[a]);
        return s;
      }
      function Ra(e, t) {
        var n = t.indexOf("(");
        if (n < 0) return '_f("' + t + '")(' + e + ")";
        var a = t.slice(0, n),
          s = t.slice(n + 1);
        return '_f("' + a + '")(' + e + (")" !== s ? "," + s : s);
      }
      function Da(e, t) {
        console.error("[Vue compiler]: " + e);
      }
      function xa(e, t) {
        return e
          ? e
              .map(function (e) {
                return e[t];
              })
              .filter(function (e) {
                return e;
              })
          : [];
      }
      function Oa(e, t, n, a, s) {
        (e.props || (e.props = [])).push($a({ name: t, value: n, dynamic: s }, a)), (e.plain = !1);
      }
      function Ia(e, t, n, a, s) {
        (s ? e.dynamicAttrs || (e.dynamicAttrs = []) : e.attrs || (e.attrs = [])).push(
          $a({ name: t, value: n, dynamic: s }, a),
        ),
          (e.plain = !1);
      }
      function La(e, t, n, a) {
        (e.attrsMap[t] = n), e.attrsList.push($a({ name: t, value: n }, a));
      }
      function Ea(e, t, n, a, s, i, r, o) {
        (e.directives || (e.directives = [])).push(
          $a({ name: t, rawName: n, value: a, arg: s, isDynamicArg: i, modifiers: r }, o),
        ),
          (e.plain = !1);
      }
      function qa(e, t, n) {
        return n ? "_p(" + t + ',"' + e + '")' : e + t;
      }
      function Va(e, t, n, s, i, r, o, d) {
        var p;
        (s = s || a).right
          ? d
            ? (t = "(" + t + ")==='click'?'contextmenu':(" + t + ")")
            : "click" === t && ((t = "contextmenu"), delete s.right)
          : s.middle && (d ? (t = "(" + t + ")==='click'?'mouseup':(" + t + ")") : "click" === t && (t = "mouseup")),
          s.capture && (delete s.capture, (t = qa("!", t, d))),
          s.once && (delete s.once, (t = qa("~", t, d))),
          s.passive && (delete s.passive, (t = qa("&", t, d))),
          s.native
            ? (delete s.native, (p = e.nativeEvents || (e.nativeEvents = {})))
            : (p = e.events || (e.events = {}));
        var u = $a({ value: n.trim(), dynamic: d }, o);
        s !== a && (u.modifiers = s);
        var l = p[t];
        Array.isArray(l) ? (i ? l.unshift(u) : l.push(u)) : (p[t] = l ? (i ? [u, l] : [l, u]) : u), (e.plain = !1);
      }
      function Ua(e, t, n) {
        var a = Ba(e, ":" + t) || Ba(e, "v-bind:" + t);
        if (null != a) return Ca(a);
        if (!1 !== n) {
          var s = Ba(e, t);
          if (null != s) return JSON.stringify(s);
        }
      }
      function Ba(e, t, n) {
        var a;
        if (null != (a = e.attrsMap[t]))
          for (var s = e.attrsList, i = 0, r = s.length; i < r; i++)
            if (s[i].name === t) {
              s.splice(i, 1);
              break;
            }
        return n && delete e.attrsMap[t], a;
      }
      function Ha(e, t) {
        for (var n = e.attrsList, a = 0, s = n.length; a < s; a++) {
          var i = n[a];
          if (t.test(i.name)) return n.splice(a, 1), i;
        }
      }
      function $a(e, t) {
        return t && (null != t.start && (e.start = t.start), null != t.end && (e.end = t.end)), e;
      }
      function Wa(e, t, n) {
        var a = n || {},
          s = a.number,
          i = "$$v";
        a.trim && (i = "(typeof $$v === 'string'? $$v.trim(): $$v)"), s && (i = "_n(" + i + ")");
        var r = Fa(t, i);
        e.model = { value: "(" + t + ")", expression: JSON.stringify(t), callback: "function ($$v) {" + r + "}" };
      }
      function Fa(e, t) {
        var n = (function (e) {
          if (((e = e.trim()), (ha = e.length), e.indexOf("[") < 0 || e.lastIndexOf("]") < ha - 1))
            return (ka = e.lastIndexOf(".")) > -1
              ? { exp: e.slice(0, ka), key: '"' + e.slice(ka + 1) + '"' }
              : { exp: e, key: null };
          (_a = e), (ka = Pa = Ma = 0);
          for (; !Ya(); ) ja((wa = Na())) ? Ga(wa) : 91 === wa && za(wa);
          return { exp: e.slice(0, Pa), key: e.slice(Pa + 1, Ma) };
        })(e);
        return null === n.key ? e + "=" + t : "$set(" + n.exp + ", " + n.key + ", " + t + ")";
      }
      function Na() {
        return _a.charCodeAt(++ka);
      }
      function Ya() {
        return ka >= ha;
      }
      function ja(e) {
        return 34 === e || 39 === e;
      }
      function za(e) {
        var t = 1;
        for (Pa = ka; !Ya(); )
          if (ja((e = Na()))) Ga(e);
          else if ((91 === e && t++, 93 === e && t--, 0 === t)) {
            Ma = ka;
            break;
          }
      }
      function Ga(e) {
        for (var t = e; !Ya() && (e = Na()) !== t; );
      }
      var Ka;
      function Ja(e, t, n) {
        var a = Ka;
        return function s() {
          var i = t.apply(null, arguments);
          null !== i && Qa(e, s, n, a);
        };
      }
      var Xa = Ke && !(te && Number(te[1]) <= 53);
      function Za(e, t, n, a) {
        if (Xa) {
          var s = pn,
            i = t;
          t = i._wrapper = function (e) {
            if (
              e.target === e.currentTarget ||
              e.timeStamp >= s ||
              e.timeStamp <= 0 ||
              e.target.ownerDocument !== document
            )
              return i.apply(this, arguments);
          };
        }
        Ka.addEventListener(e, t, ae ? { capture: n, passive: a } : n);
      }
      function Qa(e, t, n, a) {
        (a || Ka).removeEventListener(e, t._wrapper || t, n);
      }
      function es(e, t) {
        if (!s(e.data.on) || !s(t.data.on)) {
          var n = t.data.on || {},
            a = e.data.on || {};
          (Ka = t.elm),
            (function (e) {
              if (i(e.__r)) {
                var t = X ? "change" : "input";
                (e[t] = [].concat(e.__r, e[t] || [])), delete e.__r;
              }
              i(e.__c) && ((e.change = [].concat(e.__c, e.change || [])), delete e.__c);
            })(n),
            dt(n, a, Za, Qa, Ja, t.context),
            (Ka = void 0);
        }
      }
      var ts,
        ns = { create: es, update: es };
      function as(e, t) {
        if (!s(e.data.domProps) || !s(t.data.domProps)) {
          var n,
            a,
            r = t.elm,
            o = e.data.domProps || {},
            d = t.data.domProps || {};
          for (n in (i(d.__ob__) && (d = t.data.domProps = D({}, d)), o)) n in d || (r[n] = "");
          for (n in d) {
            if (((a = d[n]), "textContent" === n || "innerHTML" === n)) {
              if ((t.children && (t.children.length = 0), a === o[n])) continue;
              1 === r.childNodes.length && r.removeChild(r.childNodes[0]);
            }
            if ("value" === n && "PROGRESS" !== r.tagName) {
              r._value = a;
              var p = s(a) ? "" : String(a);
              ss(r, p) && (r.value = p);
            } else if ("innerHTML" === n && Kn(r.tagName) && s(r.innerHTML)) {
              (ts = ts || document.createElement("div")).innerHTML = "<svg>" + a + "</svg>";
              for (var u = ts.firstChild; r.firstChild; ) r.removeChild(r.firstChild);
              for (; u.firstChild; ) r.appendChild(u.firstChild);
            } else if (a !== o[n])
              try {
                r[n] = a;
              } catch (e) {}
          }
        }
      }
      function ss(e, t) {
        return (
          !e.composing &&
          ("OPTION" === e.tagName ||
            (function (e, t) {
              var n = !0;
              try {
                n = document.activeElement !== e;
              } catch (e) {}
              return n && e.value !== t;
            })(e, t) ||
            (function (e, t) {
              var n = e.value,
                a = e._vModifiers;
              if (i(a)) {
                if (a.number) return T(n) !== T(t);
                if (a.trim) return n.trim() !== t.trim();
              }
              return n !== t;
            })(e, t))
        );
      }
      var is = { create: as, update: as },
        rs = w(function (e) {
          var t = {},
            n = /:(.+)/;
          return (
            e.split(/;(?![^(]*\))/g).forEach(function (e) {
              if (e) {
                var a = e.split(n);
                a.length > 1 && (t[a[0].trim()] = a[1].trim());
              }
            }),
            t
          );
        });
      function os(e) {
        var t = ds(e.style);
        return e.staticStyle ? D(e.staticStyle, t) : t;
      }
      function ds(e) {
        return Array.isArray(e) ? x(e) : "string" == typeof e ? rs(e) : e;
      }
      var ps,
        us = /^--/,
        ls = /\s*!important$/,
        ys = function (e, t, n) {
          if (us.test(t)) e.style.setProperty(t, n);
          else if (ls.test(n)) e.style.setProperty(S(t), n.replace(ls, ""), "important");
          else {
            var a = cs(t);
            if (Array.isArray(n)) for (var s = 0, i = n.length; s < i; s++) e.style[a] = n[s];
            else e.style[a] = n;
          }
        },
        ms = ["Webkit", "Moz", "ms"],
        cs = w(function (e) {
          if (((ps = ps || document.createElement("div").style), "filter" !== (e = P(e)) && e in ps)) return e;
          for (var t = e.charAt(0).toUpperCase() + e.slice(1), n = 0; n < ms.length; n++) {
            var a = ms[n] + t;
            if (a in ps) return a;
          }
        });
      function Ts(e, t) {
        var n = t.data,
          a = e.data;
        if (!(s(n.staticStyle) && s(n.style) && s(a.staticStyle) && s(a.style))) {
          var r,
            o,
            d = t.elm,
            p = a.staticStyle,
            u = a.normalizedStyle || a.style || {},
            l = p || u,
            y = ds(t.data.style) || {};
          t.data.normalizedStyle = i(y.__ob__) ? D({}, y) : y;
          var m = (function (e, t) {
            var n,
              a = {};
            if (t)
              for (var s = e; s.componentInstance; )
                (s = s.componentInstance._vnode) && s.data && (n = os(s.data)) && D(a, n);
            (n = os(e.data)) && D(a, n);
            for (var i = e; (i = i.parent); ) i.data && (n = os(i.data)) && D(a, n);
            return a;
          })(t, !0);
          for (o in l) s(m[o]) && ys(d, o, "");
          for (o in m) (r = m[o]) !== l[o] && ys(d, o, null == r ? "" : r);
        }
      }
      var fs = { create: Ts, update: Ts },
        bs = /\s+/;
      function gs(e, t) {
        if (t && (t = t.trim()))
          if (e.classList)
            t.indexOf(" ") > -1
              ? t.split(bs).forEach(function (t) {
                  return e.classList.add(t);
                })
              : e.classList.add(t);
          else {
            var n = " " + (e.getAttribute("class") || "") + " ";
            n.indexOf(" " + t + " ") < 0 && e.setAttribute("class", (n + t).trim());
          }
      }
      function vs(e, t) {
        if (t && (t = t.trim()))
          if (e.classList)
            t.indexOf(" ") > -1
              ? t.split(bs).forEach(function (t) {
                  return e.classList.remove(t);
                })
              : e.classList.remove(t),
              e.classList.length || e.removeAttribute("class");
          else {
            for (var n = " " + (e.getAttribute("class") || "") + " ", a = " " + t + " "; n.indexOf(a) >= 0; )
              n = n.replace(a, " ");
            (n = n.trim()) ? e.setAttribute("class", n) : e.removeAttribute("class");
          }
      }
      function hs(e) {
        if (e) {
          if ("object" == typeof e) {
            var t = {};
            return !1 !== e.css && D(t, _s(e.name || "v")), D(t, e), t;
          }
          return "string" == typeof e ? _s(e) : void 0;
        }
      }
      var _s = w(function (e) {
          return {
            enterClass: e + "-enter",
            enterToClass: e + "-enter-to",
            enterActiveClass: e + "-enter-active",
            leaveClass: e + "-leave",
            leaveToClass: e + "-leave-to",
            leaveActiveClass: e + "-leave-active",
          };
        }),
        ws = z && !Z,
        ks = "transition",
        Ps = "transitionend",
        Ms = "animation",
        As = "animationend";
      ws &&
        (void 0 === window.ontransitionend &&
          void 0 !== window.onwebkittransitionend &&
          ((ks = "WebkitTransition"), (Ps = "webkitTransitionEnd")),
        void 0 === window.onanimationend &&
          void 0 !== window.onwebkitanimationend &&
          ((Ms = "WebkitAnimation"), (As = "webkitAnimationEnd")));
      var Ss = z
        ? window.requestAnimationFrame
          ? window.requestAnimationFrame.bind(window)
          : setTimeout
        : function (e) {
            return e();
          };
      function Cs(e) {
        Ss(function () {
          Ss(e);
        });
      }
      function Rs(e, t) {
        var n = e._transitionClasses || (e._transitionClasses = []);
        n.indexOf(t) < 0 && (n.push(t), gs(e, t));
      }
      function Ds(e, t) {
        e._transitionClasses && v(e._transitionClasses, t), vs(e, t);
      }
      function xs(e, t, n) {
        var a = Is(e, t),
          s = a.type,
          i = a.timeout,
          r = a.propCount;
        if (!s) return n();
        var o = "transition" === s ? Ps : As,
          d = 0,
          p = function () {
            e.removeEventListener(o, u), n();
          },
          u = function (t) {
            t.target === e && ++d >= r && p();
          };
        setTimeout(function () {
          d < r && p();
        }, i + 1),
          e.addEventListener(o, u);
      }
      var Os = /\b(transform|all)(,|$)/;
      function Is(e, t) {
        var n,
          a = window.getComputedStyle(e),
          s = (a[ks + "Delay"] || "").split(", "),
          i = (a[ks + "Duration"] || "").split(", "),
          r = Ls(s, i),
          o = (a[Ms + "Delay"] || "").split(", "),
          d = (a[Ms + "Duration"] || "").split(", "),
          p = Ls(o, d),
          u = 0,
          l = 0;
        return (
          "transition" === t
            ? r > 0 && ((n = "transition"), (u = r), (l = i.length))
            : "animation" === t
            ? p > 0 && ((n = "animation"), (u = p), (l = d.length))
            : (l = (n = (u = Math.max(r, p)) > 0 ? (r > p ? "transition" : "animation") : null)
                ? "transition" === n
                  ? i.length
                  : d.length
                : 0),
          { type: n, timeout: u, propCount: l, hasTransform: "transition" === n && Os.test(a[ks + "Property"]) }
        );
      }
      function Ls(e, t) {
        for (; e.length < t.length; ) e = e.concat(e);
        return Math.max.apply(
          null,
          t.map(function (t, n) {
            return Es(t) + Es(e[n]);
          }),
        );
      }
      function Es(e) {
        return 1e3 * Number(e.slice(0, -1).replace(",", "."));
      }
      function qs(e, t) {
        var n = e.elm;
        i(n._leaveCb) && ((n._leaveCb.cancelled = !0), n._leaveCb());
        var a = hs(e.data.transition);
        if (!s(a) && !i(n._enterCb) && 1 === n.nodeType) {
          for (
            var r = a.css,
              o = a.type,
              p = a.enterClass,
              u = a.enterToClass,
              l = a.enterActiveClass,
              y = a.appearClass,
              m = a.appearToClass,
              c = a.appearActiveClass,
              f = a.beforeEnter,
              b = a.enter,
              g = a.afterEnter,
              v = a.enterCancelled,
              h = a.beforeAppear,
              _ = a.appear,
              w = a.afterAppear,
              k = a.appearCancelled,
              P = a.duration,
              M = Xt,
              A = Xt.$vnode;
            A && A.parent;

          )
            (M = A.context), (A = A.parent);
          var S = !M._isMounted || !e.isRootInsert;
          if (!S || _ || "" === _) {
            var C = S && y ? y : p,
              R = S && c ? c : l,
              D = S && m ? m : u,
              x = (S && h) || f,
              O = S && "function" == typeof _ ? _ : b,
              I = (S && w) || g,
              L = (S && k) || v,
              E = T(d(P) ? P.enter : P);
            0;
            var q = !1 !== r && !Z,
              U = Bs(O),
              B = (n._enterCb = V(function () {
                q && (Ds(n, D), Ds(n, R)), B.cancelled ? (q && Ds(n, C), L && L(n)) : I && I(n), (n._enterCb = null);
              }));
            e.data.show ||
              pt(e, "insert", function () {
                var t = n.parentNode,
                  a = t && t._pending && t._pending[e.key];
                a && a.tag === e.tag && a.elm._leaveCb && a.elm._leaveCb(), O && O(n, B);
              }),
              x && x(n),
              q &&
                (Rs(n, C),
                Rs(n, R),
                Cs(function () {
                  Ds(n, C), B.cancelled || (Rs(n, D), U || (Us(E) ? setTimeout(B, E) : xs(n, o, B)));
                })),
              e.data.show && (t && t(), O && O(n, B)),
              q || U || B();
          }
        }
      }
      function Vs(e, t) {
        var n = e.elm;
        i(n._enterCb) && ((n._enterCb.cancelled = !0), n._enterCb());
        var a = hs(e.data.transition);
        if (s(a) || 1 !== n.nodeType) return t();
        if (!i(n._leaveCb)) {
          var r = a.css,
            o = a.type,
            p = a.leaveClass,
            u = a.leaveToClass,
            l = a.leaveActiveClass,
            y = a.beforeLeave,
            m = a.leave,
            c = a.afterLeave,
            f = a.leaveCancelled,
            b = a.delayLeave,
            g = a.duration,
            v = !1 !== r && !Z,
            h = Bs(m),
            _ = T(d(g) ? g.leave : g);
          0;
          var w = (n._leaveCb = V(function () {
            n.parentNode && n.parentNode._pending && (n.parentNode._pending[e.key] = null),
              v && (Ds(n, u), Ds(n, l)),
              w.cancelled ? (v && Ds(n, p), f && f(n)) : (t(), c && c(n)),
              (n._leaveCb = null);
          }));
          b ? b(k) : k();
        }
        function k() {
          w.cancelled ||
            (!e.data.show && n.parentNode && ((n.parentNode._pending || (n.parentNode._pending = {}))[e.key] = e),
            y && y(n),
            v &&
              (Rs(n, p),
              Rs(n, l),
              Cs(function () {
                Ds(n, p), w.cancelled || (Rs(n, u), h || (Us(_) ? setTimeout(w, _) : xs(n, o, w)));
              })),
            m && m(n, w),
            v || h || w());
        }
      }
      function Us(e) {
        return "number" == typeof e && !isNaN(e);
      }
      function Bs(e) {
        if (s(e)) return !1;
        var t = e.fns;
        return i(t) ? Bs(Array.isArray(t) ? t[0] : t) : (e._length || e.length) > 1;
      }
      function Hs(e, t) {
        !0 !== t.data.show && qs(t);
      }
      var $s = (function (e) {
        var t,
          n,
          a = {},
          d = e.modules,
          p = e.nodeOps;
        for (t = 0; t < ia.length; ++t)
          for (a[ia[t]] = [], n = 0; n < d.length; ++n) i(d[n][ia[t]]) && a[ia[t]].push(d[n][ia[t]]);
        function u(e) {
          var t = p.parentNode(e);
          i(t) && p.removeChild(t, e);
        }
        function l(e, t, n, s, o, d, u) {
          if (
            (i(e.elm) && i(d) && (e = d[u] = he(e)),
            (e.isRootInsert = !o),
            !(function (e, t, n, s) {
              var o = e.data;
              if (i(o)) {
                var d = i(e.componentInstance) && o.keepAlive;
                if ((i((o = o.hook)) && i((o = o.init)) && o(e, !1), i(e.componentInstance)))
                  return (
                    y(e, t),
                    m(n, e.elm, s),
                    r(d) &&
                      (function (e, t, n, s) {
                        var r,
                          o = e;
                        for (; o.componentInstance; )
                          if (((o = o.componentInstance._vnode), i((r = o.data)) && i((r = r.transition)))) {
                            for (r = 0; r < a.activate.length; ++r) a.activate[r](sa, o);
                            t.push(o);
                            break;
                          }
                        m(n, e.elm, s);
                      })(e, t, n, s),
                    !0
                  );
              }
            })(e, t, n, s))
          ) {
            var l = e.data,
              T = e.children,
              f = e.tag;
            i(f)
              ? ((e.elm = e.ns ? p.createElementNS(e.ns, f) : p.createElement(f, e)),
                g(e),
                c(e, T, t),
                i(l) && b(e, t),
                m(n, e.elm, s))
              : r(e.isComment)
              ? ((e.elm = p.createComment(e.text)), m(n, e.elm, s))
              : ((e.elm = p.createTextNode(e.text)), m(n, e.elm, s));
          }
        }
        function y(e, t) {
          i(e.data.pendingInsert) && (t.push.apply(t, e.data.pendingInsert), (e.data.pendingInsert = null)),
            (e.elm = e.componentInstance.$el),
            T(e) ? (b(e, t), g(e)) : (aa(e), t.push(e));
        }
        function m(e, t, n) {
          i(e) && (i(n) ? p.parentNode(n) === e && p.insertBefore(e, t, n) : p.appendChild(e, t));
        }
        function c(e, t, n) {
          if (Array.isArray(t)) {
            0;
            for (var a = 0; a < t.length; ++a) l(t[a], n, e.elm, null, !0, t, a);
          } else o(e.text) && p.appendChild(e.elm, p.createTextNode(String(e.text)));
        }
        function T(e) {
          for (; e.componentInstance; ) e = e.componentInstance._vnode;
          return i(e.tag);
        }
        function b(e, n) {
          for (var s = 0; s < a.create.length; ++s) a.create[s](sa, e);
          i((t = e.data.hook)) && (i(t.create) && t.create(sa, e), i(t.insert) && n.push(e));
        }
        function g(e) {
          var t;
          if (i((t = e.fnScopeId))) p.setStyleScope(e.elm, t);
          else
            for (var n = e; n; )
              i((t = n.context)) && i((t = t.$options._scopeId)) && p.setStyleScope(e.elm, t), (n = n.parent);
          i((t = Xt)) &&
            t !== e.context &&
            t !== e.fnContext &&
            i((t = t.$options._scopeId)) &&
            p.setStyleScope(e.elm, t);
        }
        function v(e, t, n, a, s, i) {
          for (; a <= s; ++a) l(n[a], i, e, t, !1, n, a);
        }
        function h(e) {
          var t,
            n,
            s = e.data;
          if (i(s))
            for (i((t = s.hook)) && i((t = t.destroy)) && t(e), t = 0; t < a.destroy.length; ++t) a.destroy[t](e);
          if (i((t = e.children))) for (n = 0; n < e.children.length; ++n) h(e.children[n]);
        }
        function _(e, t, n) {
          for (; t <= n; ++t) {
            var a = e[t];
            i(a) && (i(a.tag) ? (w(a), h(a)) : u(a.elm));
          }
        }
        function w(e, t) {
          if (i(t) || i(e.data)) {
            var n,
              s = a.remove.length + 1;
            for (
              i(t)
                ? (t.listeners += s)
                : (t = (function (e, t) {
                    function n() {
                      0 == --n.listeners && u(e);
                    }
                    return (n.listeners = t), n;
                  })(e.elm, s)),
                i((n = e.componentInstance)) && i((n = n._vnode)) && i(n.data) && w(n, t),
                n = 0;
              n < a.remove.length;
              ++n
            )
              a.remove[n](e, t);
            i((n = e.data.hook)) && i((n = n.remove)) ? n(e, t) : t();
          } else u(e.elm);
        }
        function k(e, t, n, a) {
          for (var s = n; s < a; s++) {
            var r = t[s];
            if (i(r) && ra(e, r)) return s;
          }
        }
        function P(e, t, n, o, d, u) {
          if (e !== t) {
            i(t.elm) && i(o) && (t = o[d] = he(t));
            var y = (t.elm = e.elm);
            if (r(e.isAsyncPlaceholder)) i(t.asyncFactory.resolved) ? S(e.elm, t, n) : (t.isAsyncPlaceholder = !0);
            else if (r(t.isStatic) && r(e.isStatic) && t.key === e.key && (r(t.isCloned) || r(t.isOnce)))
              t.componentInstance = e.componentInstance;
            else {
              var m,
                c = t.data;
              i(c) && i((m = c.hook)) && i((m = m.prepatch)) && m(e, t);
              var f = e.children,
                b = t.children;
              if (i(c) && T(t)) {
                for (m = 0; m < a.update.length; ++m) a.update[m](e, t);
                i((m = c.hook)) && i((m = m.update)) && m(e, t);
              }
              s(t.text)
                ? i(f) && i(b)
                  ? f !== b &&
                    (function (e, t, n, a, r) {
                      var o,
                        d,
                        u,
                        y = 0,
                        m = 0,
                        c = t.length - 1,
                        T = t[0],
                        f = t[c],
                        b = n.length - 1,
                        g = n[0],
                        h = n[b],
                        w = !r;
                      for (0; y <= c && m <= b; )
                        s(T)
                          ? (T = t[++y])
                          : s(f)
                          ? (f = t[--c])
                          : ra(T, g)
                          ? (P(T, g, a, n, m), (T = t[++y]), (g = n[++m]))
                          : ra(f, h)
                          ? (P(f, h, a, n, b), (f = t[--c]), (h = n[--b]))
                          : ra(T, h)
                          ? (P(T, h, a, n, b),
                            w && p.insertBefore(e, T.elm, p.nextSibling(f.elm)),
                            (T = t[++y]),
                            (h = n[--b]))
                          : ra(f, g)
                          ? (P(f, g, a, n, m), w && p.insertBefore(e, f.elm, T.elm), (f = t[--c]), (g = n[++m]))
                          : (s(o) && (o = oa(t, y, c)),
                            s((d = i(g.key) ? o[g.key] : k(g, t, y, c)))
                              ? l(g, a, e, T.elm, !1, n, m)
                              : ra((u = t[d]), g)
                              ? (P(u, g, a, n, m), (t[d] = void 0), w && p.insertBefore(e, u.elm, T.elm))
                              : l(g, a, e, T.elm, !1, n, m),
                            (g = n[++m]));
                      y > c ? v(e, s(n[b + 1]) ? null : n[b + 1].elm, n, m, b, a) : m > b && _(t, y, c);
                    })(y, f, b, n, u)
                  : i(b)
                  ? (i(e.text) && p.setTextContent(y, ""), v(y, null, b, 0, b.length - 1, n))
                  : i(f)
                  ? _(f, 0, f.length - 1)
                  : i(e.text) && p.setTextContent(y, "")
                : e.text !== t.text && p.setTextContent(y, t.text),
                i(c) && i((m = c.hook)) && i((m = m.postpatch)) && m(e, t);
            }
          }
        }
        function M(e, t, n) {
          if (r(n) && i(e.parent)) e.parent.data.pendingInsert = t;
          else for (var a = 0; a < t.length; ++a) t[a].data.hook.insert(t[a]);
        }
        var A = f("attrs,class,staticClass,staticStyle,key");
        function S(e, t, n, a) {
          var s,
            o = t.tag,
            d = t.data,
            p = t.children;
          if (((a = a || (d && d.pre)), (t.elm = e), r(t.isComment) && i(t.asyncFactory)))
            return (t.isAsyncPlaceholder = !0), !0;
          if (i(d) && (i((s = d.hook)) && i((s = s.init)) && s(t, !0), i((s = t.componentInstance))))
            return y(t, n), !0;
          if (i(o)) {
            if (i(p))
              if (e.hasChildNodes())
                if (i((s = d)) && i((s = s.domProps)) && i((s = s.innerHTML))) {
                  if (s !== e.innerHTML) return !1;
                } else {
                  for (var u = !0, l = e.firstChild, m = 0; m < p.length; m++) {
                    if (!l || !S(l, p[m], n, a)) {
                      u = !1;
                      break;
                    }
                    l = l.nextSibling;
                  }
                  if (!u || l) return !1;
                }
              else c(t, p, n);
            if (i(d)) {
              var T = !1;
              for (var f in d)
                if (!A(f)) {
                  (T = !0), b(t, n);
                  break;
                }
              !T && d.class && it(d.class);
            }
          } else e.data !== t.text && (e.data = t.text);
          return !0;
        }
        return function (e, t, n, o) {
          if (!s(t)) {
            var d,
              u = !1,
              y = [];
            if (s(e)) (u = !0), l(t, y);
            else {
              var m = i(e.nodeType);
              if (!m && ra(e, t)) P(e, t, y, null, null, o);
              else {
                if (m) {
                  if (
                    (1 === e.nodeType &&
                      e.hasAttribute("data-server-rendered") &&
                      (e.removeAttribute("data-server-rendered"), (n = !0)),
                    r(n) && S(e, t, y))
                  )
                    return M(t, y, !0), e;
                  (d = e), (e = new fe(p.tagName(d).toLowerCase(), {}, [], void 0, d));
                }
                var c = e.elm,
                  f = p.parentNode(c);
                if ((l(t, y, c._leaveCb ? null : f, p.nextSibling(c)), i(t.parent)))
                  for (var b = t.parent, g = T(t); b; ) {
                    for (var v = 0; v < a.destroy.length; ++v) a.destroy[v](b);
                    if (((b.elm = t.elm), g)) {
                      for (var w = 0; w < a.create.length; ++w) a.create[w](sa, b);
                      var k = b.data.hook.insert;
                      if (k.merged) for (var A = 1; A < k.fns.length; A++) k.fns[A]();
                    } else aa(b);
                    b = b.parent;
                  }
                i(f) ? _([e], 0, 0) : i(e.tag) && h(e);
              }
            }
            return M(t, y, u), t.elm;
          }
          i(e) && h(e);
        };
      })({
        nodeOps: ta,
        modules: [
          ga,
          Aa,
          ns,
          is,
          fs,
          z
            ? {
                create: Hs,
                activate: Hs,
                remove: function (e, t) {
                  !0 !== e.data.show ? Vs(e, t) : t();
                },
              }
            : {},
        ].concat(ca),
      });
      Z &&
        document.addEventListener("selectionchange", function () {
          var e = document.activeElement;
          e && e.vmodel && Ks(e, "input");
        });
      var Ws = {
        inserted: function (e, t, n, a) {
          "select" === n.tag
            ? (a.elm && !a.elm._vOptions
                ? pt(n, "postpatch", function () {
                    Ws.componentUpdated(e, t, n);
                  })
                : Fs(e, t, n.context),
              (e._vOptions = [].map.call(e.options, js)))
            : ("textarea" === n.tag || Qn(e.type)) &&
              ((e._vModifiers = t.modifiers),
              t.modifiers.lazy ||
                (e.addEventListener("compositionstart", zs),
                e.addEventListener("compositionend", Gs),
                e.addEventListener("change", Gs),
                Z && (e.vmodel = !0)));
        },
        componentUpdated: function (e, t, n) {
          if ("select" === n.tag) {
            Fs(e, t, n.context);
            var a = e._vOptions,
              s = (e._vOptions = [].map.call(e.options, js));
            if (
              s.some(function (e, t) {
                return !E(e, a[t]);
              })
            )
              (e.multiple
                ? t.value.some(function (e) {
                    return Ys(e, s);
                  })
                : t.value !== t.oldValue && Ys(t.value, s)) && Ks(e, "change");
          }
        },
      };
      function Fs(e, t, n) {
        Ns(e, t, n),
          (X || Q) &&
            setTimeout(function () {
              Ns(e, t, n);
            }, 0);
      }
      function Ns(e, t, n) {
        var a = t.value,
          s = e.multiple;
        if (!s || Array.isArray(a)) {
          for (var i, r, o = 0, d = e.options.length; o < d; o++)
            if (((r = e.options[o]), s)) (i = q(a, js(r)) > -1), r.selected !== i && (r.selected = i);
            else if (E(js(r), a)) return void (e.selectedIndex !== o && (e.selectedIndex = o));
          s || (e.selectedIndex = -1);
        }
      }
      function Ys(e, t) {
        return t.every(function (t) {
          return !E(t, e);
        });
      }
      function js(e) {
        return "_value" in e ? e._value : e.value;
      }
      function zs(e) {
        e.target.composing = !0;
      }
      function Gs(e) {
        e.target.composing && ((e.target.composing = !1), Ks(e.target, "input"));
      }
      function Ks(e, t) {
        var n = document.createEvent("HTMLEvents");
        n.initEvent(t, !0, !0), e.dispatchEvent(n);
      }
      function Js(e) {
        return !e.componentInstance || (e.data && e.data.transition) ? e : Js(e.componentInstance._vnode);
      }
      var Xs = {
          model: Ws,
          show: {
            bind: function (e, t, n) {
              var a = t.value,
                s = (n = Js(n)).data && n.data.transition,
                i = (e.__vOriginalDisplay = "none" === e.style.display ? "" : e.style.display);
              a && s
                ? ((n.data.show = !0),
                  qs(n, function () {
                    e.style.display = i;
                  }))
                : (e.style.display = a ? i : "none");
            },
            update: function (e, t, n) {
              var a = t.value;
              !a != !t.oldValue &&
                ((n = Js(n)).data && n.data.transition
                  ? ((n.data.show = !0),
                    a
                      ? qs(n, function () {
                          e.style.display = e.__vOriginalDisplay;
                        })
                      : Vs(n, function () {
                          e.style.display = "none";
                        }))
                  : (e.style.display = a ? e.__vOriginalDisplay : "none"));
            },
            unbind: function (e, t, n, a, s) {
              s || (e.style.display = e.__vOriginalDisplay);
            },
          },
        },
        Zs = {
          name: String,
          appear: Boolean,
          css: Boolean,
          mode: String,
          type: String,
          enterClass: String,
          leaveClass: String,
          enterToClass: String,
          leaveToClass: String,
          enterActiveClass: String,
          leaveActiveClass: String,
          appearClass: String,
          appearActiveClass: String,
          appearToClass: String,
          duration: [Number, String, Object],
        };
      function Qs(e) {
        var t = e && e.componentOptions;
        return t && t.Ctor.options.abstract ? Qs(jt(t.children)) : e;
      }
      function ei(e) {
        var t = {},
          n = e.$options;
        for (var a in n.propsData) t[a] = e[a];
        var s = n._parentListeners;
        for (var i in s) t[P(i)] = s[i];
        return t;
      }
      function ti(e, t) {
        if (/\d-keep-alive$/.test(t.tag)) return e("keep-alive", { props: t.componentOptions.propsData });
      }
      var ni = function (e) {
          return e.tag || Yt(e);
        },
        ai = function (e) {
          return "show" === e.name;
        },
        si = {
          name: "transition",
          props: Zs,
          abstract: !0,
          render: function (e) {
            var t = this,
              n = this.$slots.default;
            if (n && (n = n.filter(ni)).length) {
              0;
              var a = this.mode;
              0;
              var s = n[0];
              if (
                (function (e) {
                  for (; (e = e.parent); ) if (e.data.transition) return !0;
                })(this.$vnode)
              )
                return s;
              var i = Qs(s);
              if (!i) return s;
              if (this._leaving) return ti(e, s);
              var r = "__transition-" + this._uid + "-";
              i.key =
                null == i.key
                  ? i.isComment
                    ? r + "comment"
                    : r + i.tag
                  : o(i.key)
                  ? 0 === String(i.key).indexOf(r)
                    ? i.key
                    : r + i.key
                  : i.key;
              var d = ((i.data || (i.data = {})).transition = ei(this)),
                p = this._vnode,
                u = Qs(p);
              if (
                (i.data.directives && i.data.directives.some(ai) && (i.data.show = !0),
                u &&
                  u.data &&
                  !(function (e, t) {
                    return t.key === e.key && t.tag === e.tag;
                  })(i, u) &&
                  !Yt(u) &&
                  (!u.componentInstance || !u.componentInstance._vnode.isComment))
              ) {
                var l = (u.data.transition = D({}, d));
                if ("out-in" === a)
                  return (
                    (this._leaving = !0),
                    pt(l, "afterLeave", function () {
                      (t._leaving = !1), t.$forceUpdate();
                    }),
                    ti(e, s)
                  );
                if ("in-out" === a) {
                  if (Yt(i)) return p;
                  var y,
                    m = function () {
                      y();
                    };
                  pt(d, "afterEnter", m),
                    pt(d, "enterCancelled", m),
                    pt(l, "delayLeave", function (e) {
                      y = e;
                    });
                }
              }
              return s;
            }
          },
        },
        ii = D({ tag: String, moveClass: String }, Zs);
      function ri(e) {
        e.elm._moveCb && e.elm._moveCb(), e.elm._enterCb && e.elm._enterCb();
      }
      function oi(e) {
        e.data.newPos = e.elm.getBoundingClientRect();
      }
      function di(e) {
        var t = e.data.pos,
          n = e.data.newPos,
          a = t.left - n.left,
          s = t.top - n.top;
        if (a || s) {
          e.data.moved = !0;
          var i = e.elm.style;
          (i.transform = i.WebkitTransform = "translate(" + a + "px," + s + "px)"), (i.transitionDuration = "0s");
        }
      }
      delete ii.mode;
      var pi = {
        Transition: si,
        TransitionGroup: {
          props: ii,
          beforeMount: function () {
            var e = this,
              t = this._update;
            this._update = function (n, a) {
              var s = Zt(e);
              e.__patch__(e._vnode, e.kept, !1, !0), (e._vnode = e.kept), s(), t.call(e, n, a);
            };
          },
          render: function (e) {
            for (
              var t = this.tag || this.$vnode.data.tag || "span",
                n = Object.create(null),
                a = (this.prevChildren = this.children),
                s = this.$slots.default || [],
                i = (this.children = []),
                r = ei(this),
                o = 0;
              o < s.length;
              o++
            ) {
              var d = s[o];
              if (d.tag)
                if (null != d.key && 0 !== String(d.key).indexOf("__vlist"))
                  i.push(d), (n[d.key] = d), ((d.data || (d.data = {})).transition = r);
                else;
            }
            if (a) {
              for (var p = [], u = [], l = 0; l < a.length; l++) {
                var y = a[l];
                (y.data.transition = r), (y.data.pos = y.elm.getBoundingClientRect()), n[y.key] ? p.push(y) : u.push(y);
              }
              (this.kept = e(t, null, p)), (this.removed = u);
            }
            return e(t, null, i);
          },
          updated: function () {
            var e = this.prevChildren,
              t = this.moveClass || (this.name || "v") + "-move";
            e.length &&
              this.hasMove(e[0].elm, t) &&
              (e.forEach(ri),
              e.forEach(oi),
              e.forEach(di),
              (this._reflow = document.body.offsetHeight),
              e.forEach(function (e) {
                if (e.data.moved) {
                  var n = e.elm,
                    a = n.style;
                  Rs(n, t),
                    (a.transform = a.WebkitTransform = a.transitionDuration = ""),
                    n.addEventListener(
                      Ps,
                      (n._moveCb = function e(a) {
                        (a && a.target !== n) ||
                          (a && !/transform$/.test(a.propertyName)) ||
                          (n.removeEventListener(Ps, e), (n._moveCb = null), Ds(n, t));
                      }),
                    );
                }
              }));
          },
          methods: {
            hasMove: function (e, t) {
              if (!ws) return !1;
              if (this._hasMove) return this._hasMove;
              var n = e.cloneNode();
              e._transitionClasses &&
                e._transitionClasses.forEach(function (e) {
                  vs(n, e);
                }),
                gs(n, t),
                (n.style.display = "none"),
                this.$el.appendChild(n);
              var a = Is(n);
              return this.$el.removeChild(n), (this._hasMove = a.hasTransform);
            },
          },
        },
      };
      (Mn.config.mustUseProp = En),
        (Mn.config.isReservedTag = Jn),
        (Mn.config.isReservedAttr = In),
        (Mn.config.getTagNamespace = Xn),
        (Mn.config.isUnknownElement = function (e) {
          if (!z) return !0;
          if (Jn(e)) return !1;
          if (((e = e.toLowerCase()), null != Zn[e])) return Zn[e];
          var t = document.createElement(e);
          return e.indexOf("-") > -1
            ? (Zn[e] = t.constructor === window.HTMLUnknownElement || t.constructor === window.HTMLElement)
            : (Zn[e] = /HTMLUnknownElement/.test(t.toString()));
        }),
        D(Mn.options.directives, Xs),
        D(Mn.options.components, pi),
        (Mn.prototype.__patch__ = z ? $s : O),
        (Mn.prototype.$mount = function (e, t) {
          return (function (e, t, n) {
            var a;
            return (
              (e.$el = t),
              e.$options.render || (e.$options.render = ge),
              tn(e, "beforeMount"),
              (a = function () {
                e._update(e._render(), n);
              }),
              new cn(
                e,
                a,
                O,
                {
                  before: function () {
                    e._isMounted && !e._isDestroyed && tn(e, "beforeUpdate");
                  },
                },
                !0,
              ),
              (n = !1),
              null == e.$vnode && ((e._isMounted = !0), tn(e, "mounted")),
              e
            );
          })(this, (e = e && z ? ea(e) : void 0), t);
        }),
        z &&
          setTimeout(function () {
            H.devtools && re && re.emit("init", Mn);
          }, 0);
      var ui = /\{\{((?:.|\r?\n)+?)\}\}/g,
        li = /[-.*+?^${}()|[\]\/\\]/g,
        yi = w(function (e) {
          var t = e[0].replace(li, "\\$&"),
            n = e[1].replace(li, "\\$&");
          return new RegExp(t + "((?:.|\\n)+?)" + n, "g");
        });
      var mi = {
        staticKeys: ["staticClass"],
        transformNode: function (e, t) {
          t.warn;
          var n = Ba(e, "class");
          n && (e.staticClass = JSON.stringify(n));
          var a = Ua(e, "class", !1);
          a && (e.classBinding = a);
        },
        genData: function (e) {
          var t = "";
          return (
            e.staticClass && (t += "staticClass:" + e.staticClass + ","),
            e.classBinding && (t += "class:" + e.classBinding + ","),
            t
          );
        },
      };
      var ci,
        Ti = {
          staticKeys: ["staticStyle"],
          transformNode: function (e, t) {
            t.warn;
            var n = Ba(e, "style");
            n && (e.staticStyle = JSON.stringify(rs(n)));
            var a = Ua(e, "style", !1);
            a && (e.styleBinding = a);
          },
          genData: function (e) {
            var t = "";
            return (
              e.staticStyle && (t += "staticStyle:" + e.staticStyle + ","),
              e.styleBinding && (t += "style:(" + e.styleBinding + "),"),
              t
            );
          },
        },
        fi = function (e) {
          return ((ci = ci || document.createElement("div")).innerHTML = e), ci.textContent;
        },
        bi = f("area,base,br,col,embed,frame,hr,img,input,isindex,keygen,link,meta,param,source,track,wbr"),
        gi = f("colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source"),
        vi = f(
          "address,article,aside,base,blockquote,body,caption,col,colgroup,dd,details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,title,tr,track",
        ),
        hi = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
        _i = /^\s*((?:v-[\w-]+:|@|:|#)\[[^=]+\][^\s"'<>\/=]*)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/,
        wi = "[a-zA-Z_][\\-\\.0-9_a-zA-Z" + $.source + "]*",
        ki = "((?:" + wi + "\\:)?" + wi + ")",
        Pi = new RegExp("^<" + ki),
        Mi = /^\s*(\/?)>/,
        Ai = new RegExp("^<\\/" + ki + "[^>]*>"),
        Si = /^<!DOCTYPE [^>]+>/i,
        Ci = /^<!\--/,
        Ri = /^<!\[/,
        Di = f("script,style,textarea", !0),
        xi = {},
        Oi = { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&amp;": "&", "&#10;": "\n", "&#9;": "\t", "&#39;": "'" },
        Ii = /&(?:lt|gt|quot|amp|#39);/g,
        Li = /&(?:lt|gt|quot|amp|#39|#10|#9);/g,
        Ei = f("pre,textarea", !0),
        qi = function (e, t) {
          return e && Ei(e) && "\n" === t[0];
        };
      function Vi(e, t) {
        var n = t ? Li : Ii;
        return e.replace(n, function (e) {
          return Oi[e];
        });
      }
      var Ui,
        Bi,
        Hi,
        $i,
        Wi,
        Fi,
        Ni,
        Yi,
        ji = /^@|^v-on:/,
        zi = /^v-|^@|^:|^#/,
        Gi = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,
        Ki = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/,
        Ji = /^\(|\)$/g,
        Xi = /^\[.*\]$/,
        Zi = /:(.*)$/,
        Qi = /^:|^\.|^v-bind:/,
        er = /\.[^.\]]+(?=[^\]]*$)/g,
        tr = /^v-slot(:|$)|^#/,
        nr = /[\r\n]/,
        ar = /\s+/g,
        sr = w(fi);
      function ir(e, t, n) {
        return { type: 1, tag: e, attrsList: t, attrsMap: yr(t), rawAttrsMap: {}, parent: n, children: [] };
      }
      function rr(e, t) {
        (Ui = t.warn || Da), (Fi = t.isPreTag || I), (Ni = t.mustUseProp || I), (Yi = t.getTagNamespace || I);
        var n = t.isReservedTag || I;
        (function (e) {
          return !!e.component || !n(e.tag);
        },
          (Hi = xa(t.modules, "transformNode")),
          ($i = xa(t.modules, "preTransformNode")),
          (Wi = xa(t.modules, "postTransformNode")),
          (Bi = t.delimiters));
        var a,
          s,
          i = [],
          r = !1 !== t.preserveWhitespace,
          o = t.whitespace,
          d = !1,
          p = !1;
        function u(e) {
          if (
            (l(e),
            d || e.processed || (e = or(e, t)),
            i.length || e === a || (a.if && (e.elseif || e.else) && pr(a, { exp: e.elseif, block: e })),
            s && !e.forbidden)
          )
            if (e.elseif || e.else)
              (r = e),
                (o = (function (e) {
                  for (var t = e.length; t--; ) {
                    if (1 === e[t].type) return e[t];
                    e.pop();
                  }
                })(s.children)) &&
                  o.if &&
                  pr(o, { exp: r.elseif, block: r });
            else {
              if (e.slotScope) {
                var n = e.slotTarget || '"default"';
                (s.scopedSlots || (s.scopedSlots = {}))[n] = e;
              }
              s.children.push(e), (e.parent = s);
            }
          var r, o;
          (e.children = e.children.filter(function (e) {
            return !e.slotScope;
          })),
            l(e),
            e.pre && (d = !1),
            Fi(e.tag) && (p = !1);
          for (var u = 0; u < Wi.length; u++) Wi[u](e, t);
        }
        function l(e) {
          if (!p)
            for (var t; (t = e.children[e.children.length - 1]) && 3 === t.type && " " === t.text; ) e.children.pop();
        }
        return (
          (function (e, t) {
            for (var n, a, s = [], i = t.expectHTML, r = t.isUnaryTag || I, o = t.canBeLeftOpenTag || I, d = 0; e; ) {
              if (((n = e), a && Di(a))) {
                var p = 0,
                  u = a.toLowerCase(),
                  l = xi[u] || (xi[u] = new RegExp("([\\s\\S]*?)(</" + u + "[^>]*>)", "i")),
                  y = e.replace(l, function (e, n, a) {
                    return (
                      (p = a.length),
                      Di(u) ||
                        "noscript" === u ||
                        (n = n.replace(/<!\--([\s\S]*?)-->/g, "$1").replace(/<!\[CDATA\[([\s\S]*?)]]>/g, "$1")),
                      qi(u, n) && (n = n.slice(1)),
                      t.chars && t.chars(n),
                      ""
                    );
                  });
                (d += e.length - y.length), (e = y), A(u, d - p, d);
              } else {
                var m = e.indexOf("<");
                if (0 === m) {
                  if (Ci.test(e)) {
                    var c = e.indexOf("--\x3e");
                    if (c >= 0) {
                      t.shouldKeepComment && t.comment(e.substring(4, c), d, d + c + 3), k(c + 3);
                      continue;
                    }
                  }
                  if (Ri.test(e)) {
                    var T = e.indexOf("]>");
                    if (T >= 0) {
                      k(T + 2);
                      continue;
                    }
                  }
                  var f = e.match(Si);
                  if (f) {
                    k(f[0].length);
                    continue;
                  }
                  var b = e.match(Ai);
                  if (b) {
                    var g = d;
                    k(b[0].length), A(b[1], g, d);
                    continue;
                  }
                  var v = P();
                  if (v) {
                    M(v), qi(v.tagName, e) && k(1);
                    continue;
                  }
                }
                var h = void 0,
                  _ = void 0,
                  w = void 0;
                if (m >= 0) {
                  for (
                    _ = e.slice(m);
                    !(Ai.test(_) || Pi.test(_) || Ci.test(_) || Ri.test(_) || (w = _.indexOf("<", 1)) < 0);

                  )
                    (m += w), (_ = e.slice(m));
                  h = e.substring(0, m);
                }
                m < 0 && (h = e), h && k(h.length), t.chars && h && t.chars(h, d - h.length, d);
              }
              if (e === n) {
                t.chars && t.chars(e);
                break;
              }
            }
            function k(t) {
              (d += t), (e = e.substring(t));
            }
            function P() {
              var t = e.match(Pi);
              if (t) {
                var n,
                  a,
                  s = { tagName: t[1], attrs: [], start: d };
                for (k(t[0].length); !(n = e.match(Mi)) && (a = e.match(_i) || e.match(hi)); )
                  (a.start = d), k(a[0].length), (a.end = d), s.attrs.push(a);
                if (n) return (s.unarySlash = n[1]), k(n[0].length), (s.end = d), s;
              }
            }
            function M(e) {
              var n = e.tagName,
                d = e.unarySlash;
              i && ("p" === a && vi(n) && A(a), o(n) && a === n && A(n));
              for (var p = r(n) || !!d, u = e.attrs.length, l = new Array(u), y = 0; y < u; y++) {
                var m = e.attrs[y],
                  c = m[3] || m[4] || m[5] || "",
                  T = "a" === n && "href" === m[1] ? t.shouldDecodeNewlinesForHref : t.shouldDecodeNewlines;
                l[y] = { name: m[1], value: Vi(c, T) };
              }
              p || (s.push({ tag: n, lowerCasedTag: n.toLowerCase(), attrs: l, start: e.start, end: e.end }), (a = n)),
                t.start && t.start(n, l, p, e.start, e.end);
            }
            function A(e, n, i) {
              var r, o;
              if ((null == n && (n = d), null == i && (i = d), e))
                for (o = e.toLowerCase(), r = s.length - 1; r >= 0 && s[r].lowerCasedTag !== o; r--);
              else r = 0;
              if (r >= 0) {
                for (var p = s.length - 1; p >= r; p--) t.end && t.end(s[p].tag, n, i);
                (s.length = r), (a = r && s[r - 1].tag);
              } else
                "br" === o
                  ? t.start && t.start(e, [], !0, n, i)
                  : "p" === o && (t.start && t.start(e, [], !1, n, i), t.end && t.end(e, n, i));
            }
            A();
          })(e, {
            warn: Ui,
            expectHTML: t.expectHTML,
            isUnaryTag: t.isUnaryTag,
            canBeLeftOpenTag: t.canBeLeftOpenTag,
            shouldDecodeNewlines: t.shouldDecodeNewlines,
            shouldDecodeNewlinesForHref: t.shouldDecodeNewlinesForHref,
            shouldKeepComment: t.comments,
            outputSourceRange: t.outputSourceRange,
            start: function (e, n, r, o, l) {
              var y = (s && s.ns) || Yi(e);
              X &&
                "svg" === y &&
                (n = (function (e) {
                  for (var t = [], n = 0; n < e.length; n++) {
                    var a = e[n];
                    mr.test(a.name) || ((a.name = a.name.replace(cr, "")), t.push(a));
                  }
                  return t;
                })(n));
              var m,
                c = ir(e, n, s);
              y && (c.ns = y),
                ("style" !== (m = c).tag &&
                  ("script" !== m.tag || (m.attrsMap.type && "text/javascript" !== m.attrsMap.type))) ||
                  ie() ||
                  (c.forbidden = !0);
              for (var T = 0; T < $i.length; T++) c = $i[T](c, t) || c;
              d ||
                (!(function (e) {
                  null != Ba(e, "v-pre") && (e.pre = !0);
                })(c),
                c.pre && (d = !0)),
                Fi(c.tag) && (p = !0),
                d
                  ? (function (e) {
                      var t = e.attrsList,
                        n = t.length;
                      if (n)
                        for (var a = (e.attrs = new Array(n)), s = 0; s < n; s++)
                          (a[s] = { name: t[s].name, value: JSON.stringify(t[s].value) }),
                            null != t[s].start && ((a[s].start = t[s].start), (a[s].end = t[s].end));
                      else e.pre || (e.plain = !0);
                    })(c)
                  : c.processed ||
                    (dr(c),
                    (function (e) {
                      var t = Ba(e, "v-if");
                      if (t) (e.if = t), pr(e, { exp: t, block: e });
                      else {
                        null != Ba(e, "v-else") && (e.else = !0);
                        var n = Ba(e, "v-else-if");
                        n && (e.elseif = n);
                      }
                    })(c),
                    (function (e) {
                      null != Ba(e, "v-once") && (e.once = !0);
                    })(c)),
                a || (a = c),
                r ? u(c) : ((s = c), i.push(c));
            },
            end: function (e, t, n) {
              var a = i[i.length - 1];
              (i.length -= 1), (s = i[i.length - 1]), u(a);
            },
            chars: function (e, t, n) {
              if (s && (!X || "textarea" !== s.tag || s.attrsMap.placeholder !== e)) {
                var a,
                  i,
                  u,
                  l = s.children;
                if (
                  (e =
                    p || e.trim()
                      ? "script" === (a = s).tag || "style" === a.tag
                        ? e
                        : sr(e)
                      : l.length
                      ? o
                        ? "condense" === o && nr.test(e)
                          ? ""
                          : " "
                        : r
                        ? " "
                        : ""
                      : "")
                )
                  p || "condense" !== o || (e = e.replace(ar, " ")),
                    !d &&
                    " " !== e &&
                    (i = (function (e, t) {
                      var n = t ? yi(t) : ui;
                      if (n.test(e)) {
                        for (var a, s, i, r = [], o = [], d = (n.lastIndex = 0); (a = n.exec(e)); ) {
                          (s = a.index) > d && (o.push((i = e.slice(d, s))), r.push(JSON.stringify(i)));
                          var p = Ca(a[1].trim());
                          r.push("_s(" + p + ")"), o.push({ "@binding": p }), (d = s + a[0].length);
                        }
                        return (
                          d < e.length && (o.push((i = e.slice(d))), r.push(JSON.stringify(i))),
                          { expression: r.join("+"), tokens: o }
                        );
                      }
                    })(e, Bi))
                      ? (u = { type: 2, expression: i.expression, tokens: i.tokens, text: e })
                      : (" " === e && l.length && " " === l[l.length - 1].text) || (u = { type: 3, text: e }),
                    u && l.push(u);
              }
            },
            comment: function (e, t, n) {
              if (s) {
                var a = { type: 3, text: e, isComment: !0 };
                0, s.children.push(a);
              }
            },
          }),
          a
        );
      }
      function or(e, t) {
        var n;
        !(function (e) {
          var t = Ua(e, "key");
          if (t) {
            e.key = t;
          }
        })(e),
          (e.plain = !e.key && !e.scopedSlots && !e.attrsList.length),
          (function (e) {
            var t = Ua(e, "ref");
            t &&
              ((e.ref = t),
              (e.refInFor = (function (e) {
                var t = e;
                for (; t; ) {
                  if (void 0 !== t.for) return !0;
                  t = t.parent;
                }
                return !1;
              })(e)));
          })(e),
          (function (e) {
            var t;
            "template" === e.tag
              ? ((t = Ba(e, "scope")), (e.slotScope = t || Ba(e, "slot-scope")))
              : (t = Ba(e, "slot-scope")) && (e.slotScope = t);
            var n = Ua(e, "slot");
            n &&
              ((e.slotTarget = '""' === n ? '"default"' : n),
              (e.slotTargetDynamic = !(!e.attrsMap[":slot"] && !e.attrsMap["v-bind:slot"])),
              "template" === e.tag ||
                e.slotScope ||
                Ia(
                  e,
                  "slot",
                  n,
                  (function (e, t) {
                    return e.rawAttrsMap[":" + t] || e.rawAttrsMap["v-bind:" + t] || e.rawAttrsMap[t];
                  })(e, "slot"),
                ));
            if ("template" === e.tag) {
              var a = Ha(e, tr);
              if (a) {
                0;
                var s = ur(a),
                  i = s.name,
                  r = s.dynamic;
                (e.slotTarget = i), (e.slotTargetDynamic = r), (e.slotScope = a.value || "_empty_");
              }
            } else {
              var o = Ha(e, tr);
              if (o) {
                0;
                var d = e.scopedSlots || (e.scopedSlots = {}),
                  p = ur(o),
                  u = p.name,
                  l = p.dynamic,
                  y = (d[u] = ir("template", [], e));
                (y.slotTarget = u),
                  (y.slotTargetDynamic = l),
                  (y.children = e.children.filter(function (e) {
                    if (!e.slotScope) return (e.parent = y), !0;
                  })),
                  (y.slotScope = o.value || "_empty_"),
                  (e.children = []),
                  (e.plain = !1);
              }
            }
          })(e),
          "slot" === (n = e).tag && (n.slotName = Ua(n, "name")),
          (function (e) {
            var t;
            (t = Ua(e, "is")) && (e.component = t);
            null != Ba(e, "inline-template") && (e.inlineTemplate = !0);
          })(e);
        for (var a = 0; a < Hi.length; a++) e = Hi[a](e, t) || e;
        return (
          (function (e) {
            var t,
              n,
              a,
              s,
              i,
              r,
              o,
              d,
              p = e.attrsList;
            for (t = 0, n = p.length; t < n; t++) {
              if (((a = s = p[t].name), (i = p[t].value), zi.test(a)))
                if (((e.hasBindings = !0), (r = lr(a.replace(zi, ""))) && (a = a.replace(er, "")), Qi.test(a)))
                  (a = a.replace(Qi, "")),
                    (i = Ca(i)),
                    (d = Xi.test(a)) && (a = a.slice(1, -1)),
                    r &&
                      (r.prop && !d && "innerHtml" === (a = P(a)) && (a = "innerHTML"),
                      r.camel && !d && (a = P(a)),
                      r.sync &&
                        ((o = Fa(i, "$event")),
                        d
                          ? Va(e, '"update:"+(' + a + ")", o, null, !1, 0, p[t], !0)
                          : (Va(e, "update:" + P(a), o, null, !1, 0, p[t]),
                            S(a) !== P(a) && Va(e, "update:" + S(a), o, null, !1, 0, p[t])))),
                    (r && r.prop) || (!e.component && Ni(e.tag, e.attrsMap.type, a))
                      ? Oa(e, a, i, p[t], d)
                      : Ia(e, a, i, p[t], d);
                else if (ji.test(a))
                  (a = a.replace(ji, "")), (d = Xi.test(a)) && (a = a.slice(1, -1)), Va(e, a, i, r, !1, 0, p[t], d);
                else {
                  var u = (a = a.replace(zi, "")).match(Zi),
                    l = u && u[1];
                  (d = !1),
                    l && ((a = a.slice(0, -(l.length + 1))), Xi.test(l) && ((l = l.slice(1, -1)), (d = !0))),
                    Ea(e, a, s, i, l, d, r, p[t]);
                }
              else
                Ia(e, a, JSON.stringify(i), p[t]),
                  !e.component && "muted" === a && Ni(e.tag, e.attrsMap.type, a) && Oa(e, a, "true", p[t]);
            }
          })(e),
          e
        );
      }
      function dr(e) {
        var t;
        if ((t = Ba(e, "v-for"))) {
          var n = (function (e) {
            var t = e.match(Gi);
            if (!t) return;
            var n = {};
            n.for = t[2].trim();
            var a = t[1].trim().replace(Ji, ""),
              s = a.match(Ki);
            s
              ? ((n.alias = a.replace(Ki, "").trim()), (n.iterator1 = s[1].trim()), s[2] && (n.iterator2 = s[2].trim()))
              : (n.alias = a);
            return n;
          })(t);
          n && D(e, n);
        }
      }
      function pr(e, t) {
        e.ifConditions || (e.ifConditions = []), e.ifConditions.push(t);
      }
      function ur(e) {
        var t = e.name.replace(tr, "");
        return (
          t || ("#" !== e.name[0] && (t = "default")),
          Xi.test(t) ? { name: t.slice(1, -1), dynamic: !0 } : { name: '"' + t + '"', dynamic: !1 }
        );
      }
      function lr(e) {
        var t = e.match(er);
        if (t) {
          var n = {};
          return (
            t.forEach(function (e) {
              n[e.slice(1)] = !0;
            }),
            n
          );
        }
      }
      function yr(e) {
        for (var t = {}, n = 0, a = e.length; n < a; n++) t[e[n].name] = e[n].value;
        return t;
      }
      var mr = /^xmlns:NS\d+/,
        cr = /^NS\d+:/;
      function Tr(e) {
        return ir(e.tag, e.attrsList.slice(), e.parent);
      }
      var fr = [
        mi,
        Ti,
        {
          preTransformNode: function (e, t) {
            if ("input" === e.tag) {
              var n,
                a = e.attrsMap;
              if (!a["v-model"]) return;
              if (
                ((a[":type"] || a["v-bind:type"]) && (n = Ua(e, "type")),
                a.type || n || !a["v-bind"] || (n = "(" + a["v-bind"] + ").type"),
                n)
              ) {
                var s = Ba(e, "v-if", !0),
                  i = s ? "&&(" + s + ")" : "",
                  r = null != Ba(e, "v-else", !0),
                  o = Ba(e, "v-else-if", !0),
                  d = Tr(e);
                dr(d),
                  La(d, "type", "checkbox"),
                  or(d, t),
                  (d.processed = !0),
                  (d.if = "(" + n + ")==='checkbox'" + i),
                  pr(d, { exp: d.if, block: d });
                var p = Tr(e);
                Ba(p, "v-for", !0),
                  La(p, "type", "radio"),
                  or(p, t),
                  pr(d, { exp: "(" + n + ")==='radio'" + i, block: p });
                var u = Tr(e);
                return (
                  Ba(u, "v-for", !0),
                  La(u, ":type", n),
                  or(u, t),
                  pr(d, { exp: s, block: u }),
                  r ? (d.else = !0) : o && (d.elseif = o),
                  d
                );
              }
            }
          },
        },
      ];
      var br,
        gr,
        vr = {
          expectHTML: !0,
          modules: fr,
          directives: {
            model: function (e, t, n) {
              n;
              var a = t.value,
                s = t.modifiers,
                i = e.tag,
                r = e.attrsMap.type;
              if (e.component) return Wa(e, a, s), !1;
              if ("select" === i)
                !(function (e, t, n) {
                  var a =
                    'var $$selectedVal = Array.prototype.filter.call($event.target.options,function(o){return o.selected}).map(function(o){var val = "_value" in o ? o._value : o.value;return ' +
                    (n && n.number ? "_n(val)" : "val") +
                    "});";
                  (a = a + " " + Fa(t, "$event.target.multiple ? $$selectedVal : $$selectedVal[0]")),
                    Va(e, "change", a, null, !0);
                })(e, a, s);
              else if ("input" === i && "checkbox" === r)
                !(function (e, t, n) {
                  var a = n && n.number,
                    s = Ua(e, "value") || "null",
                    i = Ua(e, "true-value") || "true",
                    r = Ua(e, "false-value") || "false";
                  Oa(
                    e,
                    "checked",
                    "Array.isArray(" +
                      t +
                      ")?_i(" +
                      t +
                      "," +
                      s +
                      ")>-1" +
                      ("true" === i ? ":(" + t + ")" : ":_q(" + t + "," + i + ")"),
                  ),
                    Va(
                      e,
                      "change",
                      "var $$a=" +
                        t +
                        ",$$el=$event.target,$$c=$$el.checked?(" +
                        i +
                        "):(" +
                        r +
                        ");if(Array.isArray($$a)){var $$v=" +
                        (a ? "_n(" + s + ")" : s) +
                        ",$$i=_i($$a,$$v);if($$el.checked){$$i<0&&(" +
                        Fa(t, "$$a.concat([$$v])") +
                        ")}else{$$i>-1&&(" +
                        Fa(t, "$$a.slice(0,$$i).concat($$a.slice($$i+1))") +
                        ")}}else{" +
                        Fa(t, "$$c") +
                        "}",
                      null,
                      !0,
                    );
                })(e, a, s);
              else if ("input" === i && "radio" === r)
                !(function (e, t, n) {
                  var a = n && n.number,
                    s = Ua(e, "value") || "null";
                  Oa(e, "checked", "_q(" + t + "," + (s = a ? "_n(" + s + ")" : s) + ")"),
                    Va(e, "change", Fa(t, s), null, !0);
                })(e, a, s);
              else if ("input" === i || "textarea" === i)
                !(function (e, t, n) {
                  var a = e.attrsMap.type;
                  0;
                  var s = n || {},
                    i = s.lazy,
                    r = s.number,
                    o = s.trim,
                    d = !i && "range" !== a,
                    p = i ? "change" : "range" === a ? "__r" : "input",
                    u = "$event.target.value";
                  o && (u = "$event.target.value.trim()");
                  r && (u = "_n(" + u + ")");
                  var l = Fa(t, u);
                  d && (l = "if($event.target.composing)return;" + l);
                  Oa(e, "value", "(" + t + ")"), Va(e, p, l, null, !0), (o || r) && Va(e, "blur", "$forceUpdate()");
                })(e, a, s);
              else {
                if (!H.isReservedTag(i)) return Wa(e, a, s), !1;
              }
              return !0;
            },
            text: function (e, t) {
              t.value && Oa(e, "textContent", "_s(" + t.value + ")", t);
            },
            html: function (e, t) {
              t.value && Oa(e, "innerHTML", "_s(" + t.value + ")", t);
            },
          },
          isPreTag: function (e) {
            return "pre" === e;
          },
          isUnaryTag: bi,
          mustUseProp: En,
          canBeLeftOpenTag: gi,
          isReservedTag: Jn,
          getTagNamespace: Xn,
          staticKeys: (function (e) {
            return e
              .reduce(function (e, t) {
                return e.concat(t.staticKeys || []);
              }, [])
              .join(",");
          })(fr),
        },
        hr = w(function (e) {
          return f(
            "type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap" + (e ? "," + e : ""),
          );
        });
      function _r(e, t) {
        e &&
          ((br = hr(t.staticKeys || "")),
          (gr = t.isReservedTag || I),
          (function e(t) {
            if (
              ((t.static = (function (e) {
                if (2 === e.type) return !1;
                if (3 === e.type) return !0;
                return !(
                  !e.pre &&
                  (e.hasBindings ||
                    e.if ||
                    e.for ||
                    b(e.tag) ||
                    !gr(e.tag) ||
                    (function (e) {
                      for (; e.parent; ) {
                        if ("template" !== (e = e.parent).tag) return !1;
                        if (e.for) return !0;
                      }
                      return !1;
                    })(e) ||
                    !Object.keys(e).every(br))
                );
              })(t)),
              1 === t.type)
            ) {
              if (!gr(t.tag) && "slot" !== t.tag && null == t.attrsMap["inline-template"]) return;
              for (var n = 0, a = t.children.length; n < a; n++) {
                var s = t.children[n];
                e(s), s.static || (t.static = !1);
              }
              if (t.ifConditions)
                for (var i = 1, r = t.ifConditions.length; i < r; i++) {
                  var o = t.ifConditions[i].block;
                  e(o), o.static || (t.static = !1);
                }
            }
          })(e),
          (function e(t, n) {
            if (1 === t.type) {
              if (
                ((t.static || t.once) && (t.staticInFor = n),
                t.static && t.children.length && (1 !== t.children.length || 3 !== t.children[0].type))
              )
                return void (t.staticRoot = !0);
              if (((t.staticRoot = !1), t.children))
                for (var a = 0, s = t.children.length; a < s; a++) e(t.children[a], n || !!t.for);
              if (t.ifConditions) for (var i = 1, r = t.ifConditions.length; i < r; i++) e(t.ifConditions[i].block, n);
            }
          })(e, !1));
      }
      var wr = /^([\w$_]+|\([^)]*?\))\s*=>|^function(?:\s+[\w$]+)?\s*\(/,
        kr = /\([^)]*?\);*$/,
        Pr = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,
        Mr = { esc: 27, tab: 9, enter: 13, space: 32, up: 38, left: 37, right: 39, down: 40, delete: [8, 46] },
        Ar = {
          esc: ["Esc", "Escape"],
          tab: "Tab",
          enter: "Enter",
          space: [" ", "Spacebar"],
          up: ["Up", "ArrowUp"],
          left: ["Left", "ArrowLeft"],
          right: ["Right", "ArrowRight"],
          down: ["Down", "ArrowDown"],
          delete: ["Backspace", "Delete", "Del"],
        },
        Sr = function (e) {
          return "if(" + e + ")return null;";
        },
        Cr = {
          stop: "$event.stopPropagation();",
          prevent: "$event.preventDefault();",
          self: Sr("$event.target !== $event.currentTarget"),
          ctrl: Sr("!$event.ctrlKey"),
          shift: Sr("!$event.shiftKey"),
          alt: Sr("!$event.altKey"),
          meta: Sr("!$event.metaKey"),
          left: Sr("'button' in $event && $event.button !== 0"),
          middle: Sr("'button' in $event && $event.button !== 1"),
          right: Sr("'button' in $event && $event.button !== 2"),
        };
      function Rr(e, t) {
        var n = t ? "nativeOn:" : "on:",
          a = "",
          s = "";
        for (var i in e) {
          var r = Dr(e[i]);
          e[i] && e[i].dynamic ? (s += i + "," + r + ",") : (a += '"' + i + '":' + r + ",");
        }
        return (a = "{" + a.slice(0, -1) + "}"), s ? n + "_d(" + a + ",[" + s.slice(0, -1) + "])" : n + a;
      }
      function Dr(e) {
        if (!e) return "function(){}";
        if (Array.isArray(e))
          return (
            "[" +
            e
              .map(function (e) {
                return Dr(e);
              })
              .join(",") +
            "]"
          );
        var t = Pr.test(e.value),
          n = wr.test(e.value),
          a = Pr.test(e.value.replace(kr, ""));
        if (e.modifiers) {
          var s = "",
            i = "",
            r = [];
          for (var o in e.modifiers)
            if (Cr[o]) (i += Cr[o]), Mr[o] && r.push(o);
            else if ("exact" === o) {
              var d = e.modifiers;
              i += Sr(
                ["ctrl", "shift", "alt", "meta"]
                  .filter(function (e) {
                    return !d[e];
                  })
                  .map(function (e) {
                    return "$event." + e + "Key";
                  })
                  .join("||"),
              );
            } else r.push(o);
          return (
            r.length &&
              (s += (function (e) {
                return "if(!$event.type.indexOf('key')&&" + e.map(xr).join("&&") + ")return null;";
              })(r)),
            i && (s += i),
            "function($event){" +
              s +
              (t
                ? "return " + e.value + "($event)"
                : n
                ? "return (" + e.value + ")($event)"
                : a
                ? "return " + e.value
                : e.value) +
              "}"
          );
        }
        return t || n ? e.value : "function($event){" + (a ? "return " + e.value : e.value) + "}";
      }
      function xr(e) {
        var t = parseInt(e, 10);
        if (t) return "$event.keyCode!==" + t;
        var n = Mr[e],
          a = Ar[e];
        return (
          "_k($event.keyCode," + JSON.stringify(e) + "," + JSON.stringify(n) + ",$event.key," + JSON.stringify(a) + ")"
        );
      }
      var Or = {
          on: function (e, t) {
            e.wrapListeners = function (e) {
              return "_g(" + e + "," + t.value + ")";
            };
          },
          bind: function (e, t) {
            e.wrapData = function (n) {
              return (
                "_b(" +
                n +
                ",'" +
                e.tag +
                "'," +
                t.value +
                "," +
                (t.modifiers && t.modifiers.prop ? "true" : "false") +
                (t.modifiers && t.modifiers.sync ? ",true" : "") +
                ")"
              );
            };
          },
          cloak: O,
        },
        Ir = function (e) {
          (this.options = e),
            (this.warn = e.warn || Da),
            (this.transforms = xa(e.modules, "transformCode")),
            (this.dataGenFns = xa(e.modules, "genData")),
            (this.directives = D(D({}, Or), e.directives));
          var t = e.isReservedTag || I;
          (this.maybeComponent = function (e) {
            return !!e.component || !t(e.tag);
          }),
            (this.onceId = 0),
            (this.staticRenderFns = []),
            (this.pre = !1);
        };
      function Lr(e, t) {
        var n = new Ir(t);
        return {
          render: "with(this){return " + (e ? Er(e, n) : '_c("div")') + "}",
          staticRenderFns: n.staticRenderFns,
        };
      }
      function Er(e, t) {
        if ((e.parent && (e.pre = e.pre || e.parent.pre), e.staticRoot && !e.staticProcessed)) return qr(e, t);
        if (e.once && !e.onceProcessed) return Vr(e, t);
        if (e.for && !e.forProcessed) return Br(e, t);
        if (e.if && !e.ifProcessed) return Ur(e, t);
        if ("template" !== e.tag || e.slotTarget || t.pre) {
          if ("slot" === e.tag)
            return (function (e, t) {
              var n = e.slotName || '"default"',
                a = Fr(e, t),
                s = "_t(" + n + (a ? "," + a : ""),
                i =
                  e.attrs || e.dynamicAttrs
                    ? jr(
                        (e.attrs || []).concat(e.dynamicAttrs || []).map(function (e) {
                          return { name: P(e.name), value: e.value, dynamic: e.dynamic };
                        }),
                      )
                    : null,
                r = e.attrsMap["v-bind"];
              (!i && !r) || a || (s += ",null");
              i && (s += "," + i);
              r && (s += (i ? "" : ",null") + "," + r);
              return s + ")";
            })(e, t);
          var n;
          if (e.component)
            n = (function (e, t, n) {
              var a = t.inlineTemplate ? null : Fr(t, n, !0);
              return "_c(" + e + "," + Hr(t, n) + (a ? "," + a : "") + ")";
            })(e.component, e, t);
          else {
            var a;
            (!e.plain || (e.pre && t.maybeComponent(e))) && (a = Hr(e, t));
            var s = e.inlineTemplate ? null : Fr(e, t, !0);
            n = "_c('" + e.tag + "'" + (a ? "," + a : "") + (s ? "," + s : "") + ")";
          }
          for (var i = 0; i < t.transforms.length; i++) n = t.transforms[i](e, n);
          return n;
        }
        return Fr(e, t) || "void 0";
      }
      function qr(e, t) {
        e.staticProcessed = !0;
        var n = t.pre;
        return (
          e.pre && (t.pre = e.pre),
          t.staticRenderFns.push("with(this){return " + Er(e, t) + "}"),
          (t.pre = n),
          "_m(" + (t.staticRenderFns.length - 1) + (e.staticInFor ? ",true" : "") + ")"
        );
      }
      function Vr(e, t) {
        if (((e.onceProcessed = !0), e.if && !e.ifProcessed)) return Ur(e, t);
        if (e.staticInFor) {
          for (var n = "", a = e.parent; a; ) {
            if (a.for) {
              n = a.key;
              break;
            }
            a = a.parent;
          }
          return n ? "_o(" + Er(e, t) + "," + t.onceId++ + "," + n + ")" : Er(e, t);
        }
        return qr(e, t);
      }
      function Ur(e, t, n, a) {
        return (
          (e.ifProcessed = !0),
          (function e(t, n, a, s) {
            if (!t.length) return s || "_e()";
            var i = t.shift();
            return i.exp ? "(" + i.exp + ")?" + r(i.block) + ":" + e(t, n, a, s) : "" + r(i.block);
            function r(e) {
              return a ? a(e, n) : e.once ? Vr(e, n) : Er(e, n);
            }
          })(e.ifConditions.slice(), t, n, a)
        );
      }
      function Br(e, t, n, a) {
        var s = e.for,
          i = e.alias,
          r = e.iterator1 ? "," + e.iterator1 : "",
          o = e.iterator2 ? "," + e.iterator2 : "";
        return (
          (e.forProcessed = !0),
          (a || "_l") + "((" + s + "),function(" + i + r + o + "){return " + (n || Er)(e, t) + "})"
        );
      }
      function Hr(e, t) {
        var n = "{",
          a = (function (e, t) {
            var n = e.directives;
            if (!n) return;
            var a,
              s,
              i,
              r,
              o = "directives:[",
              d = !1;
            for (a = 0, s = n.length; a < s; a++) {
              (i = n[a]), (r = !0);
              var p = t.directives[i.name];
              p && (r = !!p(e, i, t.warn)),
                r &&
                  ((d = !0),
                  (o +=
                    '{name:"' +
                    i.name +
                    '",rawName:"' +
                    i.rawName +
                    '"' +
                    (i.value ? ",value:(" + i.value + "),expression:" + JSON.stringify(i.value) : "") +
                    (i.arg ? ",arg:" + (i.isDynamicArg ? i.arg : '"' + i.arg + '"') : "") +
                    (i.modifiers ? ",modifiers:" + JSON.stringify(i.modifiers) : "") +
                    "},"));
            }
            if (d) return o.slice(0, -1) + "]";
          })(e, t);
        a && (n += a + ","),
          e.key && (n += "key:" + e.key + ","),
          e.ref && (n += "ref:" + e.ref + ","),
          e.refInFor && (n += "refInFor:true,"),
          e.pre && (n += "pre:true,"),
          e.component && (n += 'tag:"' + e.tag + '",');
        for (var s = 0; s < t.dataGenFns.length; s++) n += t.dataGenFns[s](e);
        if (
          (e.attrs && (n += "attrs:" + jr(e.attrs) + ","),
          e.props && (n += "domProps:" + jr(e.props) + ","),
          e.events && (n += Rr(e.events, !1) + ","),
          e.nativeEvents && (n += Rr(e.nativeEvents, !0) + ","),
          e.slotTarget && !e.slotScope && (n += "slot:" + e.slotTarget + ","),
          e.scopedSlots &&
            (n +=
              (function (e, t, n) {
                var a =
                    e.for ||
                    Object.keys(t).some(function (e) {
                      var n = t[e];
                      return n.slotTargetDynamic || n.if || n.for || $r(n);
                    }),
                  s = !!e.if;
                if (!a)
                  for (var i = e.parent; i; ) {
                    if ((i.slotScope && "_empty_" !== i.slotScope) || i.for) {
                      a = !0;
                      break;
                    }
                    i.if && (s = !0), (i = i.parent);
                  }
                var r = Object.keys(t)
                  .map(function (e) {
                    return Wr(t[e], n);
                  })
                  .join(",");
                return (
                  "scopedSlots:_u([" +
                  r +
                  "]" +
                  (a ? ",null,true" : "") +
                  (!a && s
                    ? ",null,false," +
                      (function (e) {
                        var t = 5381,
                          n = e.length;
                        for (; n; ) t = (33 * t) ^ e.charCodeAt(--n);
                        return t >>> 0;
                      })(r)
                    : "") +
                  ")"
                );
              })(e, e.scopedSlots, t) + ","),
          e.model &&
            (n +=
              "model:{value:" +
              e.model.value +
              ",callback:" +
              e.model.callback +
              ",expression:" +
              e.model.expression +
              "},"),
          e.inlineTemplate)
        ) {
          var i = (function (e, t) {
            var n = e.children[0];
            0;
            if (n && 1 === n.type) {
              var a = Lr(n, t.options);
              return (
                "inlineTemplate:{render:function(){" +
                a.render +
                "},staticRenderFns:[" +
                a.staticRenderFns
                  .map(function (e) {
                    return "function(){" + e + "}";
                  })
                  .join(",") +
                "]}"
              );
            }
          })(e, t);
          i && (n += i + ",");
        }
        return (
          (n = n.replace(/,$/, "") + "}"),
          e.dynamicAttrs && (n = "_b(" + n + ',"' + e.tag + '",' + jr(e.dynamicAttrs) + ")"),
          e.wrapData && (n = e.wrapData(n)),
          e.wrapListeners && (n = e.wrapListeners(n)),
          n
        );
      }
      function $r(e) {
        return 1 === e.type && ("slot" === e.tag || e.children.some($r));
      }
      function Wr(e, t) {
        var n = e.attrsMap["slot-scope"];
        if (e.if && !e.ifProcessed && !n) return Ur(e, t, Wr, "null");
        if (e.for && !e.forProcessed) return Br(e, t, Wr);
        var a = "_empty_" === e.slotScope ? "" : String(e.slotScope),
          s =
            "function(" +
            a +
            "){return " +
            ("template" === e.tag
              ? e.if && n
                ? "(" + e.if + ")?" + (Fr(e, t) || "undefined") + ":undefined"
                : Fr(e, t) || "undefined"
              : Er(e, t)) +
            "}",
          i = a ? "" : ",proxy:true";
        return "{key:" + (e.slotTarget || '"default"') + ",fn:" + s + i + "}";
      }
      function Fr(e, t, n, a, s) {
        var i = e.children;
        if (i.length) {
          var r = i[0];
          if (1 === i.length && r.for && "template" !== r.tag && "slot" !== r.tag) {
            var o = n ? (t.maybeComponent(r) ? ",1" : ",0") : "";
            return "" + (a || Er)(r, t) + o;
          }
          var d = n
              ? (function (e, t) {
                  for (var n = 0, a = 0; a < e.length; a++) {
                    var s = e[a];
                    if (1 === s.type) {
                      if (
                        Nr(s) ||
                        (s.ifConditions &&
                          s.ifConditions.some(function (e) {
                            return Nr(e.block);
                          }))
                      ) {
                        n = 2;
                        break;
                      }
                      (t(s) ||
                        (s.ifConditions &&
                          s.ifConditions.some(function (e) {
                            return t(e.block);
                          }))) &&
                        (n = 1);
                    }
                  }
                  return n;
                })(i, t.maybeComponent)
              : 0,
            p = s || Yr;
          return (
            "[" +
            i
              .map(function (e) {
                return p(e, t);
              })
              .join(",") +
            "]" +
            (d ? "," + d : "")
          );
        }
      }
      function Nr(e) {
        return void 0 !== e.for || "template" === e.tag || "slot" === e.tag;
      }
      function Yr(e, t) {
        return 1 === e.type
          ? Er(e, t)
          : 3 === e.type && e.isComment
          ? (function (e) {
              return "_e(" + JSON.stringify(e.text) + ")";
            })(e)
          : (function (e) {
              return "_v(" + (2 === e.type ? e.expression : zr(JSON.stringify(e.text))) + ")";
            })(e);
      }
      function jr(e) {
        for (var t = "", n = "", a = 0; a < e.length; a++) {
          var s = e[a],
            i = zr(s.value);
          s.dynamic ? (n += s.name + "," + i + ",") : (t += '"' + s.name + '":' + i + ",");
        }
        return (t = "{" + t.slice(0, -1) + "}"), n ? "_d(" + t + ",[" + n.slice(0, -1) + "])" : t;
      }
      function zr(e) {
        return e.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
      }
      new RegExp(
        "\\b" +
          "do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,super,throw,while,yield,delete,export,import,return,switch,default,extends,finally,continue,debugger,function,arguments"
            .split(",")
            .join("\\b|\\b") +
          "\\b",
      ),
        new RegExp("\\b" + "delete,typeof,void".split(",").join("\\s*\\([^\\)]*\\)|\\b") + "\\s*\\([^\\)]*\\)");
      function Gr(e, t) {
        try {
          return new Function(e);
        } catch (n) {
          return t.push({ err: n, code: e }), O;
        }
      }
      function Kr(e) {
        var t = Object.create(null);
        return function (n, a, s) {
          (a = D({}, a)).warn;
          delete a.warn;
          var i = a.delimiters ? String(a.delimiters) + n : n;
          if (t[i]) return t[i];
          var r = e(n, a);
          var o = {},
            d = [];
          return (
            (o.render = Gr(r.render, d)),
            (o.staticRenderFns = r.staticRenderFns.map(function (e) {
              return Gr(e, d);
            })),
            (t[i] = o)
          );
        };
      }
      var Jr,
        Xr,
        Zr = ((Jr = function (e, t) {
          var n = rr(e.trim(), t);
          !1 !== t.optimize && _r(n, t);
          var a = Lr(n, t);
          return { ast: n, render: a.render, staticRenderFns: a.staticRenderFns };
        }),
        function (e) {
          function t(t, n) {
            var a = Object.create(e),
              s = [],
              i = [];
            if (n)
              for (var r in (n.modules && (a.modules = (e.modules || []).concat(n.modules)),
              n.directives && (a.directives = D(Object.create(e.directives || null), n.directives)),
              n))
                "modules" !== r && "directives" !== r && (a[r] = n[r]);
            a.warn = function (e, t, n) {
              (n ? i : s).push(e);
            };
            var o = Jr(t.trim(), a);
            return (o.errors = s), (o.tips = i), o;
          }
          return { compile: t, compileToFunctions: Kr(t) };
        })(vr),
        Qr = (Zr.compile, Zr.compileToFunctions);
      function eo(e) {
        return (
          ((Xr = Xr || document.createElement("div")).innerHTML = e ? '<a href="\n"/>' : '<div a="\n"/>'),
          Xr.innerHTML.indexOf("&#10;") > 0
        );
      }
      var to = !!z && eo(!1),
        no = !!z && eo(!0),
        ao = w(function (e) {
          var t = ea(e);
          return t && t.innerHTML;
        }),
        so = Mn.prototype.$mount;
      (Mn.prototype.$mount = function (e, t) {
        if ((e = e && ea(e)) === document.body || e === document.documentElement) return this;
        var n = this.$options;
        if (!n.render) {
          var a = n.template;
          if (a)
            if ("string" == typeof a) "#" === a.charAt(0) && (a = ao(a));
            else {
              if (!a.nodeType) return this;
              a = a.innerHTML;
            }
          else
            e &&
              (a = (function (e) {
                if (e.outerHTML) return e.outerHTML;
                var t = document.createElement("div");
                return t.appendChild(e.cloneNode(!0)), t.innerHTML;
              })(e));
          if (a) {
            0;
            var s = Qr(
                a,
                {
                  outputSourceRange: !1,
                  shouldDecodeNewlines: to,
                  shouldDecodeNewlinesForHref: no,
                  delimiters: n.delimiters,
                  comments: n.comments,
                },
                this,
              ),
              i = s.render,
              r = s.staticRenderFns;
            (n.render = i), (n.staticRenderFns = r);
          }
        }
        return so.call(this, e, t);
      }),
        (Mn.compile = Qr),
        (t.a = Mn);
    }.call(this, n(0), n(7).setImmediate));
  },
  function (e) {
    e.exports = JSON.parse('{"a":"hardhat-docgen","b":"https://github.com/ItsNickBarry/hardhat-docgen"}');
  },
  function (e, t, n) {
    var a = n(5);
    a.__esModule && (a = a.default), "string" == typeof a && (a = [[e.i, a, ""]]), a.locals && (e.exports = a.locals);
    (0, n(11).default)("0b345cf4", a, !1, {});
  },
  function (e, t, n) {
    "use strict";
    n(3);
  },
  function (e, t, n) {
    (t = e.exports = n(6)(!1)).push([
      e.i,
      "@import url(https://fonts.googleapis.com/css2?family=Source+Code+Pro:wght@400;500;600;700&display=swap);",
      "",
    ]),
      t.push([e.i, "\nhtml,\nbody {\n  font-family: 'Source Code Pro', monospace;\n}\n", ""]);
  },
  function (e, t, n) {
    "use strict";
    e.exports = function (e) {
      var t = [];
      return (
        (t.toString = function () {
          return this.map(function (t) {
            var n = (function (e, t) {
              var n = e[1] || "",
                a = e[3];
              if (!a) return n;
              if (t && "function" == typeof btoa) {
                var s =
                    ((r = a),
                    "/*# sourceMappingURL=data:application/json;charset=utf-8;base64," +
                      btoa(unescape(encodeURIComponent(JSON.stringify(r)))) +
                      " */"),
                  i = a.sources.map(function (e) {
                    return "/*# sourceURL=" + a.sourceRoot + e + " */";
                  });
                return [n].concat(i).concat([s]).join("\n");
              }
              var r;
              return [n].join("\n");
            })(t, e);
            return t[2] ? "@media " + t[2] + "{" + n + "}" : n;
          }).join("");
        }),
        (t.i = function (e, n) {
          "string" == typeof e && (e = [[null, e, ""]]);
          for (var a = {}, s = 0; s < this.length; s++) {
            var i = this[s][0];
            null != i && (a[i] = !0);
          }
          for (s = 0; s < e.length; s++) {
            var r = e[s];
            (null != r[0] && a[r[0]]) ||
              (n && !r[2] ? (r[2] = n) : n && (r[2] = "(" + r[2] + ") and (" + n + ")"), t.push(r));
          }
        }),
        t
      );
    };
  },
  function (e, t, n) {
    (function (e) {
      var a = (void 0 !== e && e) || ("undefined" != typeof self && self) || window,
        s = Function.prototype.apply;
      function i(e, t) {
        (this._id = e), (this._clearFn = t);
      }
      (t.setTimeout = function () {
        return new i(s.call(setTimeout, a, arguments), clearTimeout);
      }),
        (t.setInterval = function () {
          return new i(s.call(setInterval, a, arguments), clearInterval);
        }),
        (t.clearTimeout = t.clearInterval = function (e) {
          e && e.close();
        }),
        (i.prototype.unref = i.prototype.ref = function () {}),
        (i.prototype.close = function () {
          this._clearFn.call(a, this._id);
        }),
        (t.enroll = function (e, t) {
          clearTimeout(e._idleTimeoutId), (e._idleTimeout = t);
        }),
        (t.unenroll = function (e) {
          clearTimeout(e._idleTimeoutId), (e._idleTimeout = -1);
        }),
        (t._unrefActive = t.active = function (e) {
          clearTimeout(e._idleTimeoutId);
          var t = e._idleTimeout;
          t >= 0 &&
            (e._idleTimeoutId = setTimeout(function () {
              e._onTimeout && e._onTimeout();
            }, t));
        }),
        n(8),
        (t.setImmediate =
          ("undefined" != typeof self && self.setImmediate) ||
          (void 0 !== e && e.setImmediate) ||
          (this && this.setImmediate)),
        (t.clearImmediate =
          ("undefined" != typeof self && self.clearImmediate) ||
          (void 0 !== e && e.clearImmediate) ||
          (this && this.clearImmediate));
    }.call(this, n(0)));
  },
  function (e, t, n) {
    (function (e, t) {
      !(function (e, n) {
        "use strict";
        if (!e.setImmediate) {
          var a,
            s,
            i,
            r,
            o,
            d = 1,
            p = {},
            u = !1,
            l = e.document,
            y = Object.getPrototypeOf && Object.getPrototypeOf(e);
          (y = y && y.setTimeout ? y : e),
            "[object process]" === {}.toString.call(e.process)
              ? (a = function (e) {
                  t.nextTick(function () {
                    c(e);
                  });
                })
              : !(function () {
                  if (e.postMessage && !e.importScripts) {
                    var t = !0,
                      n = e.onmessage;
                    return (
                      (e.onmessage = function () {
                        t = !1;
                      }),
                      e.postMessage("", "*"),
                      (e.onmessage = n),
                      t
                    );
                  }
                })()
              ? e.MessageChannel
                ? (((i = new MessageChannel()).port1.onmessage = function (e) {
                    c(e.data);
                  }),
                  (a = function (e) {
                    i.port2.postMessage(e);
                  }))
                : l && "onreadystatechange" in l.createElement("script")
                ? ((s = l.documentElement),
                  (a = function (e) {
                    var t = l.createElement("script");
                    (t.onreadystatechange = function () {
                      c(e), (t.onreadystatechange = null), s.removeChild(t), (t = null);
                    }),
                      s.appendChild(t);
                  }))
                : (a = function (e) {
                    setTimeout(c, 0, e);
                  })
              : ((r = "setImmediate$" + Math.random() + "$"),
                (o = function (t) {
                  t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(r) && c(+t.data.slice(r.length));
                }),
                e.addEventListener ? e.addEventListener("message", o, !1) : e.attachEvent("onmessage", o),
                (a = function (t) {
                  e.postMessage(r + t, "*");
                })),
            (y.setImmediate = function (e) {
              "function" != typeof e && (e = new Function("" + e));
              for (var t = new Array(arguments.length - 1), n = 0; n < t.length; n++) t[n] = arguments[n + 1];
              var s = { callback: e, args: t };
              return (p[d] = s), a(d), d++;
            }),
            (y.clearImmediate = m);
        }
        function m(e) {
          delete p[e];
        }
        function c(e) {
          if (u) setTimeout(c, 0, e);
          else {
            var t = p[e];
            if (t) {
              u = !0;
              try {
                !(function (e) {
                  var t = e.callback,
                    n = e.args;
                  switch (n.length) {
                    case 0:
                      t();
                      break;
                    case 1:
                      t(n[0]);
                      break;
                    case 2:
                      t(n[0], n[1]);
                      break;
                    case 3:
                      t(n[0], n[1], n[2]);
                      break;
                    default:
                      t.apply(void 0, n);
                  }
                })(t);
              } finally {
                m(e), (u = !1);
              }
            }
          }
        }
      })("undefined" == typeof self ? (void 0 === e ? this : e) : self);
    }.call(this, n(0), n(9)));
  },
  function (e, t) {
    var n,
      a,
      s = (e.exports = {});
    function i() {
      throw new Error("setTimeout has not been defined");
    }
    function r() {
      throw new Error("clearTimeout has not been defined");
    }
    function o(e) {
      if (n === setTimeout) return setTimeout(e, 0);
      if ((n === i || !n) && setTimeout) return (n = setTimeout), setTimeout(e, 0);
      try {
        return n(e, 0);
      } catch (t) {
        try {
          return n.call(null, e, 0);
        } catch (t) {
          return n.call(this, e, 0);
        }
      }
    }
    !(function () {
      try {
        n = "function" == typeof setTimeout ? setTimeout : i;
      } catch (e) {
        n = i;
      }
      try {
        a = "function" == typeof clearTimeout ? clearTimeout : r;
      } catch (e) {
        a = r;
      }
    })();
    var d,
      p = [],
      u = !1,
      l = -1;
    function y() {
      u && d && ((u = !1), d.length ? (p = d.concat(p)) : (l = -1), p.length && m());
    }
    function m() {
      if (!u) {
        var e = o(y);
        u = !0;
        for (var t = p.length; t; ) {
          for (d = p, p = []; ++l < t; ) d && d[l].run();
          (l = -1), (t = p.length);
        }
        (d = null),
          (u = !1),
          (function (e) {
            if (a === clearTimeout) return clearTimeout(e);
            if ((a === r || !a) && clearTimeout) return (a = clearTimeout), clearTimeout(e);
            try {
              a(e);
            } catch (t) {
              try {
                return a.call(null, e);
              } catch (t) {
                return a.call(this, e);
              }
            }
          })(e);
      }
    }
    function c(e, t) {
      (this.fun = e), (this.array = t);
    }
    function T() {}
    (s.nextTick = function (e) {
      var t = new Array(arguments.length - 1);
      if (arguments.length > 1) for (var n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      p.push(new c(e, t)), 1 !== p.length || u || o(m);
    }),
      (c.prototype.run = function () {
        this.fun.apply(null, this.array);
      }),
      (s.title = "browser"),
      (s.browser = !0),
      (s.env = {}),
      (s.argv = []),
      (s.version = ""),
      (s.versions = {}),
      (s.on = T),
      (s.addListener = T),
      (s.once = T),
      (s.off = T),
      (s.removeListener = T),
      (s.removeAllListeners = T),
      (s.emit = T),
      (s.prependListener = T),
      (s.prependOnceListener = T),
      (s.listeners = function (e) {
        return [];
      }),
      (s.binding = function (e) {
        throw new Error("process.binding is not supported");
      }),
      (s.cwd = function () {
        return "/";
      }),
      (s.chdir = function (e) {
        throw new Error("process.chdir is not supported");
      }),
      (s.umask = function () {
        return 0;
      });
  },
  function (e, t, n) {
    "use strict";
    n.r(t);
    var a = n(1);
    /*!
     * vue-router v3.5.1
     * (c) 2021 Evan You
     * @license MIT
     */ function s(e, t) {
      for (var n in t) e[n] = t[n];
      return e;
    }
    var i = /[!'()*]/g,
      r = function (e) {
        return "%" + e.charCodeAt(0).toString(16);
      },
      o = /%2C/g,
      d = function (e) {
        return encodeURIComponent(e).replace(i, r).replace(o, ",");
      };
    function p(e) {
      try {
        return decodeURIComponent(e);
      } catch (e) {
        0;
      }
      return e;
    }
    var u = function (e) {
      return null == e || "object" == typeof e ? e : String(e);
    };
    function l(e) {
      var t = {};
      return (e = e.trim().replace(/^(\?|#|&)/, ""))
        ? (e.split("&").forEach(function (e) {
            var n = e.replace(/\+/g, " ").split("="),
              a = p(n.shift()),
              s = n.length > 0 ? p(n.join("=")) : null;
            void 0 === t[a] ? (t[a] = s) : Array.isArray(t[a]) ? t[a].push(s) : (t[a] = [t[a], s]);
          }),
          t)
        : t;
    }
    function y(e) {
      var t = e
        ? Object.keys(e)
            .map(function (t) {
              var n = e[t];
              if (void 0 === n) return "";
              if (null === n) return d(t);
              if (Array.isArray(n)) {
                var a = [];
                return (
                  n.forEach(function (e) {
                    void 0 !== e && (null === e ? a.push(d(t)) : a.push(d(t) + "=" + d(e)));
                  }),
                  a.join("&")
                );
              }
              return d(t) + "=" + d(n);
            })
            .filter(function (e) {
              return e.length > 0;
            })
            .join("&")
        : null;
      return t ? "?" + t : "";
    }
    var m = /\/?$/;
    function c(e, t, n, a) {
      var s = a && a.options.stringifyQuery,
        i = t.query || {};
      try {
        i = T(i);
      } catch (e) {}
      var r = {
        name: t.name || (e && e.name),
        meta: (e && e.meta) || {},
        path: t.path || "/",
        hash: t.hash || "",
        query: i,
        params: t.params || {},
        fullPath: g(t, s),
        matched: e ? b(e) : [],
      };
      return n && (r.redirectedFrom = g(n, s)), Object.freeze(r);
    }
    function T(e) {
      if (Array.isArray(e)) return e.map(T);
      if (e && "object" == typeof e) {
        var t = {};
        for (var n in e) t[n] = T(e[n]);
        return t;
      }
      return e;
    }
    var f = c(null, { path: "/" });
    function b(e) {
      for (var t = []; e; ) t.unshift(e), (e = e.parent);
      return t;
    }
    function g(e, t) {
      var n = e.path,
        a = e.query;
      void 0 === a && (a = {});
      var s = e.hash;
      return void 0 === s && (s = ""), (n || "/") + (t || y)(a) + s;
    }
    function v(e, t, n) {
      return t === f
        ? e === t
        : !!t &&
            (e.path && t.path
              ? e.path.replace(m, "") === t.path.replace(m, "") && (n || (e.hash === t.hash && h(e.query, t.query)))
              : !(!e.name || !t.name) &&
                e.name === t.name &&
                (n || (e.hash === t.hash && h(e.query, t.query) && h(e.params, t.params))));
    }
    function h(e, t) {
      if ((void 0 === e && (e = {}), void 0 === t && (t = {}), !e || !t)) return e === t;
      var n = Object.keys(e).sort(),
        a = Object.keys(t).sort();
      return (
        n.length === a.length &&
        n.every(function (n, s) {
          var i = e[n];
          if (a[s] !== n) return !1;
          var r = t[n];
          return null == i || null == r
            ? i === r
            : "object" == typeof i && "object" == typeof r
            ? h(i, r)
            : String(i) === String(r);
        })
      );
    }
    function _(e) {
      for (var t = 0; t < e.matched.length; t++) {
        var n = e.matched[t];
        for (var a in n.instances) {
          var s = n.instances[a],
            i = n.enteredCbs[a];
          if (s && i) {
            delete n.enteredCbs[a];
            for (var r = 0; r < i.length; r++) s._isBeingDestroyed || i[r](s);
          }
        }
      }
    }
    var w = {
      name: "RouterView",
      functional: !0,
      props: { name: { type: String, default: "default" } },
      render: function (e, t) {
        var n = t.props,
          a = t.children,
          i = t.parent,
          r = t.data;
        r.routerView = !0;
        for (
          var o = i.$createElement,
            d = n.name,
            p = i.$route,
            u = i._routerViewCache || (i._routerViewCache = {}),
            l = 0,
            y = !1;
          i && i._routerRoot !== i;

        ) {
          var m = i.$vnode ? i.$vnode.data : {};
          m.routerView && l++, m.keepAlive && i._directInactive && i._inactive && (y = !0), (i = i.$parent);
        }
        if (((r.routerViewDepth = l), y)) {
          var c = u[d],
            T = c && c.component;
          return T ? (c.configProps && k(T, r, c.route, c.configProps), o(T, r, a)) : o();
        }
        var f = p.matched[l],
          b = f && f.components[d];
        if (!f || !b) return (u[d] = null), o();
        (u[d] = { component: b }),
          (r.registerRouteInstance = function (e, t) {
            var n = f.instances[d];
            ((t && n !== e) || (!t && n === e)) && (f.instances[d] = t);
          }),
          ((r.hook || (r.hook = {})).prepatch = function (e, t) {
            f.instances[d] = t.componentInstance;
          }),
          (r.hook.init = function (e) {
            e.data.keepAlive &&
              e.componentInstance &&
              e.componentInstance !== f.instances[d] &&
              (f.instances[d] = e.componentInstance),
              _(p);
          });
        var g = f.props && f.props[d];
        return g && (s(u[d], { route: p, configProps: g }), k(b, r, p, g)), o(b, r, a);
      },
    };
    function k(e, t, n, a) {
      var i = (t.props = (function (e, t) {
        switch (typeof t) {
          case "undefined":
            return;
          case "object":
            return t;
          case "function":
            return t(e);
          case "boolean":
            return t ? e.params : void 0;
          default:
            0;
        }
      })(n, a));
      if (i) {
        i = t.props = s({}, i);
        var r = (t.attrs = t.attrs || {});
        for (var o in i) (e.props && o in e.props) || ((r[o] = i[o]), delete i[o]);
      }
    }
    function P(e, t, n) {
      var a = e.charAt(0);
      if ("/" === a) return e;
      if ("?" === a || "#" === a) return t + e;
      var s = t.split("/");
      (n && s[s.length - 1]) || s.pop();
      for (var i = e.replace(/^\//, "").split("/"), r = 0; r < i.length; r++) {
        var o = i[r];
        ".." === o ? s.pop() : "." !== o && s.push(o);
      }
      return "" !== s[0] && s.unshift(""), s.join("/");
    }
    function M(e) {
      return e.replace(/\/\//g, "/");
    }
    var A =
        Array.isArray ||
        function (e) {
          return "[object Array]" == Object.prototype.toString.call(e);
        },
      S = $,
      C = I,
      R = function (e, t) {
        return E(I(e, t), t);
      },
      D = E,
      x = H,
      O = new RegExp(
        [
          "(\\\\.)",
          "([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))",
        ].join("|"),
        "g",
      );
    function I(e, t) {
      for (var n, a = [], s = 0, i = 0, r = "", o = (t && t.delimiter) || "/"; null != (n = O.exec(e)); ) {
        var d = n[0],
          p = n[1],
          u = n.index;
        if (((r += e.slice(i, u)), (i = u + d.length), p)) r += p[1];
        else {
          var l = e[i],
            y = n[2],
            m = n[3],
            c = n[4],
            T = n[5],
            f = n[6],
            b = n[7];
          r && (a.push(r), (r = ""));
          var g = null != y && null != l && l !== y,
            v = "+" === f || "*" === f,
            h = "?" === f || "*" === f,
            _ = n[2] || o,
            w = c || T;
          a.push({
            name: m || s++,
            prefix: y || "",
            delimiter: _,
            optional: h,
            repeat: v,
            partial: g,
            asterisk: !!b,
            pattern: w ? V(w) : b ? ".*" : "[^" + q(_) + "]+?",
          });
        }
      }
      return i < e.length && (r += e.substr(i)), r && a.push(r), a;
    }
    function L(e) {
      return encodeURI(e).replace(/[\/?#]/g, function (e) {
        return "%" + e.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function E(e, t) {
      for (var n = new Array(e.length), a = 0; a < e.length; a++)
        "object" == typeof e[a] && (n[a] = new RegExp("^(?:" + e[a].pattern + ")$", B(t)));
      return function (t, a) {
        for (var s = "", i = t || {}, r = (a || {}).pretty ? L : encodeURIComponent, o = 0; o < e.length; o++) {
          var d = e[o];
          if ("string" != typeof d) {
            var p,
              u = i[d.name];
            if (null == u) {
              if (d.optional) {
                d.partial && (s += d.prefix);
                continue;
              }
              throw new TypeError('Expected "' + d.name + '" to be defined');
            }
            if (A(u)) {
              if (!d.repeat)
                throw new TypeError(
                  'Expected "' + d.name + '" to not repeat, but received `' + JSON.stringify(u) + "`",
                );
              if (0 === u.length) {
                if (d.optional) continue;
                throw new TypeError('Expected "' + d.name + '" to not be empty');
              }
              for (var l = 0; l < u.length; l++) {
                if (((p = r(u[l])), !n[o].test(p)))
                  throw new TypeError(
                    'Expected all "' +
                      d.name +
                      '" to match "' +
                      d.pattern +
                      '", but received `' +
                      JSON.stringify(p) +
                      "`",
                  );
                s += (0 === l ? d.prefix : d.delimiter) + p;
              }
            } else {
              if (
                ((p = d.asterisk
                  ? encodeURI(u).replace(/[?#]/g, function (e) {
                      return "%" + e.charCodeAt(0).toString(16).toUpperCase();
                    })
                  : r(u)),
                !n[o].test(p))
              )
                throw new TypeError('Expected "' + d.name + '" to match "' + d.pattern + '", but received "' + p + '"');
              s += d.prefix + p;
            }
          } else s += d;
        }
        return s;
      };
    }
    function q(e) {
      return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g, "\\$1");
    }
    function V(e) {
      return e.replace(/([=!:$\/()])/g, "\\$1");
    }
    function U(e, t) {
      return (e.keys = t), e;
    }
    function B(e) {
      return e && e.sensitive ? "" : "i";
    }
    function H(e, t, n) {
      A(t) || ((n = t || n), (t = []));
      for (var a = (n = n || {}).strict, s = !1 !== n.end, i = "", r = 0; r < e.length; r++) {
        var o = e[r];
        if ("string" == typeof o) i += q(o);
        else {
          var d = q(o.prefix),
            p = "(?:" + o.pattern + ")";
          t.push(o),
            o.repeat && (p += "(?:" + d + p + ")*"),
            (i += p = o.optional ? (o.partial ? d + "(" + p + ")?" : "(?:" + d + "(" + p + "))?") : d + "(" + p + ")");
        }
      }
      var u = q(n.delimiter || "/"),
        l = i.slice(-u.length) === u;
      return (
        a || (i = (l ? i.slice(0, -u.length) : i) + "(?:" + u + "(?=$))?"),
        (i += s ? "$" : a && l ? "" : "(?=" + u + "|$)"),
        U(new RegExp("^" + i, B(n)), t)
      );
    }
    function $(e, t, n) {
      return (
        A(t) || ((n = t || n), (t = [])),
        (n = n || {}),
        e instanceof RegExp
          ? (function (e, t) {
              var n = e.source.match(/\((?!\?)/g);
              if (n)
                for (var a = 0; a < n.length; a++)
                  t.push({
                    name: a,
                    prefix: null,
                    delimiter: null,
                    optional: !1,
                    repeat: !1,
                    partial: !1,
                    asterisk: !1,
                    pattern: null,
                  });
              return U(e, t);
            })(e, t)
          : A(e)
          ? (function (e, t, n) {
              for (var a = [], s = 0; s < e.length; s++) a.push($(e[s], t, n).source);
              return U(new RegExp("(?:" + a.join("|") + ")", B(n)), t);
            })(e, t, n)
          : (function (e, t, n) {
              return H(I(e, n), t, n);
            })(e, t, n)
      );
    }
    (S.parse = C), (S.compile = R), (S.tokensToFunction = D), (S.tokensToRegExp = x);
    var W = Object.create(null);
    function F(e, t, n) {
      t = t || {};
      try {
        var a = W[e] || (W[e] = S.compile(e));
        return "string" == typeof t.pathMatch && (t[0] = t.pathMatch), a(t, { pretty: !0 });
      } catch (e) {
        return "";
      } finally {
        delete t[0];
      }
    }
    function N(e, t, n, a) {
      var i = "string" == typeof e ? { path: e } : e;
      if (i._normalized) return i;
      if (i.name) {
        var r = (i = s({}, e)).params;
        return r && "object" == typeof r && (i.params = s({}, r)), i;
      }
      if (!i.path && i.params && t) {
        (i = s({}, i))._normalized = !0;
        var o = s(s({}, t.params), i.params);
        if (t.name) (i.name = t.name), (i.params = o);
        else if (t.matched.length) {
          var d = t.matched[t.matched.length - 1].path;
          i.path = F(d, o, t.path);
        } else 0;
        return i;
      }
      var p = (function (e) {
          var t = "",
            n = "",
            a = e.indexOf("#");
          a >= 0 && ((t = e.slice(a)), (e = e.slice(0, a)));
          var s = e.indexOf("?");
          return s >= 0 && ((n = e.slice(s + 1)), (e = e.slice(0, s))), { path: e, query: n, hash: t };
        })(i.path || ""),
        y = (t && t.path) || "/",
        m = p.path ? P(p.path, y, n || i.append) : y,
        c = (function (e, t, n) {
          void 0 === t && (t = {});
          var a,
            s = n || l;
          try {
            a = s(e || "");
          } catch (e) {
            a = {};
          }
          for (var i in t) {
            var r = t[i];
            a[i] = Array.isArray(r) ? r.map(u) : u(r);
          }
          return a;
        })(p.query, i.query, a && a.options.parseQuery),
        T = i.hash || p.hash;
      return T && "#" !== T.charAt(0) && (T = "#" + T), { _normalized: !0, path: m, query: c, hash: T };
    }
    var Y,
      j = function () {},
      z = {
        name: "RouterLink",
        props: {
          to: { type: [String, Object], required: !0 },
          tag: { type: String, default: "a" },
          custom: Boolean,
          exact: Boolean,
          exactPath: Boolean,
          append: Boolean,
          replace: Boolean,
          activeClass: String,
          exactActiveClass: String,
          ariaCurrentValue: { type: String, default: "page" },
          event: { type: [String, Array], default: "click" },
        },
        render: function (e) {
          var t = this,
            n = this.$router,
            a = this.$route,
            i = n.resolve(this.to, a, this.append),
            r = i.location,
            o = i.route,
            d = i.href,
            p = {},
            u = n.options.linkActiveClass,
            l = n.options.linkExactActiveClass,
            y = null == u ? "router-link-active" : u,
            T = null == l ? "router-link-exact-active" : l,
            f = null == this.activeClass ? y : this.activeClass,
            b = null == this.exactActiveClass ? T : this.exactActiveClass,
            g = o.redirectedFrom ? c(null, N(o.redirectedFrom), null, n) : o;
          (p[b] = v(a, g, this.exactPath)),
            (p[f] =
              this.exact || this.exactPath
                ? p[b]
                : (function (e, t) {
                    return (
                      0 === e.path.replace(m, "/").indexOf(t.path.replace(m, "/")) &&
                      (!t.hash || e.hash === t.hash) &&
                      (function (e, t) {
                        for (var n in t) if (!(n in e)) return !1;
                        return !0;
                      })(e.query, t.query)
                    );
                  })(a, g));
          var h = p[b] ? this.ariaCurrentValue : null,
            _ = function (e) {
              G(e) && (t.replace ? n.replace(r, j) : n.push(r, j));
            },
            w = { click: G };
          Array.isArray(this.event)
            ? this.event.forEach(function (e) {
                w[e] = _;
              })
            : (w[this.event] = _);
          var k = { class: p },
            P =
              !this.$scopedSlots.$hasNormal &&
              this.$scopedSlots.default &&
              this.$scopedSlots.default({ href: d, route: o, navigate: _, isActive: p[f], isExactActive: p[b] });
          if (P) {
            if (1 === P.length) return P[0];
            if (P.length > 1 || !P.length) return 0 === P.length ? e() : e("span", {}, P);
          }
          if ("a" === this.tag) (k.on = w), (k.attrs = { href: d, "aria-current": h });
          else {
            var M = (function e(t) {
              var n;
              if (t)
                for (var a = 0; a < t.length; a++) {
                  if ("a" === (n = t[a]).tag) return n;
                  if (n.children && (n = e(n.children))) return n;
                }
            })(this.$slots.default);
            if (M) {
              M.isStatic = !1;
              var A = (M.data = s({}, M.data));
              for (var S in ((A.on = A.on || {}), A.on)) {
                var C = A.on[S];
                S in w && (A.on[S] = Array.isArray(C) ? C : [C]);
              }
              for (var R in w) R in A.on ? A.on[R].push(w[R]) : (A.on[R] = _);
              var D = (M.data.attrs = s({}, M.data.attrs));
              (D.href = d), (D["aria-current"] = h);
            } else k.on = w;
          }
          return e(this.tag, k, this.$slots.default);
        },
      };
    function G(e) {
      if (
        !(
          e.metaKey ||
          e.altKey ||
          e.ctrlKey ||
          e.shiftKey ||
          e.defaultPrevented ||
          (void 0 !== e.button && 0 !== e.button)
        )
      ) {
        if (e.currentTarget && e.currentTarget.getAttribute) {
          var t = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(t)) return;
        }
        return e.preventDefault && e.preventDefault(), !0;
      }
    }
    var K = "undefined" != typeof window;
    function J(e, t, n, a, s) {
      var i = t || [],
        r = n || Object.create(null),
        o = a || Object.create(null);
      e.forEach(function (e) {
        !(function e(t, n, a, s, i, r) {
          var o = s.path,
            d = s.name;
          0;
          var p = s.pathToRegexpOptions || {},
            u = (function (e, t, n) {
              n || (e = e.replace(/\/$/, ""));
              if ("/" === e[0]) return e;
              if (null == t) return e;
              return M(t.path + "/" + e);
            })(o, i, p.strict);
          "boolean" == typeof s.caseSensitive && (p.sensitive = s.caseSensitive);
          var l = {
            path: u,
            regex: X(u, p),
            components: s.components || { default: s.component },
            alias: s.alias ? ("string" == typeof s.alias ? [s.alias] : s.alias) : [],
            instances: {},
            enteredCbs: {},
            name: d,
            parent: i,
            matchAs: r,
            redirect: s.redirect,
            beforeEnter: s.beforeEnter,
            meta: s.meta || {},
            props: null == s.props ? {} : s.components ? s.props : { default: s.props },
          };
          s.children &&
            s.children.forEach(function (s) {
              var i = r ? M(r + "/" + s.path) : void 0;
              e(t, n, a, s, l, i);
            });
          n[l.path] || (t.push(l.path), (n[l.path] = l));
          if (void 0 !== s.alias)
            for (var y = Array.isArray(s.alias) ? s.alias : [s.alias], m = 0; m < y.length; ++m) {
              0;
              var c = { path: y[m], children: s.children };
              e(t, n, a, c, i, l.path || "/");
            }
          d && (a[d] || (a[d] = l));
        })(i, r, o, e, s);
      });
      for (var d = 0, p = i.length; d < p; d++) "*" === i[d] && (i.push(i.splice(d, 1)[0]), p--, d--);
      return { pathList: i, pathMap: r, nameMap: o };
    }
    function X(e, t) {
      return S(e, [], t);
    }
    function Z(e, t) {
      var n = J(e),
        a = n.pathList,
        s = n.pathMap,
        i = n.nameMap;
      function r(e, n, r) {
        var o = N(e, n, !1, t),
          p = o.name;
        if (p) {
          var u = i[p];
          if (!u) return d(null, o);
          var l = u.regex.keys
            .filter(function (e) {
              return !e.optional;
            })
            .map(function (e) {
              return e.name;
            });
          if (("object" != typeof o.params && (o.params = {}), n && "object" == typeof n.params))
            for (var y in n.params) !(y in o.params) && l.indexOf(y) > -1 && (o.params[y] = n.params[y]);
          return (o.path = F(u.path, o.params)), d(u, o, r);
        }
        if (o.path) {
          o.params = {};
          for (var m = 0; m < a.length; m++) {
            var c = a[m],
              T = s[c];
            if (Q(T.regex, o.path, o.params)) return d(T, o, r);
          }
        }
        return d(null, o);
      }
      function o(e, n) {
        var a = e.redirect,
          s = "function" == typeof a ? a(c(e, n, null, t)) : a;
        if (("string" == typeof s && (s = { path: s }), !s || "object" != typeof s)) return d(null, n);
        var o = s,
          p = o.name,
          u = o.path,
          l = n.query,
          y = n.hash,
          m = n.params;
        if (
          ((l = o.hasOwnProperty("query") ? o.query : l),
          (y = o.hasOwnProperty("hash") ? o.hash : y),
          (m = o.hasOwnProperty("params") ? o.params : m),
          p)
        ) {
          i[p];
          return r({ _normalized: !0, name: p, query: l, hash: y, params: m }, void 0, n);
        }
        if (u) {
          var T = (function (e, t) {
            return P(e, t.parent ? t.parent.path : "/", !0);
          })(u, e);
          return r({ _normalized: !0, path: F(T, m), query: l, hash: y }, void 0, n);
        }
        return d(null, n);
      }
      function d(e, n, a) {
        return e && e.redirect
          ? o(e, a || n)
          : e && e.matchAs
          ? (function (e, t, n) {
              var a = r({ _normalized: !0, path: F(n, t.params) });
              if (a) {
                var s = a.matched,
                  i = s[s.length - 1];
                return (t.params = a.params), d(i, t);
              }
              return d(null, t);
            })(0, n, e.matchAs)
          : c(e, n, a, t);
      }
      return {
        match: r,
        addRoute: function (e, t) {
          var n = "object" != typeof e ? i[e] : void 0;
          J([t || e], a, s, i, n),
            n &&
              J(
                n.alias.map(function (e) {
                  return { path: e, children: [t] };
                }),
                a,
                s,
                i,
                n,
              );
        },
        getRoutes: function () {
          return a.map(function (e) {
            return s[e];
          });
        },
        addRoutes: function (e) {
          J(e, a, s, i);
        },
      };
    }
    function Q(e, t, n) {
      var a = t.match(e);
      if (!a) return !1;
      if (!n) return !0;
      for (var s = 1, i = a.length; s < i; ++s) {
        var r = e.keys[s - 1];
        r && (n[r.name || "pathMatch"] = "string" == typeof a[s] ? p(a[s]) : a[s]);
      }
      return !0;
    }
    var ee = K && window.performance && window.performance.now ? window.performance : Date;
    function te() {
      return ee.now().toFixed(3);
    }
    var ne = te();
    function ae() {
      return ne;
    }
    function se(e) {
      return (ne = e);
    }
    var ie = Object.create(null);
    function re() {
      "scrollRestoration" in window.history && (window.history.scrollRestoration = "manual");
      var e = window.location.protocol + "//" + window.location.host,
        t = window.location.href.replace(e, ""),
        n = s({}, window.history.state);
      return (
        (n.key = ae()),
        window.history.replaceState(n, "", t),
        window.addEventListener("popstate", pe),
        function () {
          window.removeEventListener("popstate", pe);
        }
      );
    }
    function oe(e, t, n, a) {
      if (e.app) {
        var s = e.options.scrollBehavior;
        s &&
          e.app.$nextTick(function () {
            var i = (function () {
                var e = ae();
                if (e) return ie[e];
              })(),
              r = s.call(e, t, n, a ? i : null);
            r &&
              ("function" == typeof r.then
                ? r
                    .then(function (e) {
                      ce(e, i);
                    })
                    .catch(function (e) {
                      0;
                    })
                : ce(r, i));
          });
      }
    }
    function de() {
      var e = ae();
      e && (ie[e] = { x: window.pageXOffset, y: window.pageYOffset });
    }
    function pe(e) {
      de(), e.state && e.state.key && se(e.state.key);
    }
    function ue(e) {
      return ye(e.x) || ye(e.y);
    }
    function le(e) {
      return { x: ye(e.x) ? e.x : window.pageXOffset, y: ye(e.y) ? e.y : window.pageYOffset };
    }
    function ye(e) {
      return "number" == typeof e;
    }
    var me = /^#\d/;
    function ce(e, t) {
      var n,
        a = "object" == typeof e;
      if (a && "string" == typeof e.selector) {
        var s = me.test(e.selector) ? document.getElementById(e.selector.slice(1)) : document.querySelector(e.selector);
        if (s) {
          var i = e.offset && "object" == typeof e.offset ? e.offset : {};
          t = (function (e, t) {
            var n = document.documentElement.getBoundingClientRect(),
              a = e.getBoundingClientRect();
            return { x: a.left - n.left - t.x, y: a.top - n.top - t.y };
          })(s, (i = { x: ye((n = i).x) ? n.x : 0, y: ye(n.y) ? n.y : 0 }));
        } else ue(e) && (t = le(e));
      } else a && ue(e) && (t = le(e));
      t &&
        ("scrollBehavior" in document.documentElement.style
          ? window.scrollTo({ left: t.x, top: t.y, behavior: e.behavior })
          : window.scrollTo(t.x, t.y));
    }
    var Te,
      fe =
        K &&
        ((-1 === (Te = window.navigator.userAgent).indexOf("Android 2.") && -1 === Te.indexOf("Android 4.0")) ||
          -1 === Te.indexOf("Mobile Safari") ||
          -1 !== Te.indexOf("Chrome") ||
          -1 !== Te.indexOf("Windows Phone")) &&
        window.history &&
        "function" == typeof window.history.pushState;
    function be(e, t) {
      de();
      var n = window.history;
      try {
        if (t) {
          var a = s({}, n.state);
          (a.key = ae()), n.replaceState(a, "", e);
        } else n.pushState({ key: se(te()) }, "", e);
      } catch (n) {
        window.location[t ? "replace" : "assign"](e);
      }
    }
    function ge(e) {
      be(e, !0);
    }
    function ve(e, t, n) {
      var a = function (s) {
        s >= e.length
          ? n()
          : e[s]
          ? t(e[s], function () {
              a(s + 1);
            })
          : a(s + 1);
      };
      a(0);
    }
    var he = { redirected: 2, aborted: 4, cancelled: 8, duplicated: 16 };
    function _e(e, t) {
      return ke(
        e,
        t,
        he.redirected,
        'Redirected when going from "' +
          e.fullPath +
          '" to "' +
          (function (e) {
            if ("string" == typeof e) return e;
            if ("path" in e) return e.path;
            var t = {};
            return (
              Pe.forEach(function (n) {
                n in e && (t[n] = e[n]);
              }),
              JSON.stringify(t, null, 2)
            );
          })(t) +
          '" via a navigation guard.',
      );
    }
    function we(e, t) {
      return ke(
        e,
        t,
        he.cancelled,
        'Navigation cancelled from "' + e.fullPath + '" to "' + t.fullPath + '" with a new navigation.',
      );
    }
    function ke(e, t, n, a) {
      var s = new Error(a);
      return (s._isRouter = !0), (s.from = e), (s.to = t), (s.type = n), s;
    }
    var Pe = ["params", "query", "hash"];
    function Me(e) {
      return Object.prototype.toString.call(e).indexOf("Error") > -1;
    }
    function Ae(e, t) {
      return Me(e) && e._isRouter && (null == t || e.type === t);
    }
    function Se(e) {
      return function (t, n, a) {
        var s = !1,
          i = 0,
          r = null;
        Ce(e, function (e, t, n, o) {
          if ("function" == typeof e && void 0 === e.cid) {
            (s = !0), i++;
            var d,
              p = xe(function (t) {
                var s;
                ((s = t).__esModule || (De && "Module" === s[Symbol.toStringTag])) && (t = t.default),
                  (e.resolved = "function" == typeof t ? t : Y.extend(t)),
                  (n.components[o] = t),
                  --i <= 0 && a();
              }),
              u = xe(function (e) {
                var t = "Failed to resolve async component " + o + ": " + e;
                r || ((r = Me(e) ? e : new Error(t)), a(r));
              });
            try {
              d = e(p, u);
            } catch (e) {
              u(e);
            }
            if (d)
              if ("function" == typeof d.then) d.then(p, u);
              else {
                var l = d.component;
                l && "function" == typeof l.then && l.then(p, u);
              }
          }
        }),
          s || a();
      };
    }
    function Ce(e, t) {
      return Re(
        e.map(function (e) {
          return Object.keys(e.components).map(function (n) {
            return t(e.components[n], e.instances[n], e, n);
          });
        }),
      );
    }
    function Re(e) {
      return Array.prototype.concat.apply([], e);
    }
    var De = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag;
    function xe(e) {
      var t = !1;
      return function () {
        for (var n = [], a = arguments.length; a--; ) n[a] = arguments[a];
        if (!t) return (t = !0), e.apply(this, n);
      };
    }
    var Oe = function (e, t) {
      (this.router = e),
        (this.base = (function (e) {
          if (!e)
            if (K) {
              var t = document.querySelector("base");
              e = (e = (t && t.getAttribute("href")) || "/").replace(/^https?:\/\/[^\/]+/, "");
            } else e = "/";
          "/" !== e.charAt(0) && (e = "/" + e);
          return e.replace(/\/$/, "");
        })(t)),
        (this.current = f),
        (this.pending = null),
        (this.ready = !1),
        (this.readyCbs = []),
        (this.readyErrorCbs = []),
        (this.errorCbs = []),
        (this.listeners = []);
    };
    function Ie(e, t, n, a) {
      var s = Ce(e, function (e, a, s, i) {
        var r = (function (e, t) {
          "function" != typeof e && (e = Y.extend(e));
          return e.options[t];
        })(e, t);
        if (r)
          return Array.isArray(r)
            ? r.map(function (e) {
                return n(e, a, s, i);
              })
            : n(r, a, s, i);
      });
      return Re(a ? s.reverse() : s);
    }
    function Le(e, t) {
      if (t)
        return function () {
          return e.apply(t, arguments);
        };
    }
    (Oe.prototype.listen = function (e) {
      this.cb = e;
    }),
      (Oe.prototype.onReady = function (e, t) {
        this.ready ? e() : (this.readyCbs.push(e), t && this.readyErrorCbs.push(t));
      }),
      (Oe.prototype.onError = function (e) {
        this.errorCbs.push(e);
      }),
      (Oe.prototype.transitionTo = function (e, t, n) {
        var a,
          s = this;
        try {
          a = this.router.match(e, this.current);
        } catch (e) {
          throw (
            (this.errorCbs.forEach(function (t) {
              t(e);
            }),
            e)
          );
        }
        var i = this.current;
        this.confirmTransition(
          a,
          function () {
            s.updateRoute(a),
              t && t(a),
              s.ensureURL(),
              s.router.afterHooks.forEach(function (e) {
                e && e(a, i);
              }),
              s.ready ||
                ((s.ready = !0),
                s.readyCbs.forEach(function (e) {
                  e(a);
                }));
          },
          function (e) {
            n && n(e),
              e &&
                !s.ready &&
                ((Ae(e, he.redirected) && i === f) ||
                  ((s.ready = !0),
                  s.readyErrorCbs.forEach(function (t) {
                    t(e);
                  })));
          },
        );
      }),
      (Oe.prototype.confirmTransition = function (e, t, n) {
        var a = this,
          s = this.current;
        this.pending = e;
        var i,
          r,
          o = function (e) {
            !Ae(e) &&
              Me(e) &&
              (a.errorCbs.length
                ? a.errorCbs.forEach(function (t) {
                    t(e);
                  })
                : console.error(e)),
              n && n(e);
          },
          d = e.matched.length - 1,
          p = s.matched.length - 1;
        if (v(e, s) && d === p && e.matched[d] === s.matched[p])
          return (
            this.ensureURL(),
            o(
              (((r = ke(
                (i = s),
                e,
                he.duplicated,
                'Avoided redundant navigation to current location: "' + i.fullPath + '".',
              )).name = "NavigationDuplicated"),
              r),
            )
          );
        var u = (function (e, t) {
            var n,
              a = Math.max(e.length, t.length);
            for (n = 0; n < a && e[n] === t[n]; n++);
            return { updated: t.slice(0, n), activated: t.slice(n), deactivated: e.slice(n) };
          })(this.current.matched, e.matched),
          l = u.updated,
          y = u.deactivated,
          m = u.activated,
          c = [].concat(
            (function (e) {
              return Ie(e, "beforeRouteLeave", Le, !0);
            })(y),
            this.router.beforeHooks,
            (function (e) {
              return Ie(e, "beforeRouteUpdate", Le);
            })(l),
            m.map(function (e) {
              return e.beforeEnter;
            }),
            Se(m),
          ),
          T = function (t, n) {
            if (a.pending !== e) return o(we(s, e));
            try {
              t(e, s, function (t) {
                !1 === t
                  ? (a.ensureURL(!0),
                    o(
                      (function (e, t) {
                        return ke(
                          e,
                          t,
                          he.aborted,
                          'Navigation aborted from "' +
                            e.fullPath +
                            '" to "' +
                            t.fullPath +
                            '" via a navigation guard.',
                        );
                      })(s, e),
                    ))
                  : Me(t)
                  ? (a.ensureURL(!0), o(t))
                  : "string" == typeof t ||
                    ("object" == typeof t && ("string" == typeof t.path || "string" == typeof t.name))
                  ? (o(_e(s, e)), "object" == typeof t && t.replace ? a.replace(t) : a.push(t))
                  : n(t);
              });
            } catch (e) {
              o(e);
            }
          };
        ve(c, T, function () {
          ve(
            (function (e) {
              return Ie(e, "beforeRouteEnter", function (e, t, n, a) {
                return (function (e, t, n) {
                  return function (a, s, i) {
                    return e(a, s, function (e) {
                      "function" == typeof e && (t.enteredCbs[n] || (t.enteredCbs[n] = []), t.enteredCbs[n].push(e)),
                        i(e);
                    });
                  };
                })(e, n, a);
              });
            })(m).concat(a.router.resolveHooks),
            T,
            function () {
              if (a.pending !== e) return o(we(s, e));
              (a.pending = null),
                t(e),
                a.router.app &&
                  a.router.app.$nextTick(function () {
                    _(e);
                  });
            },
          );
        });
      }),
      (Oe.prototype.updateRoute = function (e) {
        (this.current = e), this.cb && this.cb(e);
      }),
      (Oe.prototype.setupListeners = function () {}),
      (Oe.prototype.teardown = function () {
        this.listeners.forEach(function (e) {
          e();
        }),
          (this.listeners = []),
          (this.current = f),
          (this.pending = null);
      });
    var Ee = (function (e) {
      function t(t, n) {
        e.call(this, t, n), (this._startLocation = qe(this.base));
      }
      return (
        e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.setupListeners = function () {
          var e = this;
          if (!(this.listeners.length > 0)) {
            var t = this.router,
              n = t.options.scrollBehavior,
              a = fe && n;
            a && this.listeners.push(re());
            var s = function () {
              var n = e.current,
                s = qe(e.base);
              (e.current === f && s === e._startLocation) ||
                e.transitionTo(s, function (e) {
                  a && oe(t, e, n, !0);
                });
            };
            window.addEventListener("popstate", s),
              this.listeners.push(function () {
                window.removeEventListener("popstate", s);
              });
          }
        }),
        (t.prototype.go = function (e) {
          window.history.go(e);
        }),
        (t.prototype.push = function (e, t, n) {
          var a = this,
            s = this.current;
          this.transitionTo(
            e,
            function (e) {
              be(M(a.base + e.fullPath)), oe(a.router, e, s, !1), t && t(e);
            },
            n,
          );
        }),
        (t.prototype.replace = function (e, t, n) {
          var a = this,
            s = this.current;
          this.transitionTo(
            e,
            function (e) {
              ge(M(a.base + e.fullPath)), oe(a.router, e, s, !1), t && t(e);
            },
            n,
          );
        }),
        (t.prototype.ensureURL = function (e) {
          if (qe(this.base) !== this.current.fullPath) {
            var t = M(this.base + this.current.fullPath);
            e ? be(t) : ge(t);
          }
        }),
        (t.prototype.getCurrentLocation = function () {
          return qe(this.base);
        }),
        t
      );
    })(Oe);
    function qe(e) {
      var t = window.location.pathname;
      return (
        e && 0 === t.toLowerCase().indexOf(e.toLowerCase()) && (t = t.slice(e.length)),
        (t || "/") + window.location.search + window.location.hash
      );
    }
    var Ve = (function (e) {
      function t(t, n, a) {
        e.call(this, t, n),
          (a &&
            (function (e) {
              var t = qe(e);
              if (!/^\/#/.test(t)) return window.location.replace(M(e + "/#" + t)), !0;
            })(this.base)) ||
            Ue();
      }
      return (
        e && (t.__proto__ = e),
        (t.prototype = Object.create(e && e.prototype)),
        (t.prototype.constructor = t),
        (t.prototype.setupListeners = function () {
          var e = this;
          if (!(this.listeners.length > 0)) {
            var t = this.router.options.scrollBehavior,
              n = fe && t;
            n && this.listeners.push(re());
            var a = function () {
                var t = e.current;
                Ue() &&
                  e.transitionTo(Be(), function (a) {
                    n && oe(e.router, a, t, !0), fe || We(a.fullPath);
                  });
              },
              s = fe ? "popstate" : "hashchange";
            window.addEventListener(s, a),
              this.listeners.push(function () {
                window.removeEventListener(s, a);
              });
          }
        }),
        (t.prototype.push = function (e, t, n) {
          var a = this,
            s = this.current;
          this.transitionTo(
            e,
            function (e) {
              $e(e.fullPath), oe(a.router, e, s, !1), t && t(e);
            },
            n,
          );
        }),
        (t.prototype.replace = function (e, t, n) {
          var a = this,
            s = this.current;
          this.transitionTo(
            e,
            function (e) {
              We(e.fullPath), oe(a.router, e, s, !1), t && t(e);
            },
            n,
          );
        }),
        (t.prototype.go = function (e) {
          window.history.go(e);
        }),
        (t.prototype.ensureURL = function (e) {
          var t = this.current.fullPath;
          Be() !== t && (e ? $e(t) : We(t));
        }),
        (t.prototype.getCurrentLocation = function () {
          return Be();
        }),
        t
      );
    })(Oe);
    function Ue() {
      var e = Be();
      return "/" === e.charAt(0) || (We("/" + e), !1);
    }
    function Be() {
      var e = window.location.href,
        t = e.indexOf("#");
      return t < 0 ? "" : (e = e.slice(t + 1));
    }
    function He(e) {
      var t = window.location.href,
        n = t.indexOf("#");
      return (n >= 0 ? t.slice(0, n) : t) + "#" + e;
    }
    function $e(e) {
      fe ? be(He(e)) : (window.location.hash = e);
    }
    function We(e) {
      fe ? ge(He(e)) : window.location.replace(He(e));
    }
    var Fe = (function (e) {
        function t(t, n) {
          e.call(this, t, n), (this.stack = []), (this.index = -1);
        }
        return (
          e && (t.__proto__ = e),
          (t.prototype = Object.create(e && e.prototype)),
          (t.prototype.constructor = t),
          (t.prototype.push = function (e, t, n) {
            var a = this;
            this.transitionTo(
              e,
              function (e) {
                (a.stack = a.stack.slice(0, a.index + 1).concat(e)), a.index++, t && t(e);
              },
              n,
            );
          }),
          (t.prototype.replace = function (e, t, n) {
            var a = this;
            this.transitionTo(
              e,
              function (e) {
                (a.stack = a.stack.slice(0, a.index).concat(e)), t && t(e);
              },
              n,
            );
          }),
          (t.prototype.go = function (e) {
            var t = this,
              n = this.index + e;
            if (!(n < 0 || n >= this.stack.length)) {
              var a = this.stack[n];
              this.confirmTransition(
                a,
                function () {
                  var e = t.current;
                  (t.index = n),
                    t.updateRoute(a),
                    t.router.afterHooks.forEach(function (t) {
                      t && t(a, e);
                    });
                },
                function (e) {
                  Ae(e, he.duplicated) && (t.index = n);
                },
              );
            }
          }),
          (t.prototype.getCurrentLocation = function () {
            var e = this.stack[this.stack.length - 1];
            return e ? e.fullPath : "/";
          }),
          (t.prototype.ensureURL = function () {}),
          t
        );
      })(Oe),
      Ne = function (e) {
        void 0 === e && (e = {}),
          (this.app = null),
          (this.apps = []),
          (this.options = e),
          (this.beforeHooks = []),
          (this.resolveHooks = []),
          (this.afterHooks = []),
          (this.matcher = Z(e.routes || [], this));
        var t = e.mode || "hash";
        switch (
          ((this.fallback = "history" === t && !fe && !1 !== e.fallback),
          this.fallback && (t = "hash"),
          K || (t = "abstract"),
          (this.mode = t),
          t)
        ) {
          case "history":
            this.history = new Ee(this, e.base);
            break;
          case "hash":
            this.history = new Ve(this, e.base, this.fallback);
            break;
          case "abstract":
            this.history = new Fe(this, e.base);
            break;
          default:
            0;
        }
      },
      Ye = { currentRoute: { configurable: !0 } };
    function je(e, t) {
      return (
        e.push(t),
        function () {
          var n = e.indexOf(t);
          n > -1 && e.splice(n, 1);
        }
      );
    }
    (Ne.prototype.match = function (e, t, n) {
      return this.matcher.match(e, t, n);
    }),
      (Ye.currentRoute.get = function () {
        return this.history && this.history.current;
      }),
      (Ne.prototype.init = function (e) {
        var t = this;
        if (
          (this.apps.push(e),
          e.$once("hook:destroyed", function () {
            var n = t.apps.indexOf(e);
            n > -1 && t.apps.splice(n, 1), t.app === e && (t.app = t.apps[0] || null), t.app || t.history.teardown();
          }),
          !this.app)
        ) {
          this.app = e;
          var n = this.history;
          if (n instanceof Ee || n instanceof Ve) {
            var a = function (e) {
              n.setupListeners(),
                (function (e) {
                  var a = n.current,
                    s = t.options.scrollBehavior;
                  fe && s && "fullPath" in e && oe(t, e, a, !1);
                })(e);
            };
            n.transitionTo(n.getCurrentLocation(), a, a);
          }
          n.listen(function (e) {
            t.apps.forEach(function (t) {
              t._route = e;
            });
          });
        }
      }),
      (Ne.prototype.beforeEach = function (e) {
        return je(this.beforeHooks, e);
      }),
      (Ne.prototype.beforeResolve = function (e) {
        return je(this.resolveHooks, e);
      }),
      (Ne.prototype.afterEach = function (e) {
        return je(this.afterHooks, e);
      }),
      (Ne.prototype.onReady = function (e, t) {
        this.history.onReady(e, t);
      }),
      (Ne.prototype.onError = function (e) {
        this.history.onError(e);
      }),
      (Ne.prototype.push = function (e, t, n) {
        var a = this;
        if (!t && !n && "undefined" != typeof Promise)
          return new Promise(function (t, n) {
            a.history.push(e, t, n);
          });
        this.history.push(e, t, n);
      }),
      (Ne.prototype.replace = function (e, t, n) {
        var a = this;
        if (!t && !n && "undefined" != typeof Promise)
          return new Promise(function (t, n) {
            a.history.replace(e, t, n);
          });
        this.history.replace(e, t, n);
      }),
      (Ne.prototype.go = function (e) {
        this.history.go(e);
      }),
      (Ne.prototype.back = function () {
        this.go(-1);
      }),
      (Ne.prototype.forward = function () {
        this.go(1);
      }),
      (Ne.prototype.getMatchedComponents = function (e) {
        var t = e ? (e.matched ? e : this.resolve(e).route) : this.currentRoute;
        return t
          ? [].concat.apply(
              [],
              t.matched.map(function (e) {
                return Object.keys(e.components).map(function (t) {
                  return e.components[t];
                });
              }),
            )
          : [];
      }),
      (Ne.prototype.resolve = function (e, t, n) {
        var a = N(e, (t = t || this.history.current), n, this),
          s = this.match(a, t),
          i = s.redirectedFrom || s.fullPath;
        return {
          location: a,
          route: s,
          href: (function (e, t, n) {
            var a = "hash" === n ? "#" + t : t;
            return e ? M(e + "/" + a) : a;
          })(this.history.base, i, this.mode),
          normalizedTo: a,
          resolved: s,
        };
      }),
      (Ne.prototype.getRoutes = function () {
        return this.matcher.getRoutes();
      }),
      (Ne.prototype.addRoute = function (e, t) {
        this.matcher.addRoute(e, t),
          this.history.current !== f && this.history.transitionTo(this.history.getCurrentLocation());
      }),
      (Ne.prototype.addRoutes = function (e) {
        this.matcher.addRoutes(e),
          this.history.current !== f && this.history.transitionTo(this.history.getCurrentLocation());
      }),
      Object.defineProperties(Ne.prototype, Ye),
      (Ne.install = function e(t) {
        if (!e.installed || Y !== t) {
          (e.installed = !0), (Y = t);
          var n = function (e) {
              return void 0 !== e;
            },
            a = function (e, t) {
              var a = e.$options._parentVnode;
              n(a) && n((a = a.data)) && n((a = a.registerRouteInstance)) && a(e, t);
            };
          t.mixin({
            beforeCreate: function () {
              n(this.$options.router)
                ? ((this._routerRoot = this),
                  (this._router = this.$options.router),
                  this._router.init(this),
                  t.util.defineReactive(this, "_route", this._router.history.current))
                : (this._routerRoot = (this.$parent && this.$parent._routerRoot) || this),
                a(this, this);
            },
            destroyed: function () {
              a(this);
            },
          }),
            Object.defineProperty(t.prototype, "$router", {
              get: function () {
                return this._routerRoot._router;
              },
            }),
            Object.defineProperty(t.prototype, "$route", {
              get: function () {
                return this._routerRoot._route;
              },
            }),
            t.component("RouterView", w),
            t.component("RouterLink", z);
          var s = t.config.optionMergeStrategies;
          s.beforeRouteEnter = s.beforeRouteLeave = s.beforeRouteUpdate = s.created;
        }
      }),
      (Ne.version = "3.5.1"),
      (Ne.isNavigationFailure = Ae),
      (Ne.NavigationFailureType = he),
      (Ne.START_LOCATION = f),
      K && window.Vue && window.Vue.use(Ne);
    var ze = Ne,
      Ge = function () {
        var e = this.$createElement,
          t = this._self._c || e;
        return t("div", { staticClass: "min-h-screen bg-gray-100 px-4 pt-6" }, [t("router-view")], 1);
      };
    Ge._withStripped = !0;
    n(4);
    function Ke(e, t, n, a, s, i, r, o) {
      var d,
        p = "function" == typeof e ? e.options : e;
      if (
        (t && ((p.render = t), (p.staticRenderFns = n), (p._compiled = !0)),
        a && (p.functional = !0),
        i && (p._scopeId = "data-v-" + i),
        r
          ? ((d = function (e) {
              (e =
                e ||
                (this.$vnode && this.$vnode.ssrContext) ||
                (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext)) ||
                "undefined" == typeof __VUE_SSR_CONTEXT__ ||
                (e = __VUE_SSR_CONTEXT__),
                s && s.call(this, e),
                e && e._registeredComponents && e._registeredComponents.add(r);
            }),
            (p._ssrRegister = d))
          : s &&
            (d = o
              ? function () {
                  s.call(this, (p.functional ? this.parent : this).$root.$options.shadowRoot);
                }
              : s),
        d)
      )
        if (p.functional) {
          p._injectStyles = d;
          var u = p.render;
          p.render = function (e, t) {
            return d.call(t), u(e, t);
          };
        } else {
          var l = p.beforeCreate;
          p.beforeCreate = l ? [].concat(l, d) : [d];
        }
      return { exports: e, options: p };
    }
    var Je = Ke({}, Ge, [], !1, null, null, null);
    Je.options.__file = "node_modules/hardhat-docgen/src/App.vue";
    var Xe = Je.exports,
      Ze = function () {
        var e = this,
          t = e.$createElement,
          n = e._self._c || t;
        return n(
          "div",
          { staticClass: "w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto" },
          [
            n("HeaderBar"),
            e._v(" "),
            n(
              "div",
              { staticClass: "pb-32" },
              [
                n("div", { staticClass: "space-y-4" }, [
                  n("span", { staticClass: "text-lg" }, [e._v("\n        " + e._s(e.json.source) + "\n      ")]),
                  e._v(" "),
                  n("h1", { staticClass: "text-xl" }, [e._v("\n        " + e._s(e.json.name) + "\n      ")]),
                  e._v(" "),
                  n("h2", { staticClass: "text-lg" }, [e._v("\n        " + e._s(e.json.title) + "\n      ")]),
                  e._v(" "),
                  n("h2", { staticClass: "text-lg" }, [e._v("\n        " + e._s(e.json.author) + "\n      ")]),
                  e._v(" "),
                  n("p", [e._v(e._s(e.json.notice))]),
                  e._v(" "),
                  n("p", [e._v(e._s(e.json.details))]),
                ]),
                e._v(" "),
                n(
                  "div",
                  { staticClass: "mt-8" },
                  [
                    e.json.hasOwnProperty("constructor")
                      ? n("Member", { attrs: { json: e.json.constructor } })
                      : e._e(),
                  ],
                  1,
                ),
                e._v(" "),
                n(
                  "div",
                  { staticClass: "mt-8" },
                  [e.json.receive ? n("Member", { attrs: { json: e.json.receive } }) : e._e()],
                  1,
                ),
                e._v(" "),
                n(
                  "div",
                  { staticClass: "mt-8" },
                  [e.json.fallback ? n("Member", { attrs: { json: e.json.fallback } }) : e._e()],
                  1,
                ),
                e._v(" "),
                e.json.events ? n("MemberSet", { attrs: { title: "Events", json: e.json.events } }) : e._e(),
                e._v(" "),
                e.json.stateVariables
                  ? n("MemberSet", { attrs: { title: "State Variables", json: e.json.stateVariables } })
                  : e._e(),
                e._v(" "),
                e.json.methods ? n("MemberSet", { attrs: { title: "Methods", json: e.json.methods } }) : e._e(),
              ],
              1,
            ),
            e._v(" "),
            n("FooterBar"),
          ],
          1,
        );
      };
    Ze._withStripped = !0;
    var Qe = function () {
      var e = this,
        t = e.$createElement,
        n = e._self._c || t;
      return n(
        "div",
        { staticClass: "bg-gray-100 fixed bottom-0 right-0 w-full border-t border-dashed border-gray-300" },
        [
          n("div", { staticClass: "w-full text-center py-2 md:max-w-screen-sm lg:max-w-screen-md mx-auto" }, [
            n(
              "button",
              {
                staticClass: "py-1 px-2 text-gray-500",
                on: {
                  click: function (t) {
                    return e.openLink(e.repository);
                  },
                },
              },
              [e._v("\n      built with " + e._s(e.name) + "\n    ")],
            ),
          ]),
        ],
      );
    };
    Qe._withStripped = !0;
    var et = n(2),
      tt = Ke(
        {
          data: function () {
            return { repository: et.b, name: et.a };
          },
          methods: {
            openLink(e) {
              window.open(e, "_blank");
            },
          },
        },
        Qe,
        [],
        !1,
        null,
        null,
        null,
      );
    tt.options.__file = "node_modules/hardhat-docgen/src/components/FooterBar.vue";
    var nt = tt.exports,
      at = function () {
        var e = this.$createElement,
          t = this._self._c || e;
        return t(
          "div",
          { staticClass: "w-full border-b border-dashed py-2 border-gray-300" },
          [
            t("router-link", { staticClass: "py-2 text-gray-500", attrs: { to: "/" } }, [
              this._v("\n    <- Go back\n  "),
            ]),
          ],
          1,
        );
      };
    at._withStripped = !0;
    var st = Ke({}, at, [], !1, null, null, null);
    st.options.__file = "node_modules/hardhat-docgen/src/components/HeaderBar.vue";
    var it = st.exports,
      rt = function () {
        var e = this,
          t = e.$createElement,
          n = e._self._c || t;
        return n("div", { staticClass: "border-2 border-gray-400 border-dashed w-full p-2" }, [
          n("h3", { staticClass: "text-lg pb-2 mb-2 border-b-2 border-gray-400 border-dashed" }, [
            e._v("\n    " + e._s(e.name) + " " + e._s(e.keywords) + " " + e._s(e.inputSignature) + "\n  "),
          ]),
          e._v(" "),
          n(
            "div",
            { staticClass: "space-y-3" },
            [
              n("p", [e._v(e._s(e.json.notice))]),
              e._v(" "),
              n("p", [e._v(e._s(e.json.details))]),
              e._v(" "),
              n("MemberSection", { attrs: { name: "Parameters", items: e.inputs } }),
              e._v(" "),
              n("MemberSection", { attrs: { name: "Return Values", items: e.outputs } }),
            ],
            1,
          ),
        ]);
      };
    rt._withStripped = !0;
    var ot = function () {
      var e = this,
        t = e.$createElement,
        n = e._self._c || t;
      return e.items.length > 0
        ? n(
            "ul",
            [
              n("h4", { staticClass: "text-lg" }, [e._v("\n    " + e._s(e.name) + "\n  ")]),
              e._v(" "),
              e._l(e.items, function (t, a) {
                return n("li", { key: a }, [
                  n("span", { staticClass: "bg-gray-300" }, [e._v(e._s(t.type))]),
                  e._v(" "),
                  n("b", [e._v(e._s(t.name || "_" + a))]),
                  t.desc ? n("span", [e._v(": "), n("i", [e._v(e._s(t.desc))])]) : e._e(),
                ]);
              }),
            ],
            2,
          )
        : e._e();
    };
    ot._withStripped = !0;
    var dt = Ke(
      { props: { name: { type: String, default: "" }, items: { type: Array, default: () => new Array() } } },
      ot,
      [],
      !1,
      null,
      null,
      null,
    );
    dt.options.__file = "node_modules/hardhat-docgen/src/components/MemberSection.vue";
    var pt = Ke(
      {
        components: { MemberSection: dt.exports },
        props: { json: { type: Object, default: () => new Object() } },
        computed: {
          name: function () {
            return this.json.name || this.json.type;
          },
          keywords: function () {
            let e = [];
            return (
              this.json.stateMutability && e.push(this.json.stateMutability),
              "true" === this.json.anonymous && e.push("anonymous"),
              e.join(" ")
            );
          },
          params: function () {
            return this.json.params || {};
          },
          returns: function () {
            return this.json.returns || {};
          },
          inputs: function () {
            return (this.json.inputs || []).map(e => ({ ...e, desc: this.params[e.name] }));
          },
          inputSignature: function () {
            return `(${this.inputs.map(e => e.type).join(",")})`;
          },
          outputs: function () {
            return (this.json.outputs || []).map((e, t) => ({ ...e, desc: this.returns[e.name || "_" + t] }));
          },
          outputSignature: function () {
            return `(${this.outputs.map(e => e.type).join(",")})`;
          },
        },
      },
      rt,
      [],
      !1,
      null,
      null,
      null,
    );
    pt.options.__file = "node_modules/hardhat-docgen/src/components/Member.vue";
    var ut = pt.exports,
      lt = function () {
        var e = this,
          t = e.$createElement,
          n = e._self._c || t;
        return n(
          "div",
          { staticClass: "w-full mt-8" },
          [
            n("h2", { staticClass: "text-lg" }, [e._v(e._s(e.title))]),
            e._v(" "),
            e._l(Object.keys(e.json), function (t) {
              return n("Member", { key: t, staticClass: "mt-3", attrs: { json: e.json[t] } });
            }),
          ],
          2,
        );
      };
    lt._withStripped = !0;
    var yt = Ke(
      {
        components: { Member: ut },
        props: { title: { type: String, default: "" }, json: { type: Object, default: () => new Object() } },
      },
      lt,
      [],
      !1,
      null,
      null,
      null,
    );
    yt.options.__file = "node_modules/hardhat-docgen/src/components/MemberSet.vue";
    var mt = Ke(
      {
        components: { Member: ut, MemberSet: yt.exports, HeaderBar: it, FooterBar: nt },
        props: { json: { type: Object, default: () => new Object() } },
      },
      Ze,
      [],
      !1,
      null,
      null,
      null,
    );
    mt.options.__file = "node_modules/hardhat-docgen/src/components/Contract.vue";
    var ct = mt.exports,
      Tt = function () {
        var e = this.$createElement,
          t = this._self._c || e;
        return t(
          "div",
          { staticClass: "w-full space-y-10 md:max-w-screen-sm lg:max-w-screen-md mx-auto pb-32" },
          [
            t("Branch", { attrs: { json: this.trees, name: "Sources:" } }),
            this._v(" "),
            t("FooterBar", { staticClass: "mt-20" }),
          ],
          1,
        );
      };
    Tt._withStripped = !0;
    var ft = function () {
      var e = this,
        t = e.$createElement,
        n = e._self._c || t;
      return n("div", [
        e._v("\n  " + e._s(e.name) + "\n  "),
        Array.isArray(e.json)
          ? n(
              "div",
              { staticClass: "pl-5" },
              e._l(e.json, function (t, a) {
                return n(
                  "div",
                  { key: a },
                  [
                    n("router-link", { attrs: { to: t.source + ":" + t.name } }, [
                      e._v("\n        " + e._s(t.name) + "\n      "),
                    ]),
                  ],
                  1,
                );
              }),
              0,
            )
          : n(
              "div",
              { staticClass: "pl-5" },
              e._l(Object.keys(e.json), function (t) {
                return n("div", { key: t }, [n("Branch", { attrs: { json: e.json[t], name: t } })], 1);
              }),
              0,
            ),
      ]);
    };
    ft._withStripped = !0;
    var bt = Ke(
      {
        name: "Branch",
        props: { name: { type: String, default: null }, json: { type: [Object, Array], default: () => new Object() } },
      },
      ft,
      [],
      !1,
      null,
      null,
      null,
    );
    bt.options.__file = "node_modules/hardhat-docgen/src/components/Branch.vue";
    var gt = Ke(
      {
        components: { Branch: bt.exports, FooterBar: nt },
        props: { json: { type: Object, default: () => new Object() } },
        computed: {
          trees: function () {
            let e = {};
            for (let t in this.json)
              t.split(/(?<=\/)/).reduce(
                function (e, n) {
                  if (!n.includes(":")) return (e[n] = e[n] || {}), e[n];
                  {
                    let [a] = n.split(":");
                    (e[a] = e[a] || []), e[a].push(this.json[t]);
                  }
                }.bind(this),
                e,
              );
            return e;
          },
        },
      },
      Tt,
      [],
      !1,
      null,
      null,
      null,
    );
    gt.options.__file = "node_modules/hardhat-docgen/src/components/Index.vue";
    var vt = gt.exports;
    a.a.use(ze);
    const ht = {
        "contracts/dependencies/chi/ChiDeployer.sol:Deployer": {
          source: "contracts/dependencies/chi/ChiDeployer.sol",
          name: "Deployer",
          methods: {
            "chi()": {
              inputs: [],
              name: "chi",
              outputs: [{ internalType: "contract IFreeFromUpTo", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "chiDeploy(bytes)": {
              inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
              name: "chiDeploy",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "chiDeploy2(uint256,bytes)": {
              inputs: [
                { internalType: "uint256", name: "salt", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "chiDeploy2",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "gst()": {
              inputs: [],
              name: "gst",
              outputs: [{ internalType: "contract IFreeFromUpTo", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "gstDeploy(bytes)": {
              inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
              name: "gstDeploy",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "gstDeploy2(uint256,bytes)": {
              inputs: [
                { internalType: "uint256", name: "salt", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "gstDeploy2",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/dependencies/chi/ChiDeployer.sol:IFreeFromUpTo": {
          source: "contracts/dependencies/chi/ChiDeployer.sol",
          name: "IFreeFromUpTo",
          methods: {
            "freeFromUpTo(address,uint256)": {
              inputs: [
                { internalType: "address", name: "from", type: "address" },
                { internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "freeFromUpTo",
              outputs: [{ internalType: "uint256", name: "freed", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/dependencies/compound/ExponentialNoError.sol:ExponentialNoError": {
          source: "contracts/dependencies/compound/ExponentialNoError.sol",
          name: "ExponentialNoError",
          title: "Exponential module for storing fixed-precision decimals",
          author: "Compound",
          notice:
            "Exp is a struct which stores decimals with a fixed precision of 18 decimal places.         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:         `Exp({mantissa: 5100000000000000000})`.",
        },
        "contracts/dependencies/openzeppelin/AddressUpgradeable.sol:AddressUpgradeable": {
          source: "contracts/dependencies/openzeppelin/AddressUpgradeable.sol",
          name: "AddressUpgradeable",
          details: "Collection of functions related to the address type",
        },
        "contracts/dependencies/openzeppelin/IERC20MetadataUpgradeable.sol:IERC20MetadataUpgradeable": {
          source: "contracts/dependencies/openzeppelin/IERC20MetadataUpgradeable.sol",
          name: "IERC20MetadataUpgradeable",
          details: "Interface for the optional metadata functions from the ERC20 standard.",
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens owned by `account`.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the decimals places of the token.",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens in existence.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
          },
        },
        "contracts/dependencies/openzeppelin/IERC20Upgradeable.sol:IERC20Upgradeable": {
          source: "contracts/dependencies/openzeppelin/IERC20Upgradeable.sol",
          name: "IERC20Upgradeable",
          details: "Interface of the ERC20 standard as defined in the EIP.",
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens owned by `account`.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens in existence.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
          },
        },
        "contracts/dependencies/openzeppelin/SafeERC20Upgradeable.sol:SafeERC20Upgradeable": {
          source: "contracts/dependencies/openzeppelin/SafeERC20Upgradeable.sol",
          name: "SafeERC20Upgradeable",
          title: "SafeERC20",
          details:
            "Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract, which allows you to call the safe operations as `token.safeTransfer(...)`, etc.",
        },
        "contracts/dependencies/openzeppelin/SafeMathUpgradeable.sol:SafeMathUpgradeable": {
          source: "contracts/dependencies/openzeppelin/SafeMathUpgradeable.sol",
          name: "SafeMathUpgradeable",
          details:
            "Wrappers over Solidity's arithmetic operations with added overflow checks. Arithmetic operations in Solidity wrap on overflow. This can easily result in bugs, because programmers usually assume that an overflow raises an error, which is the standard behavior in high level programming languages. `SafeMath` restores this intuition by reverting the transaction when an operation overflows. Using this library instead of the unchecked operations eliminates an entire class of bugs, so it's recommended to use it always.",
        },
        "contracts/dependencies/openzeppelin/VersionedInitializable.sol:VersionedInitializable": {
          source: "contracts/dependencies/openzeppelin/VersionedInitializable.sol",
          name: "VersionedInitializable",
          title: "VersionedInitializable",
          author: "Aave, inspired by the OpenZeppelin Initializable contract",
          details:
            "Helper contract to implement initializer functions. To use it, replace the constructor with a function that has the `initializer` modifier. WARNING: Unlike constructors, initializer functions must be manually invoked. This applies both to deploying an Initializable contract, as well as extending an Initializable contract via inheritance. WARNING: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or ensure that all initializers are idempotent, because this is not dealt with automatically as with constructors.",
        },
        "contracts/interfaces/aave/v1/IAaveV1.sol:IAaveV1": {
          source: "contracts/interfaces/aave/v1/IAaveV1.sol",
          name: "IAaveV1",
          methods: {
            "borrow(address,uint256,uint256,uint16)": {
              inputs: [
                { internalType: "address", name: "_reserve", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256", name: "_interestRateMode", type: "uint256" },
                { internalType: "uint16", name: "_referralCode", type: "uint16" },
              ],
              name: "borrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "deposit(address,uint256,uint16)": {
              inputs: [
                { internalType: "address", name: "_reserve", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint16", name: "_referralCode", type: "uint16" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getReserveConfigurationData(address)": {
              inputs: [{ internalType: "address", name: "_reserve", type: "address" }],
              name: "getReserveConfigurationData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "ltv", type: "uint256" },
                    { internalType: "uint256", name: "liquidationThreshold", type: "uint256" },
                    { internalType: "uint256", name: "liquidationBonus", type: "uint256" },
                    { internalType: "address", name: "rateStrategyAddress", type: "address" },
                    { internalType: "bool", name: "usageAsCollateralEnabled", type: "bool" },
                    { internalType: "bool", name: "borrowingEnabled", type: "bool" },
                    { internalType: "bool", name: "stableBorrowRateEnabled", type: "bool" },
                    { internalType: "bool", name: "isActive", type: "bool" },
                  ],
                  internalType: "struct ReserveConfigurationData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveData(address)": {
              inputs: [{ internalType: "address", name: "_reserve", type: "address" }],
              name: "getReserveData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "totalLiquidity", type: "uint256" },
                    { internalType: "uint256", name: "availableLiquidity", type: "uint256" },
                    { internalType: "uint256", name: "totalBorrowsStable", type: "uint256" },
                    { internalType: "uint256", name: "totalBorrowsVariable", type: "uint256" },
                    { internalType: "uint256", name: "liquidityRate", type: "uint256" },
                    { internalType: "uint256", name: "variableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "stableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "averageStableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "utilizationRate", type: "uint256" },
                    { internalType: "uint256", name: "liquidityIndex", type: "uint256" },
                    { internalType: "uint256", name: "variableBorrowIndex", type: "uint256" },
                    { internalType: "address", name: "aTokenAddress", type: "address" },
                    { internalType: "uint40", name: "lastUpdateTimestamp", type: "uint40" },
                  ],
                  internalType: "struct ReserveData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getUserAccountData(address)": {
              inputs: [{ internalType: "address", name: "_user", type: "address" }],
              name: "getUserAccountData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "totalLiquidityETH", type: "uint256" },
                    { internalType: "uint256", name: "totalCollateralETH", type: "uint256" },
                    { internalType: "uint256", name: "totalBorrowsETH", type: "uint256" },
                    { internalType: "uint256", name: "totalFeesETH", type: "uint256" },
                    { internalType: "uint256", name: "availableBorrowsETH", type: "uint256" },
                    { internalType: "uint256", name: "currentLiquidationThreshold", type: "uint256" },
                    { internalType: "uint256", name: "ltv", type: "uint256" },
                    { internalType: "uint256", name: "healthFactor", type: "uint256" },
                  ],
                  internalType: "struct UserAccountData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getUserReserveData(address,address)": {
              inputs: [
                { internalType: "address", name: "_reserve", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "getUserReserveData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "currentATokenBalance", type: "uint256" },
                    { internalType: "uint256", name: "currentBorrowBalance", type: "uint256" },
                    { internalType: "uint256", name: "principalBorrowBalance", type: "uint256" },
                    { internalType: "uint256", name: "borrowRateMode", type: "uint256" },
                    { internalType: "uint256", name: "borrowRate", type: "uint256" },
                    { internalType: "uint256", name: "liquidityRate", type: "uint256" },
                    { internalType: "uint256", name: "originationFee", type: "uint256" },
                    { internalType: "uint256", name: "variableBorrowIndex", type: "uint256" },
                    { internalType: "uint256", name: "lastUpdateTimestamp", type: "uint256" },
                    { internalType: "bool", name: "enabled", type: "bool" },
                  ],
                  internalType: "struct UserReserveData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "repay(address,uint256,address)": {
              inputs: [
                { internalType: "address", name: "_reserve", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address payable", name: "_onBehalfOf", type: "address" },
              ],
              name: "repay",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setUserUseReserveAsCollateral(address,bool)": {
              inputs: [
                { internalType: "address", name: "_reserve", type: "address" },
                { internalType: "bool", name: "_useAsCollateral", type: "bool" },
              ],
              name: "setUserUseReserveAsCollateral",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v1/IAaveV1LendingPoolAddressesProvider.sol:IAaveV1LendingPoolAddressesProvider": {
          source: "contracts/interfaces/aave/v1/IAaveV1LendingPoolAddressesProvider.sol",
          name: "IAaveV1LendingPoolAddressesProvider",
          methods: {
            "getLendingPool()": {
              inputs: [],
              name: "getLendingPool",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLendingPoolCore()": {
              inputs: [],
              name: "getLendingPoolCore",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLendingPoolDataProvider()": {
              inputs: [],
              name: "getLendingPoolDataProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getPriceOracle()": {
              inputs: [],
              name: "getPriceOracle",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v1/IAaveV1PriceOracle.sol:IAaveV1PriceOracle": {
          source: "contracts/interfaces/aave/v1/IAaveV1PriceOracle.sol",
          name: "IAaveV1PriceOracle",
          methods: {
            "getAssetPrice(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getAssetPrice",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v1/IAaveV1Token.sol:IAaveV1Token": {
          source: "contracts/interfaces/aave/v1/IAaveV1Token.sol",
          name: "IAaveV1Token",
          methods: {
            "isTransferAllowed(address,uint256)": {
              inputs: [
                { internalType: "address", name: "user", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "isTransferAllowed",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "redeem(uint256)": {
              inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
              name: "redeem",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "underlyingAssetAddress()": {
              inputs: [],
              name: "underlyingAssetAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2.sol:IAaveV2": {
          source: "contracts/interfaces/aave/v2/IAaveV2.sol",
          name: "IAaveV2",
          methods: {
            "borrow(address,uint256,uint256,uint16,address)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256", name: "_interestRateMode", type: "uint256" },
                { internalType: "uint16", name: "_referralCode", type: "uint16" },
                { internalType: "address", name: "_onBehalfOf", type: "address" },
              ],
              name: "borrow",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "deposit(address,uint256,address,uint16)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_onBehalfOf", type: "address" },
                { internalType: "uint16", name: "_referralCode", type: "uint16" },
              ],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getAddressesProvider()": {
              inputs: [],
              name: "getAddressesProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getConfiguration(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getConfiguration",
              outputs: [
                {
                  components: [{ internalType: "uint256", name: "data", type: "uint256" }],
                  internalType: "struct ReserveConfigurationMap",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveData(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveData",
              outputs: [
                {
                  components: [
                    {
                      components: [{ internalType: "uint256", name: "data", type: "uint256" }],
                      internalType: "struct ReserveConfigurationMap",
                      name: "configuration",
                      type: "tuple",
                    },
                    { internalType: "uint128", name: "liquidityIndex", type: "uint128" },
                    { internalType: "uint128", name: "variableBorrowIndex", type: "uint128" },
                    { internalType: "uint128", name: "currentLiquidityRate", type: "uint128" },
                    { internalType: "uint128", name: "currentVariableBorrowRate", type: "uint128" },
                    { internalType: "uint128", name: "currentStableBorrowRate", type: "uint128" },
                    { internalType: "uint40", name: "lastUpdateTimestamp", type: "uint40" },
                    { internalType: "address", name: "aTokenAddress", type: "address" },
                    { internalType: "address", name: "stableDebtTokenAddress", type: "address" },
                    { internalType: "address", name: "variableDebtTokenAddress", type: "address" },
                    { internalType: "address", name: "interestRateStrategyAddress", type: "address" },
                    { internalType: "uint8", name: "id", type: "uint8" },
                  ],
                  internalType: "struct ReserveData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveNormalizedIncome(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveNormalizedIncome",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getReserveNormalizedVariableDebt(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveNormalizedVariableDebt",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getReservesList()": {
              inputs: [],
              name: "getReservesList",
              outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUserAccountData(address)": {
              inputs: [{ internalType: "address", name: "_user", type: "address" }],
              name: "getUserAccountData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "totalCollateralETH", type: "uint256" },
                    { internalType: "uint256", name: "totalDebtETH", type: "uint256" },
                    { internalType: "uint256", name: "availableBorrowsETH", type: "uint256" },
                    { internalType: "uint256", name: "currentLiquidationThreshold", type: "uint256" },
                    { internalType: "uint256", name: "ltv", type: "uint256" },
                    { internalType: "uint256", name: "healthFactor", type: "uint256" },
                  ],
                  internalType: "struct UserAccountData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getUserConfiguration(address)": {
              inputs: [{ internalType: "address", name: "user", type: "address" }],
              name: "getUserConfiguration",
              outputs: [
                {
                  components: [{ internalType: "uint256", name: "data", type: "uint256" }],
                  internalType: "struct ReserveConfigurationMap",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "paused()": {
              inputs: [],
              name: "paused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "repay(address,uint256,uint256,address)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256", name: "_rateMode", type: "uint256" },
                { internalType: "address", name: "_onBehalfOf", type: "address" },
              ],
              name: "repay",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setUserUseReserveAsCollateral(address,bool)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "bool", name: "_useAsCollateral", type: "bool" },
              ],
              name: "setUserUseReserveAsCollateral",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "withdraw(address,uint256,address)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_to", type: "address" },
              ],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2LendingPoolAddressProviderRegistry.sol:IAaveV2LendingPoolAddressProviderRegistry": {
          source: "contracts/interfaces/aave/v2/IAaveV2LendingPoolAddressProviderRegistry.sol",
          name: "IAaveV2LendingPoolAddressProviderRegistry",
          methods: {
            "getAddressesProviderIdByAddress(address)": {
              inputs: [{ internalType: "address", name: "addressesProvider", type: "address" }],
              name: "getAddressesProviderIdByAddress",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAddressesProvidersList()": {
              inputs: [],
              name: "getAddressesProvidersList",
              outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2LendingPoolAddressesProvider.sol:IAaveV2LendingPoolAddressesProvider": {
          source: "contracts/interfaces/aave/v2/IAaveV2LendingPoolAddressesProvider.sol",
          name: "IAaveV2LendingPoolAddressesProvider",
          methods: {
            "getAddress(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_id", type: "bytes32" }],
              name: "getAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLendingPool()": {
              inputs: [],
              name: "getLendingPool",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLendingPoolCollateralManager()": {
              inputs: [],
              name: "getLendingPoolCollateralManager",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLendingRateOracle()": {
              inputs: [],
              name: "getLendingRateOracle",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getMarketId()": {
              inputs: [],
              name: "getMarketId",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            "getPriceOracle()": {
              inputs: [],
              name: "getPriceOracle",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2PriceOracle.sol:IAaveV2PriceOracle": {
          source: "contracts/interfaces/aave/v2/IAaveV2PriceOracle.sol",
          name: "IAaveV2PriceOracle",
          methods: {
            "getAssetPrice(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getAssetPrice",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAssetsPrices(address[])": {
              inputs: [{ internalType: "address[]", name: "_assets", type: "address[]" }],
              name: "getAssetsPrices",
              outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getFallbackOracle()": {
              inputs: [],
              name: "getFallbackOracle",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSourceOfAsset(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getSourceOfAsset",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2ProtocolDataProvider.sol:IAaveV2ProtocolDataProvider": {
          source: "contracts/interfaces/aave/v2/IAaveV2ProtocolDataProvider.sol",
          name: "IAaveV2ProtocolDataProvider",
          methods: {
            "ADDRESSES_PROVIDER()": {
              inputs: [],
              name: "ADDRESSES_PROVIDER",
              outputs: [{ internalType: "contract IAaveV2LendingPoolAddressesProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllATokens()": {
              inputs: [],
              name: "getAllATokens",
              outputs: [
                {
                  components: [
                    { internalType: "string", name: "symbol", type: "string" },
                    { internalType: "address", name: "tokenAddress", type: "address" },
                  ],
                  internalType: "struct TokenData[]",
                  name: "",
                  type: "tuple[]",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getAllReservesTokens()": {
              inputs: [],
              name: "getAllReservesTokens",
              outputs: [
                {
                  components: [
                    { internalType: "string", name: "symbol", type: "string" },
                    { internalType: "address", name: "tokenAddress", type: "address" },
                  ],
                  internalType: "struct TokenData[]",
                  name: "",
                  type: "tuple[]",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveConfigurationData(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveConfigurationData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "decimals", type: "uint256" },
                    { internalType: "uint256", name: "ltv", type: "uint256" },
                    { internalType: "uint256", name: "liquidationThreshold", type: "uint256" },
                    { internalType: "uint256", name: "liquidationBonus", type: "uint256" },
                    { internalType: "uint256", name: "reserveFactor", type: "uint256" },
                    { internalType: "bool", name: "usageAsCollateralEnabled", type: "bool" },
                    { internalType: "bool", name: "borrowingEnabled", type: "bool" },
                    { internalType: "bool", name: "stableBorrowRateEnabled", type: "bool" },
                    { internalType: "bool", name: "isActive", type: "bool" },
                    { internalType: "bool", name: "isFrozen", type: "bool" },
                  ],
                  internalType: "struct ReserveConfigurationData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveData(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "availableLiquidity", type: "uint256" },
                    { internalType: "uint256", name: "totalStableDebt", type: "uint256" },
                    { internalType: "uint256", name: "totalVariableDebt", type: "uint256" },
                    { internalType: "uint256", name: "liquidityRate", type: "uint256" },
                    { internalType: "uint256", name: "variableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "stableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "averageStableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "liquidityIndex", type: "uint256" },
                    { internalType: "uint256", name: "variableBorrowIndex", type: "uint256" },
                    { internalType: "uint40", name: "lastUpdateTimestamp", type: "uint40" },
                  ],
                  internalType: "struct ReserveDataProtocol",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getReserveTokensAddresses(address)": {
              inputs: [{ internalType: "address", name: "_asset", type: "address" }],
              name: "getReserveTokensAddresses",
              outputs: [
                {
                  components: [
                    { internalType: "address", name: "aTokenAddress", type: "address" },
                    { internalType: "address", name: "stableDebtTokenAddress", type: "address" },
                    { internalType: "address", name: "variableDebtTokenAddress", type: "address" },
                  ],
                  internalType: "struct ReserveTokensAddresses",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getUserReserveData(address,address)": {
              inputs: [
                { internalType: "address", name: "_asset", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "getUserReserveData",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "currentATokenBalance", type: "uint256" },
                    { internalType: "uint256", name: "currentStableDebt", type: "uint256" },
                    { internalType: "uint256", name: "currentVariableDebt", type: "uint256" },
                    { internalType: "uint256", name: "principalStableDebt", type: "uint256" },
                    { internalType: "uint256", name: "scaledVariableDebt", type: "uint256" },
                    { internalType: "uint256", name: "stableBorrowRate", type: "uint256" },
                    { internalType: "uint256", name: "liquidityRate", type: "uint256" },
                    { internalType: "uint40", name: "stableRateLastUpdated", type: "uint40" },
                    { internalType: "bool", name: "usageAsCollateralEnabled", type: "bool" },
                  ],
                  internalType: "struct UserReserveData",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/aave/v2/IAaveV2Token.sol:IAaveV2Token": {
          source: "contracts/interfaces/aave/v2/IAaveV2Token.sol",
          name: "IAaveV2Token",
          methods: {
            "POOL()": {
              inputs: [],
              name: "POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RESERVE_TREASURY_ADDRESS()": {
              inputs: [],
              name: "RESERVE_TREASURY_ADDRESS",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "UNDERLYING_ASSET_ADDRESS()": {
              inputs: [],
              name: "UNDERLYING_ASSET_ADDRESS",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getScaledUserBalanceAndSupply(address)": {
              inputs: [{ internalType: "address", name: "user", type: "address" }],
              name: "getScaledUserBalanceAndSupply",
              outputs: [
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "isTransferAllowed(address,uint256)": {
              inputs: [
                { internalType: "address", name: "user", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "isTransferAllowed",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "scaledBalanceOf(address)": {
              inputs: [{ internalType: "address", name: "user", type: "address" }],
              name: "scaledBalanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "scaledTotalSupply()": {
              inputs: [],
              name: "scaledTotalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/chi/IChi.sol:IChi": {
          source: "contracts/interfaces/chi/IChi.sol",
          name: "IChi",
          details: "Interface of the Opty.fi Vaults.",
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the remaining number of tokens that `spender` will be allowed to spend on behalf of `owner` through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets `amount` as the allowance of `spender` over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens owned by `account`.",
            },
            "mint(uint256)": {
              inputs: [{ internalType: "uint256", name: "value", type: "uint256" }],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of tokens in existence.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from the caller's account to `recipient`. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Moves `amount` tokens from `sender` to `recipient` using the allowance mechanism. `amount` is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.",
            },
          },
        },
        "contracts/interfaces/compound/ICompound.sol:ICompound": {
          source: "contracts/interfaces/compound/ICompound.sol",
          name: "ICompound",
          methods: {
            "claimComp(address)": {
              inputs: [{ internalType: "address", name: "holder", type: "address" }],
              name: "claimComp",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "compAccrued(address)": {
              inputs: [{ internalType: "address", name: "holder", type: "address" }],
              name: "compAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "exchangeRateCurrent()": {
              inputs: [],
              name: "exchangeRateCurrent",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "exchangeRateStored()": {
              inputs: [],
              name: "exchangeRateStored",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getCash()": {
              inputs: [],
              name: "getCash",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getCompBalanceMetadata(address,address)": {
              inputs: [
                { internalType: "address", name: "comp", type: "address" },
                { internalType: "address", name: "account", type: "address" },
              ],
              name: "getCompBalanceMetadata",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "balance", type: "uint256" },
                    { internalType: "uint256", name: "votes", type: "uint256" },
                    { internalType: "address", name: "delegate", type: "address" },
                  ],
                  internalType: "struct ICompound.CompBalanceMetadata",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getCompBalanceMetadataExt(address,address,address)": {
              inputs: [
                { internalType: "address", name: "comp", type: "address" },
                { internalType: "address", name: "comptroller", type: "address" },
                { internalType: "address", name: "account", type: "address" },
              ],
              name: "getCompBalanceMetadataExt",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "balance", type: "uint256" },
                    { internalType: "uint256", name: "votes", type: "uint256" },
                    { internalType: "address", name: "delegate", type: "address" },
                    { internalType: "uint256", name: "allocated", type: "uint256" },
                  ],
                  internalType: "struct ICompound.CompBalanceMetadataExt",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "nonpayable",
              type: "function",
            },
            "mint(uint256)": {
              inputs: [{ internalType: "uint256", name: "mintAmount", type: "uint256" }],
              name: "mint",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "redeem(uint256)": {
              inputs: [{ internalType: "uint256", name: "redeemTokens", type: "uint256" }],
              name: "redeem",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "totalBorrows()": {
              inputs: [],
              name: "totalBorrows",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "totalReserves()": {
              inputs: [],
              name: "totalReserves",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "underlying()": {
              inputs: [],
              name: "underlying",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/cream/ICream.sol:ICream": {
          source: "contracts/interfaces/cream/ICream.sol",
          name: "ICream",
          methods: {
            "claimComp(address)": {
              inputs: [{ internalType: "address", name: "holder", type: "address" }],
              name: "claimComp",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "compAccrued(address)": {
              inputs: [{ internalType: "address", name: "holder", type: "address" }],
              name: "compAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "exchangeRateStored()": {
              inputs: [],
              name: "exchangeRateStored",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getCash()": {
              inputs: [],
              name: "getCash",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getCompBalanceMetadata(address,address)": {
              inputs: [
                { internalType: "address", name: "comp", type: "address" },
                { internalType: "address", name: "account", type: "address" },
              ],
              name: "getCompBalanceMetadata",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "balance", type: "uint256" },
                    { internalType: "uint256", name: "votes", type: "uint256" },
                    { internalType: "address", name: "delegate", type: "address" },
                  ],
                  internalType: "struct ICream.CompBalanceMetadata",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getCompBalanceMetadataExt(address,address,address)": {
              inputs: [
                { internalType: "address", name: "comp", type: "address" },
                { internalType: "address", name: "comptroller", type: "address" },
                { internalType: "address", name: "account", type: "address" },
              ],
              name: "getCompBalanceMetadataExt",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "balance", type: "uint256" },
                    { internalType: "uint256", name: "votes", type: "uint256" },
                    { internalType: "address", name: "delegate", type: "address" },
                    { internalType: "uint256", name: "allocated", type: "uint256" },
                  ],
                  internalType: "struct ICream.CompBalanceMetadataExt",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "nonpayable",
              type: "function",
            },
            "mint(uint256)": {
              inputs: [{ internalType: "uint256", name: "mintAmount", type: "uint256" }],
              name: "mint",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "redeem(uint256)": {
              inputs: [{ internalType: "uint256", name: "redeemTokens", type: "uint256" }],
              name: "redeem",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "underlying()": {
              inputs: [],
              name: "underlying",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/curve/ICurveDAO.sol:ICurveDAO": {
          source: "contracts/interfaces/curve/ICurveDAO.sol",
          name: "ICurveDAO",
          methods: {
            "mint(address)": {
              inputs: [{ internalType: "address", name: "liquidityPoolGauge", type: "address" }],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/curve/ICurveDeposit.sol:ICurveDeposit": {
          source: "contracts/interfaces/curve/ICurveDeposit.sol",
          name: "ICurveDeposit",
          methods: {
            "add_liquidity(uint256[4],uint256)": {
              inputs: [
                { internalType: "uint256[4]", name: "amountsIn", type: "uint256[4]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 4token pool.",
            },
            "add_liquidity(uint256[2],uint256)": {
              inputs: [
                { internalType: "uint256[2]", name: "amountsIn", type: "uint256[2]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 2token pool.",
            },
            "add_liquidity(uint256[3],uint256)": {
              inputs: [
                { internalType: "uint256[3]", name: "amountsIn", type: "uint256[3]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 3token pool.",
            },
            "calc_withdraw_one_coin(uint256,int128)": {
              inputs: [
                { internalType: "uint256", name: "_balance", type: "uint256" },
                { internalType: "int128", name: "_tokenIndex", type: "int128" },
              ],
              name: "calc_withdraw_one_coin",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[2])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[2]", name: "minAmountOut", type: "uint256[2]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[4])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[4]", name: "minAmountOut", type: "uint256[4]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[3])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[3]", name: "minAmountOut", type: "uint256[3]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity_one_coin(uint256,int128,uint256,bool)": {
              inputs: [
                { internalType: "uint256", name: "amountIn", type: "uint256" },
                { internalType: "int128", name: "i", type: "int128" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
                { internalType: "bool", name: "donateDust", type: "bool" },
              ],
              name: "remove_liquidity_one_coin",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/curve/ICurveGauge.sol:ICurveGauge": {
          source: "contracts/interfaces/curve/ICurveGauge.sol",
          name: "ICurveGauge",
          methods: {
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "claimable_tokens(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "claimable_tokens",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "deposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_value", type: "uint256" }],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "withdraw(uint256)": {
              inputs: [{ internalType: "uint256", name: "_value", type: "uint256" }],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/curve/ICurveSwap.sol:ICurveSwap": {
          source: "contracts/interfaces/curve/ICurveSwap.sol",
          name: "ICurveSwap",
          methods: {
            "add_liquidity(uint256[4],uint256)": {
              inputs: [
                { internalType: "uint256[4]", name: "amountsIn", type: "uint256[4]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 4token pool.",
            },
            "add_liquidity(uint256[2],uint256)": {
              inputs: [
                { internalType: "uint256[2]", name: "amountsIn", type: "uint256[2]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 2token pool.",
            },
            "add_liquidity(uint256[3],uint256)": {
              inputs: [
                { internalType: "uint256[3]", name: "amountsIn", type: "uint256[3]" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "add_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Function for every 3token pool.",
            },
            "calc_token_amount(uint256[],bool)": {
              inputs: [
                { internalType: "uint256[]", name: "amountsIn", type: "uint256[]" },
                { internalType: "bool", name: "deposit", type: "bool" },
              ],
              name: "calc_token_amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "get_virtual_price()": {
              inputs: [],
              name: "get_virtual_price",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[2])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[2]", name: "minAmountOut", type: "uint256[2]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[4])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[4]", name: "minAmountOut", type: "uint256[4]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity(uint256,uint256[3])": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "uint256[3]", name: "minAmountOut", type: "uint256[3]" },
              ],
              name: "remove_liquidity",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "remove_liquidity_one_coin(uint256,int128,uint256)": {
              inputs: [
                { internalType: "uint256", name: "amountIn", type: "uint256" },
                { internalType: "int128", name: "i", type: "int128" },
                { internalType: "uint256", name: "minAmountOut", type: "uint256" },
              ],
              name: "remove_liquidity_one_coin",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/curve/ITokenMinter.sol:ITokenMinter": {
          source: "contracts/interfaces/curve/ITokenMinter.sol",
          name: "ITokenMinter",
          methods: {
            "mint(address)": {
              inputs: [{ internalType: "address", name: "_gauge", type: "address" }],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "minted(address,address)": {
              inputs: [
                { internalType: "address", name: "_gauge", type: "address" },
                { internalType: "address", name: "_account", type: "address" },
              ],
              name: "minted",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/dforce/IDForceDeposit.sol:IDForceDeposit": {
          source: "contracts/interfaces/dforce/IDForceDeposit.sol",
          name: "IDForceDeposit",
          methods: {
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getExchangeRate()": {
              inputs: [],
              name: "getExchangeRate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidity()": {
              inputs: [],
              name: "getLiquidity",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getTokenBalance(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "getTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getTotalBalance()": {
              inputs: [],
              name: "getTotalBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "mint(address,uint256)": {
              inputs: [
                { internalType: "address", name: "receiver", type: "address" },
                { internalType: "uint256", name: "depositAmount", type: "uint256" },
              ],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "redeem(address,uint256)": {
              inputs: [
                { internalType: "address", name: "receiver", type: "address" },
                { internalType: "uint256", name: "redeemAmount", type: "uint256" },
              ],
              name: "redeem",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/dforce/IDForceStake.sol:IDForceStake": {
          source: "contracts/interfaces/dforce/IDForceStake.sol",
          name: "IDForceStake",
          methods: {
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "_account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "earned(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "earned",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "exit()": { inputs: [], name: "exit", outputs: [], stateMutability: "nonpayable", type: "function" },
            "getReward()": {
              inputs: [],
              name: "getReward",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "stake(uint256)": {
              inputs: [{ internalType: "uint256", name: "_value", type: "uint256" }],
              name: "stake",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "withdraw(uint256)": {
              inputs: [{ internalType: "uint256", name: "_value", type: "uint256" }],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/dydx/IdYdX.sol:IdYdX": {
          source: "contracts/interfaces/dydx/IdYdX.sol",
          name: "IdYdX",
          methods: {
            "getAccountWei((address,uint256),uint256)": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "owner", type: "address" },
                    { internalType: "uint256", name: "number", type: "uint256" },
                  ],
                  internalType: "struct AccountInfo",
                  name: "_accountInfo",
                  type: "tuple",
                },
                { internalType: "uint256", name: "marketId", type: "uint256" },
              ],
              name: "getAccountWei",
              outputs: [
                { internalType: "bool", name: "", type: "bool" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getMarketTotalPar(uint256)": {
              inputs: [{ internalType: "uint256", name: "marketId", type: "uint256" }],
              name: "getMarketTotalPar",
              outputs: [
                {
                  components: [
                    { internalType: "uint128", name: "borrow", type: "uint128" },
                    { internalType: "uint128", name: "supply", type: "uint128" },
                  ],
                  internalType: "struct TotalPar",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
            "operate((address,uint256)[],(uint8,uint256,(bool,uint8,uint8,uint256),uint256,uint256,address,uint256,bytes)[])": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "owner", type: "address" },
                    { internalType: "uint256", name: "number", type: "uint256" },
                  ],
                  internalType: "struct AccountInfo[]",
                  name: "_accountInfo",
                  type: "tuple[]",
                },
                {
                  components: [
                    { internalType: "enum ActionType", name: "actionType", type: "uint8" },
                    { internalType: "uint256", name: "accountId", type: "uint256" },
                    {
                      components: [
                        { internalType: "bool", name: "sign", type: "bool" },
                        { internalType: "enum AssetDenomination", name: "denomination", type: "uint8" },
                        { internalType: "enum AssetReference", name: "ref", type: "uint8" },
                        { internalType: "uint256", name: "value", type: "uint256" },
                      ],
                      internalType: "struct AssetAmount",
                      name: "amount",
                      type: "tuple",
                    },
                    { internalType: "uint256", name: "primaryMarketId", type: "uint256" },
                    { internalType: "uint256", name: "secondaryMarketId", type: "uint256" },
                    { internalType: "address", name: "otherAddress", type: "address" },
                    { internalType: "uint256", name: "otherAccountId", type: "uint256" },
                    { internalType: "bytes", name: "data", type: "bytes" },
                  ],
                  internalType: "struct ActionArgs[]",
                  name: "_actionArgs",
                  type: "tuple[]",
                },
              ],
              name: "operate",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOperators((address,bool)[])": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "operator", type: "address" },
                    { internalType: "bool", name: "trusted", type: "bool" },
                  ],
                  internalType: "struct OperatorArg[]",
                  name: "args",
                  type: "tuple[]",
                },
              ],
              name: "setOperators",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/fulcrum/IFulcrum.sol:IFulcrum": {
          source: "contracts/interfaces/fulcrum/IFulcrum.sol",
          name: "IFulcrum",
          methods: {
            "assetBalanceOf(address)": {
              inputs: [{ internalType: "address", name: "holder", type: "address" }],
              name: "assetBalanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "burn(address,uint256)": {
              inputs: [
                { internalType: "address", name: "receiver", type: "address" },
                { internalType: "uint256", name: "burnAmount", type: "uint256" },
              ],
              name: "burn",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "loanTokenAddress()": {
              inputs: [],
              name: "loanTokenAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "marketLiquidity()": {
              inputs: [],
              name: "marketLiquidity",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "mint(address,uint256)": {
              inputs: [
                { internalType: "address", name: "receiver", type: "address" },
                { internalType: "uint256", name: "depositAmount", type: "uint256" },
              ],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "tokenPrice()": {
              inputs: [],
              name: "tokenPrice",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/harvest.finance/IHarvestDeposit.sol:IHarvestDeposit": {
          source: "contracts/interfaces/harvest.finance/IHarvestDeposit.sol",
          name: "IHarvestDeposit",
          methods: {
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "deposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "underlying()": {
              inputs: [],
              name: "underlying",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "underlyingBalanceWithInvestment()": {
              inputs: [],
              name: "underlyingBalanceWithInvestment",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "withdraw(uint256)": {
              inputs: [{ internalType: "uint256", name: "_shares", type: "uint256" }],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/harvest.finance/IHarvestFarm.sol:IHarvestFarm": {
          source: "contracts/interfaces/harvest.finance/IHarvestFarm.sol",
          name: "IHarvestFarm",
          methods: {
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "earned(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "earned",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "exit()": { inputs: [], name: "exit", outputs: [], stateMutability: "nonpayable", type: "function" },
            "stake(uint256)": {
              inputs: [{ internalType: "uint256", name: "_value", type: "uint256" }],
              name: "stake",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/opty/IAdapter.sol:IAdapter": {
          source: "contracts/interfaces/opty/IAdapter.sol",
          name: "IAdapter",
          details: "Interface of the Defi protocol code provider.",
          methods: {
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_underlygingTokenAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the equivalent value of _liquidityPoolToken got given {underlyingTokenAmount}",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the equivalent amount of liquidity pool token given the share amount to be withdrawn",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the equivalent amount of liquidity pool token given the share amount to be withdrawn",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              details: "Returns whether the protocol can stake",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the balance in underlying for liquidityPoolToken balance of holder",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the amount in underlying token for whole      collateral of {_optyPool} balance if {_borrowAmount}      in {_borrowToken} is repaid.",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the balance in underlying for staked liquidityPoolToken balance of holder",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Borrow full `amount` of `_outputToken` and sends the  `_outputToken` token to the caller`. Returns a bytes value to be executed.",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns code for claiming the tokens",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Deposit full `amount` of `underlyingToken` and sends the  `liquidityPoolToken` token to the caller`. Returns a bytes value to be executed.",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Supply `liquidityPool` for Curve,Compound `liquidityPoolAddressProvider` for Aave and returns liquidityPoolToken to the caller`. Returns a bytes value to be executed.",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the code for harvesting all reward",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the code for harvesting some rewards",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the lending pool token given lending pool for Curve, lendingPoolToken for Aave,Compound.",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "get liquidity pool token balance",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "get liquidity pool token staked balance",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "_poolValue", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Supply `liquidityPool`, `underlyingToken` and returns pool value in underlying token for that liquidity pool. Returns a uint value",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Repay full amount of  `_outputToken` and sends the  `_underlyingTokens` token to the caller`. Returns a bytes value to be executed.",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              details: "Returns reward token address",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the equivalent value of underlying token for given {liquiidityPoolTokenAmount}.",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the amount in underlying token for      {_liquidityPoolTokenAmount} collateral if {_borrowAmount}      in {_borrowToken} is repaid.",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns code for staking  liquidityPool token",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_stakeAmount", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns code for staking liquidityPool token",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the amount of accrued reward tokens",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "liquidityPool", type: "address" },
                { internalType: "address", name: "_liquidityPoolToken", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the underlying token given the lendingPoolToken for Aave,Compound & lending pool for Curve.",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns code for unstaking liquidityPool token",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the code for unstake and withdraw of liquidty pool tokens",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the code for unstake and withdraw of liquidty pool tokens",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_unstakeAmount", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns code for unstaking staking liquidityPool token",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Redeem full `amount` of `liquidityPoolToken` token and sends the `underlyingToken` to the caller`. Returns a bytes value to be executed.",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "liquidityPool", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details:
                "Redeem `amount` of `liquidityPoolToken` token and sends the `underlyingToken` to the caller`. Returns a bytes value to be executed.",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              details: "Returns whether the share amount is redeemable",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              details: "Returns whether the share amount is redeemable",
            },
          },
        },
        "contracts/interfaces/opty/IOPTYStakingPool.sol:IOPTYStakingPool": {
          source: "contracts/interfaces/opty/IOPTYStakingPool.sol",
          name: "IOPTYStakingPool",
          details: "Interface of the Opty.fi staking pool.",
          methods: {
            "setOptyRatePerSecond(uint256)": {
              inputs: [{ internalType: "uint256", name: "_rate", type: "uint256" }],
              name: "setOptyRatePerSecond",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/opty/IOPTYStakingRateBalancer.sol:IOPTYStakingRateBalancer": {
          source: "contracts/interfaces/opty/IOPTYStakingRateBalancer.sol",
          name: "IOPTYStakingRateBalancer",
          details: "Interface of the Opty.fi staking rate balancer.",
          methods: {
            "updateOptyRates()": {
              inputs: [],
              name: "updateOptyRates",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "updateStakedOPTY(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_staker", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "updateStakedOPTY",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "updateUnstakedOPTY(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_staker", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "updateUnstakedOPTY",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/opty/IStrategyProvider.sol:IStrategyProvider": {
          source: "contracts/interfaces/opty/IStrategyProvider.sol",
          name: "IStrategyProvider",
          details: "Interface for strategy provider",
          methods: {
            "rpToTokenToBestStrategy(string,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
              ],
              name: "rpToTokenToBestStrategy",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "rpToTokenToDefaultStrategy(string,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
              ],
              name: "rpToTokenToDefaultStrategy",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "setBestDefaultStrategy(string,bytes32,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
                { internalType: "bytes32", name: "_strategyHash", type: "bytes32" },
              ],
              name: "setBestDefaultStrategy",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setBestStrategy(string,bytes32,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
                { internalType: "bytes32", name: "_strategyHash", type: "bytes32" },
              ],
              name: "setBestStrategy",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setVaultRewardStrategy(bytes32,(uint256,uint256))": {
              inputs: [
                { internalType: "bytes32", name: "_vaultRewardTokenHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "_vaultRewardStrategy",
                  type: "tuple",
                },
              ],
              name: "setVaultRewardStrategy",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign strategy in form of `_vaultRewardStrategy` to the `_vaultRewardTokenHash`. Returns a vaultRewardStrategy hash value indicating successful operation. Emits a {LogSetVaultRewardStrategy} event. Requirements: - msg.sender should be operator. - `hold` in {_vaultRewardStrategy} shoould be greater than 0 and should be in `basis` format.      For eg: If hold is 50%, then it's basis will be 5000, Similarly, if it 20%, then it's basis is 2000. - `convert` in {_vaultRewardStrategy} should be approved      For eg: If convert is 50%, then it's basis will be 5000, Similarly, if it 20%, then it's basis is 2000.",
            },
            "vaultRewardTokenHashToVaultRewardTokenStrategy(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_tokenHash", type: "bytes32" }],
              name: "vaultRewardTokenHashToVaultRewardTokenStrategy",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/interfaces/opty/IVault.sol:IVault": {
          source: "contracts/interfaces/opty/IVault.sol",
          name: "IVault",
          details: "Interface of the Opty.fi Vaults.",
          methods: {
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "discontinue()": {
              inputs: [],
              name: "discontinue",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "harvest(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "harvest",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "isMaxVaultValueJumpAllowed(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "_diff", type: "uint256" },
                { internalType: "uint256", name: "_currentVaultValue", type: "uint256" },
              ],
              name: "isMaxVaultValueJumpAllowed",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "rebalance()": {
              inputs: [],
              name: "rebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxVaultValueJump(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxVaultValueJump", type: "uint256" }],
              name: "setMaxVaultValueJump",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOPTYMinter(address)": {
              inputs: [{ internalType: "address", name: "_optyMinter", type: "address" }],
              name: "setOPTYMinter",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setPaused(bool)": {
              inputs: [{ internalType: "bool", name: "_paused", type: "bool" }],
              name: "setPaused",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setProfile(string)": {
              inputs: [{ internalType: "string", name: "_profile", type: "string" }],
              name: "setProfile",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRiskManager(address)": {
              inputs: [{ internalType: "address", name: "_riskManager", type: "address" }],
              name: "setRiskManager",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setStrategyManager(address)": {
              inputs: [{ internalType: "address", name: "_strategyCodeProvider", type: "address" }],
              name: "setStrategyManager",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setToken(address)": {
              inputs: [{ internalType: "address", name: "_underlyingToken", type: "address" }],
              name: "setToken",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setWithdrawalFee(uint256)": {
              inputs: [{ internalType: "uint256", name: "_withdrawalFee", type: "uint256" }],
              name: "setWithdrawalFee",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDeposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDeposit",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAll()": {
              inputs: [],
              name: "userDepositAll",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllAndStake(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllAndStake",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllAndStakeWithCHI(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalance()": {
              inputs: [],
              name: "userDepositAllRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceAndStake(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllRebalanceAndStake",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceAndStakeWithCHI(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllRebalanceAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceWithCHI()": {
              inputs: [],
              name: "userDepositAllRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllWithCHI()": {
              inputs: [],
              name: "userDepositAllWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAndStake(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositAndStake",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAndStakeWithCHI(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalance(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositRebalance",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceAndStake(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositRebalanceAndStake",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceAndStakeWithCHI(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositRebalanceAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawAllRebalance()": {
              inputs: [],
              name: "userWithdrawAllRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawAllRebalanceWithCHI()": {
              inputs: [],
              name: "userWithdrawAllRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawRebalance(uint256)": {
              inputs: [{ internalType: "uint256", name: "_redeemAmount", type: "uint256" }],
              name: "userWithdrawRebalance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawRebalanceWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_redeemAmount", type: "uint256" }],
              name: "userWithdrawRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/opty/IVaultStepInvestStrategyDefinitionRegistry.sol:IVaultStepInvestStrategyDefinitionRegistry": {
          source: "contracts/interfaces/opty/IVaultStepInvestStrategyDefinitionRegistry.sol",
          name: "IVaultStepInvestStrategyDefinitionRegistry",
          title: "IVaultStepInvestStrategyDefinitionRegistry",
          author: "Opty.fi",
          details: "Interface for IVaultStepInvestStrategyDefinitionRegistry",
          methods: {
            "getStrategy(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getStrategy",
              outputs: [
                { internalType: "uint256", name: "_index", type: "uint256" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[]",
                  name: "_strategySteps",
                  type: "tuple[]",
                },
              ],
              stateMutability: "view",
              type: "function",
              details: "Returns the Strategy by `_hash`.",
            },
            "getTokenToStrategies(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_tokensHash", type: "bytes32" }],
              name: "getTokenToStrategies",
              outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the list of strategy hashes by `_token`.",
            },
            "setStrategy(bytes32,(address,address,bool)[][])": {
              inputs: [
                { internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[][]",
                  name: "_strategySteps",
                  type: "tuple[][]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign multiple strategies in form of `_strategySteps` to the `_tokensHash`. Emits a {LogSetVaultInvestStrategy} event per successful assignment of the strategy. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
            "setStrategy(bytes32,(address,address,bool)[])": {
              inputs: [
                { internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[]",
                  name: "_strategySteps",
                  type: "tuple[]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign strategy in form of `_strategySteps` to the `_tokensHash`. Returns true indicating successful operation. Emits a {LogSetVaultInvestStrategy} event. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
            "setStrategy(bytes32[],(address,address,bool)[][])": {
              inputs: [
                { internalType: "bytes32[]", name: "_tokensHash", type: "bytes32[]" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[][]",
                  name: "_strategySteps",
                  type: "tuple[][]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign multiple strategies in form of `_strategySteps` to multiple tokens in form of `_tokensHash`. Emits a {LogSetVaultInvestStrategy} event per successful assignment of the strategy. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
          },
        },
        "contracts/interfaces/yearn/IYVault.sol:IYVault": {
          source: "contracts/interfaces/yearn/IYVault.sol",
          name: "IYVault",
          methods: {
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "deposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "withdraw(uint256)": {
              inputs: [{ internalType: "uint256", name: "_shares", type: "uint256" }],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/interfaces/yearn/IYearn.sol:IYearn": {
          source: "contracts/interfaces/yearn/IYearn.sol",
          name: "IYearn",
          methods: {
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calcPoolValueInToken()": {
              inputs: [],
              name: "calcPoolValueInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "deposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "deposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "withdraw(uint256)": {
              inputs: [{ internalType: "uint256", name: "_shares", type: "uint256" }],
              name: "withdraw",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/libraries/types/DataTypes.sol:DataTypes": {
          source: "contracts/libraries/types/DataTypes.sol",
          name: "DataTypes",
        },
        "contracts/mocks/EmergencyBrake.sol:EmergencyBrake": {
          source: "contracts/mocks/EmergencyBrake.sol",
          name: "EmergencyBrake",
          constructor: {
            inputs: [
              { internalType: "contract Vault", name: "_vault", type: "address" },
              { internalType: "contract ERC20", name: "_erc20", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "getBalance()": {
              inputs: [],
              name: "getBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "runDepositRebalance(uint256)": {
              inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
              name: "runDepositRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "runTwoTxnDepositRebalance(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "minAmount", type: "uint256" },
                { internalType: "uint256", name: "maxAmount", type: "uint256" },
              ],
              name: "runTwoTxnDepositRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "runTwoTxnRebalance(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "minAmount", type: "uint256" },
                { internalType: "uint256", name: "maxAmount", type: "uint256" },
              ],
              name: "runTwoTxnRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "runTwoTxnWithdrawAndDepositRebalance(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "minAmount", type: "uint256" },
                { internalType: "uint256", name: "maxAmount", type: "uint256" },
              ],
              name: "runTwoTxnWithdrawAndDepositRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "runTwoTxnWithdrawRebalance(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "minAmount", type: "uint256" },
                { internalType: "uint256", name: "maxAmount", type: "uint256" },
              ],
              name: "runTwoTxnWithdrawRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "runTwoTxnWithdrawRebalanceNoDeposit(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "minAmount", type: "uint256" },
                { internalType: "uint256", name: "maxAmount", type: "uint256" },
              ],
              name: "runTwoTxnWithdrawRebalanceNoDeposit",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/mocks/OpenDefiVault.sol:OpenDefiVault": {
          source: "contracts/mocks/OpenDefiVault.sol",
          name: "OpenDefiVault",
          constructor: {
            inputs: [{ internalType: "address", name: "_underlyingToken", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Function to get the underlying token balance of OptyVault Contract",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "initialize(address,address)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_vaultBoosterContract", type: "address" },
              ],
              name: "initialize",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "opTOKEN_REVISION()": {
              inputs: [],
              name: "opTOKEN_REVISION",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "setToken(address)": {
              inputs: [{ internalType: "address", name: "_underlyingToken", type: "address" }],
              name: "setToken",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
            "underlyingToken()": {
              inputs: [],
              name: "underlyingToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "userDeposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDeposit",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "vaultBoosterContract()": {
              inputs: [],
              name: "vaultBoosterContract",
              outputs: [{ internalType: "contract VaultBooster", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/mocks/dummyToken.sol:DummyToken": {
          source: "contracts/mocks/dummyToken.sol",
          name: "DummyToken",
          constructor: {
            inputs: [{ internalType: "uint256", name: "initialSupply", type: "uint256" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "mint(address,uint256)": {
              inputs: [
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
          },
        },
        "contracts/protocol/configuration/HarvestCodeProvider.sol:HarvestCodeProvider": {
          source: "contracts/protocol/configuration/HarvestCodeProvider.sol",
          name: "HarvestCodeProvider",
          title: "HarvestCodeProvider",
          author: "Opty.fi",
          details: "Abstraction layer to DeFi exchanges like Uniswap",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "getHarvestCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_rewardToken", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Get the codes for harvesting the tokens using uniswap router",
              params: {
                _optyVault: "Address of Vault Contract",
                _rewardToken: "Reward token address",
                _rewardTokenAmount: "reward token amount to harvest",
                _underlyingToken: "Token address acting as underlying Asset for the vault contract",
              },
              returns: {
                _codes:
                  "Array of harvest codes which can be executed to complete the execution of         harvesting of reward token Requirements: - `_rewardTokenAmount` should be greater than 0.",
              },
            },
            "getOptimalTokenAmount(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "uint256", name: "_borrowTokenAmount", type: "uint256" },
              ],
              name: "getOptimalTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Get the optimal amount for the token",
              params: {
                _borrowToken: "Address of token which has to be borrowed",
                _borrowTokenAmount: "amount of token to borrow",
                _underlyingToken: "Token address acting as underlying Asset for the vault contract",
              },
              returns: { _0: "borrow token's optimal amount" },
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardBalanceInUnderlyingTokens(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_rewardToken", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "rewardBalanceInUnderlyingTokens",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Get the underlying token amount equivalent to reward token amount",
              params: {
                _amount: "reward token balance amount",
                _rewardToken: "Reward token address",
                _underlyingToken: "Token address acting as underlying Asset for the vault contract",
              },
              returns: { _0: "equivalent reward token balance in Underlying token value" },
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "uniswapV2Router02()": {
              inputs: [],
              name: "uniswapV2Router02",
              outputs: [{ internalType: "contract IUniswapV2Router02", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Uniswap V2 router contract address",
            },
          },
        },
        "contracts/protocol/configuration/Modifiers.sol:Modifiers": {
          source: "contracts/protocol/configuration/Modifiers.sol",
          name: "Modifiers",
          title: "Modifiers",
          author: "Opty.fi",
          details: "Contract used to keep all the modifiers at one place",
          stateVariables: {
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "stateVariable",
              details: "Registry contract address",
            },
          },
          methods: {
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/configuration/ModifiersController.sol:ModifiersController": {
          source: "contracts/protocol/configuration/ModifiersController.sol",
          name: "ModifiersController",
          title: "ModifiersController",
          author: "Opty.fi",
          details: "Contract used to authorize and keep all the modifiers at one place",
          events: {
            "LogCreditPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogCreditPool",
              type: "event",
            },
            "LogDiscontinueVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "discontinued", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogDiscontinueVault",
              type: "event",
            },
            "LogLiquidityPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPool",
              type: "event",
            },
            "LogLiquidityPoolToDepositToken(address,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "address", name: "adapter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPoolToDepositToken",
              type: "event",
            },
            "LogPauseVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "paused", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogPauseVault",
              type: "event",
            },
            "LogRPPoolRatings(uint256,uint8,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { indexed: !0, internalType: "uint8", name: "upperLimit", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRPPoolRatings",
              type: "event",
            },
            "LogRateCreditPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateCreditPool",
              type: "event",
            },
            "LogRateLiquidityPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateLiquidityPool",
              type: "event",
            },
            "LogRiskProfile(uint256,bool,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "bool", name: "exists", type: "bool" },
                { indexed: !0, internalType: "uint8", name: "steps", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRiskProfile",
              type: "event",
            },
            "LogScoreStrategy(address,bytes32,uint8)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
                { indexed: !0, internalType: "bytes32", name: "hash", type: "bytes32" },
                { indexed: !0, internalType: "uint8", name: "score", type: "uint8" },
              ],
              name: "LogScoreStrategy",
              type: "event",
            },
            "LogToken(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "token", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogToken",
              type: "event",
            },
            "LogTokensToTokensHash(bytes32,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogTokensToTokensHash",
              type: "event",
            },
            "LogUnderlyingAssetHashToRPToVaults(bytes32,string,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "underlyingAssetHash", type: "bytes32" },
                { indexed: !0, internalType: "string", name: "riskProfile", type: "string" },
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogUnderlyingAssetHashToRPToVaults",
              type: "event",
            },
            "TransferMinter(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "minter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferMinter",
              type: "event",
            },
            "TransferOperator(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "operator", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferOperator",
              type: "event",
            },
            "TransferStrategist(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "strategist", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferStrategist",
              type: "event",
            },
            "TransferTreasury(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "treasurer", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferTreasury",
              type: "event",
            },
          },
          methods: {
            "creditPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "creditPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "creaditPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "governance()": {
              inputs: [],
              name: "governance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Governance of optyfi's earn protocol",
            },
            "liquidityPoolToAdapter(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToAdapter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its adapter",
            },
            "liquidityPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Minter for OPTY token",
            },
            "operator()": {
              inputs: [],
              name: "operator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Operator of optyfi's earn protocol",
            },
            "pendingGovernance()": {
              inputs: [],
              name: "pendingGovernance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending governance for optyfi's earn protocol",
            },
            "pendingRegistryImplementation()": {
              inputs: [],
              name: "pendingRegistryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Registry",
            },
            "registryImplementation()": {
              inputs: [],
              name: "registryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Registry",
            },
            "riskProfiles(string)": {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "riskProfiles",
              outputs: [
                { internalType: "uint256", name: "index", type: "uint256" },
                { internalType: "uint8", name: "steps", type: "uint8" },
                { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { internalType: "uint8", name: "upperLimit", type: "uint8" },
                { internalType: "bool", name: "exists", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "riskProfile mapped to its struct `RiskProfile`",
            },
            "riskProfilesArray(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "riskProfilesArray",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the riskProfiles",
            },
            "setMinter(address)": {
              inputs: [{ internalType: "address", name: "_minter", type: "address" }],
              name: "setMinter",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers minter to a new account (`_minter`).",
              params: { _minter: "address of minter's account Requirements: - `msg.sender` Can only be governance." },
            },
            "setOperator(address)": {
              inputs: [{ internalType: "address", name: "_operator", type: "address" }],
              name: "setOperator",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers operator to a new account (`_operator`).",
              params: {
                _operator: "address of Operator's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "setStrategist(address)": {
              inputs: [{ internalType: "address", name: "_strategist", type: "address" }],
              name: "setStrategist",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers strategist to a new account (`_strategist`).",
              params: {
                _strategist: "address of strategist's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "strategist()": {
              inputs: [],
              name: "strategist",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Strategist for this contract",
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "strategyProvider contract address",
            },
            "tokens(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "tokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "token address status which are approved or not",
            },
            "tokensHashIndexes(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "tokensHashIndexes",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the tokenHashes",
            },
            "tokensHashToTokens(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "tokensHashToTokens",
              outputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "token data mapped to token/tokens address/addresses hash",
            },
            "treasury()": {
              inputs: [],
              name: "treasury",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Treasury for this contract",
            },
            "underlyingAssetHashToRPToVaults(bytes32,string)": {
              inputs: [
                { internalType: "bytes32", name: "", type: "bytes32" },
                { internalType: "string", name: "", type: "string" },
              ],
              name: "underlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice:
                "underlying asset (token address's hash) mapped to riskProfile and vault contract         address for keeping track of all the vault contracts",
            },
            "vaultStepInvestStrategyDefinitionRegistry()": {
              inputs: [],
              name: "vaultStepInvestStrategyDefinitionRegistry",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "vaultStepInvestStrategyDefinitionRegistry contract address",
            },
            "vaultToDiscontinued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToDiscontinued",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether discontinued or not",
            },
            "vaultToPaused(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToPaused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether paused or not",
            },
          },
        },
        "contracts/protocol/configuration/PriceOracle.sol:PriceOracle": {
          source: "contracts/protocol/configuration/PriceOracle.sol",
          name: "PriceOracle",
          title: "PriceOracle",
          author: "Opty.fi",
          details: "Bridge to connect the chainlink's price oracle contract",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "getUSDAmountInUnderlyingToken(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getUSDAmountInUnderlyingToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Get the underlying token amount in USD",
              params: {
                _amount: "amount in USD for underlying token",
                _underlyingToken: "address of underlying token",
              },
              returns: { _0: "Returns the latest price" },
            },
            "getUnderlyingTokenAmountInUSD(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getUnderlyingTokenAmountInUSD",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Get the latest price in USD for token",
              params: { _amount: "amount of underlying Token", _underlyingToken: "address of underlying token" },
              returns: { _0: "Returns the latest price" },
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setOracle(address,address)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_oracle", type: "address" },
              ],
              name: "setOracle",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the price feed oracle for the underlying token",
              params: {
                _oracle: "address of price feed oracle for underlying token provided",
                _underlyingToken: "address of underlying token",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` Can only be operator.",
              },
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "underlyingTokenToPriceFeed(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "underlyingTokenToPriceFeed",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/configuration/Registry.sol:Registry": {
          source: "contracts/protocol/configuration/Registry.sol",
          name: "Registry",
          title: "Registry",
          author: "Opty.fi",
          details: "Contract to persit status of tokens,lpTokens,lp/cp and Vaults",
          events: {
            "LogCreditPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogCreditPool",
              type: "event",
            },
            "LogDiscontinueVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "discontinued", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogDiscontinueVault",
              type: "event",
            },
            "LogLiquidityPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPool",
              type: "event",
            },
            "LogLiquidityPoolToDepositToken(address,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "address", name: "adapter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPoolToDepositToken",
              type: "event",
            },
            "LogPauseVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "paused", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogPauseVault",
              type: "event",
            },
            "LogRPPoolRatings(uint256,uint8,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { indexed: !0, internalType: "uint8", name: "upperLimit", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRPPoolRatings",
              type: "event",
            },
            "LogRateCreditPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateCreditPool",
              type: "event",
            },
            "LogRateLiquidityPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateLiquidityPool",
              type: "event",
            },
            "LogRiskProfile(uint256,bool,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "bool", name: "exists", type: "bool" },
                { indexed: !0, internalType: "uint8", name: "steps", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRiskProfile",
              type: "event",
            },
            "LogScoreStrategy(address,bytes32,uint8)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
                { indexed: !0, internalType: "bytes32", name: "hash", type: "bytes32" },
                { indexed: !0, internalType: "uint8", name: "score", type: "uint8" },
              ],
              name: "LogScoreStrategy",
              type: "event",
            },
            "LogToken(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "token", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogToken",
              type: "event",
            },
            "LogTokensToTokensHash(bytes32,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogTokensToTokensHash",
              type: "event",
            },
            "LogUnderlyingAssetHashToRPToVaults(bytes32,string,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "underlyingAssetHash", type: "bytes32" },
                { indexed: !0, internalType: "string", name: "riskProfile", type: "string" },
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogUnderlyingAssetHashToRPToVaults",
              type: "event",
            },
            "TransferMinter(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "minter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferMinter",
              type: "event",
            },
            "TransferOperator(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "operator", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferOperator",
              type: "event",
            },
            "TransferStrategist(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "strategist", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferStrategist",
              type: "event",
            },
            "TransferTreasury(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "treasurer", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferTreasury",
              type: "event",
            },
          },
          methods: {
            "addRiskProfile(string,uint8,(uint8,uint8))": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "uint8", name: "_noOfSteps", type: "uint8" },
                {
                  components: [
                    { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                    { internalType: "uint8", name: "upperLimit", type: "uint8" },
                  ],
                  internalType: "struct DataTypes.PoolRatingsRange",
                  name: "_poolRatingRange",
                  type: "tuple",
                },
              ],
              name: "addRiskProfile",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Add the risk profile in Registry contract Storage      Emit events {LogRiskProfile} and {LogRPPoolRatings}",
              params: {
                _noOfSteps: "No. of permitted corresponding to risk profile provided",
                _poolRatingRange: "pool rating range ([lowerLimit, upperLimit]) supported by given risk profile",
                _riskProfile: "Risk Profile to add in Registry Storage",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` can only be operator - `_riskProfile` can not be empty - `_riskProfile` should not already exists",
              },
            },
            "addRiskProfile(string[],uint8[],(uint8,uint8)[])": {
              inputs: [
                { internalType: "string[]", name: "_riskProfiles", type: "string[]" },
                { internalType: "uint8[]", name: "_noOfSteps", type: "uint8[]" },
                {
                  components: [
                    { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                    { internalType: "uint8", name: "upperLimit", type: "uint8" },
                  ],
                  internalType: "struct DataTypes.PoolRatingsRange[]",
                  name: "_poolRatingRanges",
                  type: "tuple[]",
                },
              ],
              name: "addRiskProfile",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Add list of the risk profiles in Registry contract Storage in 1 txn.      Emit events {LogRiskProfile} and {LogRPPoolRatings}",
              params: {
                _noOfSteps: "List of No. of permitted corresponding to list of risk profile provided",
                _poolRatingRanges:
                  "List of pool rating range ([lowerLimit, upperLimit]) supported by        given list of risk profiles",
                _riskProfiles: "List of Risk Profiles to add in Registry Storage",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` can only be operator - `_riskProfile` can not be empty - `_riskProfile` should not already exists",
              },
            },
            "approveCreditPool(address)": {
              inputs: [{ internalType: "address", name: "_pool", type: "address" }],
              name: "approveCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets `_pool` from the {creditPools} mapping.      Emits a {LogCreditPool} event.",
              params: { _pool: "pool for approval to be considered as creditPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool` cannot be the zero address or an EOA. - `_pool` should not be approved",
              },
            },
            "approveCreditPool(address[])": {
              inputs: [{ internalType: "address[]", name: "_pools", type: "address[]" }],
              name: "approveCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets multiple `_pools` from the {creditPools} mapping.      Emits a {LogCreditPool} event.",
              params: { _pools: "List of pools for approval to be considered as creditPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool` cannot be the zero address or an EOA. - `_pool` should not be approved",
              },
            },
            "approveLiquidityPool(address)": {
              inputs: [{ internalType: "address", name: "_pool", type: "address" }],
              name: "approveLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets `_pool` from the {liquidityPools} mapping.      Emit event {LogLiquidityPool}",
              params: { _pool: "pools (act as liquidity/credit pools) to approve" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Emits a {LogLiquidityPool} event. Requirements: - `msg.sender` should be governance. - `_pools` cannot be the zero address or an EOA. - `_pools` should not be approved",
              },
            },
            "approveLiquidityPool(address[])": {
              inputs: [{ internalType: "address[]", name: "_pools", type: "address[]" }],
              name: "approveLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets multiple `_pools` from the {liquidityPools} mapping.      Emit event {LogLiquidityPool}",
              params: { _pools: "list of pools (act as liquidity/credit pools) to approve" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pools` cannot be the zero address or an EOA. - `_pools` should not be approved",
              },
            },
            "approveToken(address)": {
              inputs: [{ internalType: "address", name: "_token", type: "address" }],
              name: "approveToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets `_token` from the {tokens} mapping.      Emits a {LogToken} event.",
              params: { _token: "token to approve" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `_token` cannot be the zero address or an EOA. - `msg.sender` should be governance. - `_token` should not be approved",
              },
            },
            "approveToken(address[])": {
              inputs: [{ internalType: "address[]", name: "_tokens", type: "address[]" }],
              name: "approveToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets multiple `_tokens` from the {tokens} mapping.      Emits a {LogToken} event.",
              params: { _tokens: "List of tokens to approve" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_token` cannot be the zero address or an EOA. - `_token` should not be approved",
              },
            },
            "become(address)": {
              inputs: [{ internalType: "contract RegistryProxy", name: "_registryProxy", type: "address" }],
              name: "become",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Set RegistryProxy to act as Registry",
              params: {
                _registryProxy:
                  "RegistryProxy Contract address to act as Registry Requirements: - `msg.sender` should be onlyGovernance and same as RegistryProxy",
              },
            },
            "creditPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "creditPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "creaditPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "discontinue(address)": {
              inputs: [{ internalType: "address", name: "_vault", type: "address" }],
              name: "discontinue",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Discontinue the Vault contract from use permanently      Emits a {LogDiscontinueVault} event",
              params: { _vault: "Vault address to discontinue" },
              returns: {
                _0:
                  "A boolean value indicating whether operation is succeeded Requirements: - `_vault` cannot be a zero address - `msg.sender` (caller) should be governance Note: Once Vault contract is disconitnued, then it CAN NOT be re-activated for usage.",
              },
            },
            "getRiskProfiles()": {
              inputs: [],
              name: "getRiskProfiles",
              outputs: [{ internalType: "string[]", name: "", type: "string[]" }],
              stateMutability: "view",
              type: "function",
              details: "Get the list of all the riskProfiles",
              returns: { _0: "Returns the list of all riskProfiles stored in Registry Storage" },
            },
            "getTokenHashes()": {
              inputs: [],
              name: "getTokenHashes",
              outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
              stateMutability: "view",
              type: "function",
              details: "Get the list of tokensHash",
              returns: { _0: "Returns the list of tokensHash." },
            },
            "getTokensHashToTokens(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_tokensHash", type: "bytes32" }],
              name: "getTokensHashToTokens",
              outputs: [{ internalType: "address[]", name: "", type: "address[]" }],
              stateMutability: "view",
              type: "function",
              details: "Get list of token given the `_tokensHash`.",
              returns: { _0: "Returns the list of tokens corresponding to `_tokensHash`." },
            },
            "governance()": {
              inputs: [],
              name: "governance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Governance of optyfi's earn protocol",
            },
            "liquidityPoolToAdapter(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToAdapter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its adapter",
            },
            "liquidityPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Minter for OPTY token",
            },
            "operator()": {
              inputs: [],
              name: "operator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Operator of optyfi's earn protocol",
            },
            "pendingGovernance()": {
              inputs: [],
              name: "pendingGovernance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending governance for optyfi's earn protocol",
            },
            "pendingRegistryImplementation()": {
              inputs: [],
              name: "pendingRegistryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Registry",
            },
            "rateCreditPool(address,uint8)": {
              inputs: [
                { internalType: "address", name: "_pool", type: "address" },
                { internalType: "uint8", name: "_rate", type: "uint8" },
              ],
              name: "rateCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Provide `_rate` to `_pool` from the {creditPools} mapping.      Emits a {LogRateCreditPool} event.",
              params: { _pool: "creditPool to map with its rating", _rate: "rate for the creaditPool provided" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be operator. - `_pool` cannot be the zero address or an EOA. - `_pool` should be approved",
              },
            },
            "rateCreditPool((address,uint8)[])": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "uint8", name: "rate", type: "uint8" },
                  ],
                  internalType: "struct DataTypes.PoolRate[]",
                  name: "_poolRates",
                  type: "tuple[]",
                },
              ],
              name: "rateCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Provide [`_pool`,`_rate`] from the {creditPools} mapping.      Emits a {LogRateCreditPool} event.",
              params: { _poolRates: "List of pool rates (format: [_pool, _rate]) to set for creditPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be operator. - `_pool` cannot be the zero address or an EOA. - `_pool` should be approved",
              },
            },
            "rateLiquidityPool((address,uint8)[])": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "uint8", name: "rate", type: "uint8" },
                  ],
                  internalType: "struct DataTypes.PoolRate[]",
                  name: "_poolRates",
                  type: "tuple[]",
                },
              ],
              name: "rateLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Provide [`_pool`,`_rate`] from the {liquidityPools} mapping.      Emit event {LogRateLiquidityPool}",
              params: { _poolRates: "List of pool rates (format: [_pool, _rate]) to set for liquidityPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be operator. - `_pool` cannot be the zero address or an EOA. - `_pool` should be approved",
              },
            },
            "rateLiquidityPool(address,uint8)": {
              inputs: [
                { internalType: "address", name: "_pool", type: "address" },
                { internalType: "uint8", name: "_rate", type: "uint8" },
              ],
              name: "rateLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Provide `_rate` to `_pool` from the {liquidityPools} mapping.      Emit event {LogRateLiquidityPool}",
              params: { _pool: "liquidityPool to map with its rating", _rate: "rate for the liquidityPool provided" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Emits a {LogRateLiquidityPool} event. Requirements: - `msg.sender` should be operator. - `_pool` cannot be the zero address or an EOA. - `_pool` should be approved",
              },
            },
            "registryImplementation()": {
              inputs: [],
              name: "registryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Registry",
            },
            "removeRiskProfile(uint256)": {
              inputs: [{ internalType: "uint256", name: "_index", type: "uint256" }],
              name: "removeRiskProfile",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Remove the existing risk profile in Registry contract Storage      Emit event {LogRiskProfile}",
              params: { _index: "Index of risk profile to be removed" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` can only be operator - `_riskProfile` can not be empty - `_riskProfile` should not already exists",
              },
            },
            "revokeCreditPool(address[])": {
              inputs: [{ internalType: "address[]", name: "_pools", type: "address[]" }],
              name: "revokeCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Revokes multiple `_pool` from the {revokeCreditPools} mapping.      Emit event {LogCreditPool}",
              params: { _pools: "List of pools for revoking from being used as creditPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool` cannot be the zero address or an EOA. - `_pool` should not be approved",
              },
            },
            "revokeCreditPool(address)": {
              inputs: [{ internalType: "address", name: "_pool", type: "address" }],
              name: "revokeCreditPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Revokes `_pool` from the {creditPools} mapping.      Emits a {LogCreditPool} event.",
              params: { _pool: "pool for revoking from being used as creditPool" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool` cannot be the zero address or an EOA. - `_pool` should not be approved",
              },
            },
            "revokeLiquidityPool(address[])": {
              inputs: [{ internalType: "address[]", name: "_pools", type: "address[]" }],
              name: "revokeLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Revokes multiple `_pools` from the {liquidityPools} mapping.      Emit event {LogLiquidityPool}",
              params: { _pools: "list of pools (act as liquidity/credit pools) to revoke" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pools` cannot be the zero address or an EOA. - `_pools` should not be approved",
              },
            },
            "revokeLiquidityPool(address)": {
              inputs: [{ internalType: "address", name: "_pool", type: "address" }],
              name: "revokeLiquidityPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Revokes `_pool` from the {liquidityPools} mapping.      Emit event {LogLiquidityPool}",
              params: { _pool: "pools (act as liquidity/credit pools) to revoke" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Emits a {LogLiquidityPool} event. Requirements: - `msg.sender` should be governance. - `_pool` cannot be the zero address or an EOA. - `_pool` should not be approved",
              },
            },
            "revokeToken(address)": {
              inputs: [{ internalType: "address", name: "_token", type: "address" }],
              name: "revokeToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Revokes `_token` from the {tokens} mapping.      Emits a {LogToken} event.",
              params: { _token: "token to revoke" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_token` cannot be the zero address or an EOA. - `_token` should be approved",
              },
            },
            "revokeToken(address[])": {
              inputs: [{ internalType: "address[]", name: "_tokens", type: "address[]" }],
              name: "revokeToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Revokes multiple `_tokens` from the {tokens} mapping.      Emits a {LogToken} event.",
              params: { _tokens: "List of tokens to revoke" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_token` cannot be the zero address or an EOA. - `_token` should not be approved",
              },
            },
            "riskProfiles(string)": {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "riskProfiles",
              outputs: [
                { internalType: "uint256", name: "index", type: "uint256" },
                { internalType: "uint8", name: "steps", type: "uint8" },
                { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { internalType: "uint8", name: "upperLimit", type: "uint8" },
                { internalType: "bool", name: "exists", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "riskProfile mapped to its struct `RiskProfile`",
            },
            "riskProfilesArray(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "riskProfilesArray",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the riskProfiles",
            },
            "setLiquidityPoolToAdapter(address,address)": {
              inputs: [
                { internalType: "address", name: "_pool", type: "address" },
                { internalType: "address", name: "_adapter", type: "address" },
              ],
              name: "setLiquidityPoolToAdapter",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets liquidity `_pool` to the protocol adapter `_adapter` from the {liquidityPoolToAdapter} mapping.      Emits a {LogLiquidityPoolToDepositToken} event.",
              params: {
                _adapter: "adapter for the liquidityPool provided",
                _pool: "liquidityPool to map with its adapter",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool`should be approved. - `_adapter` should be contract",
              },
            },
            "setLiquidityPoolToAdapter((address,address)[])": {
              inputs: [
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "adapter", type: "address" },
                  ],
                  internalType: "struct DataTypes.PoolAdapter[]",
                  name: "_poolAdapters",
                  type: "tuple[]",
                },
              ],
              name: "setLiquidityPoolToAdapter",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Maps liquidity `_pool` to the protocol adapter `_adapter` using {liquidityPoolToAdapter}.      Emits a {LogLiquidityPoolToDepositToken} event.",
              params: { _poolAdapters: "List of `[_pool, _adapter]` pairs to set" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be governance. - `_pool`should be approved. - `_adapter` should be contract",
              },
            },
            "setMinter(address)": {
              inputs: [{ internalType: "address", name: "_minter", type: "address" }],
              name: "setMinter",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers minter to a new account (`_minter`).",
              params: { _minter: "address of minter's account Requirements: - `msg.sender` Can only be governance." },
            },
            "setOperator(address)": {
              inputs: [{ internalType: "address", name: "_operator", type: "address" }],
              name: "setOperator",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers operator to a new account (`_operator`).",
              params: {
                _operator: "address of Operator's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "setPause(address,bool)": {
              inputs: [
                { internalType: "address", name: "_vault", type: "address" },
                { internalType: "bool", name: "_paused", type: "bool" },
              ],
              name: "setPause",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Pause tha Vault contract for use temporarily during any emergency      Emits a {LogPauseVault} event",
              params: {
                _paused: "A boolean value `true` to pause vault contract and `false` for un-pause vault contract",
                _vault: "Vault contract address to pause",
              },
              returns: {
                _0:
                  "A boolean value indicating whether pause is set to true or false Requirements: - `_vault` cannot be a zero address - `msg.sender` (caller) should be governance",
              },
            },
            "setStrategist(address)": {
              inputs: [{ internalType: "address", name: "_strategist", type: "address" }],
              name: "setStrategist",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers strategist to a new account (`_strategist`).",
              params: {
                _strategist: "address of strategist's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "setStrategyProvider(address)": {
              inputs: [{ internalType: "address", name: "_strategyProvider", type: "address" }],
              name: "setStrategyProvider",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "set the StrategyProvider contract address.",
              params: { _strategyProvider: "Address of StrategyProvider Contract" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` Can only be governance. - `_strategyProvider` can not be address(0)",
              },
            },
            "setTokensHashToTokens(address[][])": {
              inputs: [{ internalType: "address[][]", name: "_setOfTokens", type: "address[][]" }],
              name: "setTokensHashToTokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets multiple `_tokens` to keccak256 hash the {tokensHashToTokens} mapping.      Emits a {LogSetTokensHashToTokens} event.",
              params: { _setOfTokens: "List of mulitple token addresses to map with their (paired tokens) hashes" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be operator. - `_tokens` should be approved",
              },
            },
            "setTokensHashToTokens(address[])": {
              inputs: [{ internalType: "address[]", name: "_tokens", type: "address[]" }],
              name: "setTokensHashToTokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets `_tokens` to keccak256 hash the {tokensHashToTokens} mapping.      Emits a {LogSetTokensHashToTokens} event.",
              params: { _tokens: "List of token addresses to map with their hashes" },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` should be operator. - `_tokens` should be approved",
              },
            },
            "setTreasury(address)": {
              inputs: [{ internalType: "address", name: "_treasury", type: "address" }],
              name: "setTreasury",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers treasury to a new account (`_treasury`)",
              params: { _treasury: "Treasury account address to hold treasury" },
              returns: {
                _0:
                  "Status of set treasury operation Requirements: - `msg.sender` Can only be governance - `_treasury` can not be address(0)",
              },
            },
            "setUnderlyingAssetHashToRPToVaults(address[][],string[],address[][])": {
              inputs: [
                { internalType: "address[][]", name: "_underlyingAssets", type: "address[][]" },
                { internalType: "string[]", name: "_riskProfiles", type: "string[]" },
                { internalType: "address[][]", name: "_vaults", type: "address[][]" },
              ],
              name: "setUnderlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets bunch of `Vaults`/`LP_vaults` contract for the corresponding `_underlyingAssets`      and `_riskProfiles`in one transaction      Emits a {LogUnderlyingAssetHashToRPToVaults} event",
              params: {
                _riskProfiles: "List of Risk profile mapped to the vault contract",
                _underlyingAssets: "List of paired token addresses to map with the riskProfile and Vault contract",
                _vaults: "List of Vault contract address",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded Requirements: - `msg.sender` (caller) should be operator - `_underlyingAssets` cannot be empty - `_vault` cannot be the zero address or EOA",
              },
            },
            "setUnderlyingAssetHashToRPToVaults(address[],string,address)": {
              inputs: [
                { internalType: "address[]", name: "_underlyingAssets", type: "address[]" },
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "address", name: "_vault", type: "address" },
              ],
              name: "setUnderlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Sets `Vault`/`LM_vault` contract for the corresponding `_underlyingAsset` and `_riskProfile`      Emits a {LogUnderlyingAssetHashToRPToVaults} event",
              params: {
                _riskProfile: "Risk profile mapped to the vault contract",
                _underlyingAssets: "List of token addresses to map with the riskProfile and Vault contract",
                _vault: "Vault contract address",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded Requirements: - `msg.sender` (caller) should be operator - `_underlyingAssets` cannot be empty - `_vault` cannot be the zero address or EOA",
              },
            },
            "setVaultStepInvestStrategyDefinitionRegistry(address)": {
              inputs: [
                { internalType: "address", name: "_vaultStepInvestStrategyDefinitionRegistry", type: "address" },
              ],
              name: "setVaultStepInvestStrategyDefinitionRegistry",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "set the VaultStepInvestStrategyDefinitionRegistry contract address.",
              params: {
                "":
                  "`_vaultStepInvestStrategyDefinitionRegistry` VaultStepInvestStrategyDefinitionRegistry contract address",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` Can only be governance. - `_vaultStepInvestStrategyDefinitionRegistry` can not be address(0)",
              },
            },
            "strategist()": {
              inputs: [],
              name: "strategist",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Strategist for this contract",
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "strategyProvider contract address",
            },
            "tokens(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "tokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "token address status which are approved or not",
            },
            "tokensHashIndexes(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "tokensHashIndexes",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the tokenHashes",
            },
            "tokensHashToTokens(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "tokensHashToTokens",
              outputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "token data mapped to token/tokens address/addresses hash",
            },
            "treasury()": {
              inputs: [],
              name: "treasury",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Treasury for this contract",
            },
            "underlyingAssetHashToRPToVaults(bytes32,string)": {
              inputs: [
                { internalType: "bytes32", name: "", type: "bytes32" },
                { internalType: "string", name: "", type: "string" },
              ],
              name: "underlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice:
                "underlying asset (token address's hash) mapped to riskProfile and vault contract         address for keeping track of all the vault contracts",
            },
            "updateRPPoolRatings(string,(uint8,uint8))": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                {
                  components: [
                    { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                    { internalType: "uint8", name: "upperLimit", type: "uint8" },
                  ],
                  internalType: "struct DataTypes.PoolRatingsRange",
                  name: "_poolRatingRange",
                  type: "tuple",
                },
              ],
              name: "updateRPPoolRatings",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Update the pool ratings for existing risk profile      Emit event {LogRPPoolRatings}",
              params: {
                _poolRatingRange:
                  "pool rating range ([lowerLimit, upperLimit])        to update for given risk profile",
                _riskProfile: "Risk profile to update with pool rating range",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` can only be operator - `_riskProfile` should exists",
              },
            },
            "updateRiskProfileSteps(string,uint8)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "uint8", name: "_noOfSteps", type: "uint8" },
              ],
              name: "updateRiskProfileSteps",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Update the no. of steps for existing risk profile      Emit event {LogRiskProfile}",
              params: {
                _noOfSteps: "No. of steps for a given risk profile",
                _riskProfile: "Risk Profile to update with steps",
              },
              returns: {
                _0:
                  "A boolean value indicating whether the operation succeeded. Requirements: - `msg.sender` can only be operator - `_riskProfile` should exists",
              },
            },
            "vaultStepInvestStrategyDefinitionRegistry()": {
              inputs: [],
              name: "vaultStepInvestStrategyDefinitionRegistry",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "vaultStepInvestStrategyDefinitionRegistry contract address",
            },
            "vaultToDiscontinued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToDiscontinued",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether discontinued or not",
            },
            "vaultToPaused(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToPaused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether paused or not",
            },
          },
        },
        "contracts/protocol/configuration/RegistryProxy.sol:RegistryProxy": {
          source: "contracts/protocol/configuration/RegistryProxy.sol",
          name: "RegistryProxy",
          title: "RegistryProxy",
          author: "Opty.fi",
          details:
            "Storage for the Registry is at this address, while execution is delegated to the `registryImplementation`. Registry should reference this contract as their controller.",
          constructor: { inputs: [], stateMutability: "nonpayable", type: "constructor" },
          fallback: { stateMutability: "payable", type: "fallback" },
          receive: { stateMutability: "payable", type: "receive" },
          events: {
            "LogCreditPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogCreditPool",
              type: "event",
            },
            "LogDiscontinueVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "discontinued", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogDiscontinueVault",
              type: "event",
            },
            "LogLiquidityPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPool",
              type: "event",
            },
            "LogLiquidityPoolToDepositToken(address,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "address", name: "adapter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPoolToDepositToken",
              type: "event",
            },
            "LogPauseVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "paused", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogPauseVault",
              type: "event",
            },
            "LogRPPoolRatings(uint256,uint8,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { indexed: !0, internalType: "uint8", name: "upperLimit", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRPPoolRatings",
              type: "event",
            },
            "LogRateCreditPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateCreditPool",
              type: "event",
            },
            "LogRateLiquidityPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateLiquidityPool",
              type: "event",
            },
            "LogRiskProfile(uint256,bool,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "bool", name: "exists", type: "bool" },
                { indexed: !0, internalType: "uint8", name: "steps", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRiskProfile",
              type: "event",
            },
            "LogScoreStrategy(address,bytes32,uint8)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
                { indexed: !0, internalType: "bytes32", name: "hash", type: "bytes32" },
                { indexed: !0, internalType: "uint8", name: "score", type: "uint8" },
              ],
              name: "LogScoreStrategy",
              type: "event",
            },
            "LogToken(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "token", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogToken",
              type: "event",
            },
            "LogTokensToTokensHash(bytes32,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogTokensToTokensHash",
              type: "event",
            },
            "LogUnderlyingAssetHashToRPToVaults(bytes32,string,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "underlyingAssetHash", type: "bytes32" },
                { indexed: !0, internalType: "string", name: "riskProfile", type: "string" },
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogUnderlyingAssetHashToRPToVaults",
              type: "event",
            },
            "NewGovernance(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldGovernance", type: "address" },
                { indexed: !1, internalType: "address", name: "newGovernance", type: "address" },
              ],
              name: "NewGovernance",
              type: "event",
            },
            "NewImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newImplementation", type: "address" },
              ],
              name: "NewImplementation",
              type: "event",
            },
            "NewPendingGovernance(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldPendingGovernance", type: "address" },
                { indexed: !1, internalType: "address", name: "newPendingGovernance", type: "address" },
              ],
              name: "NewPendingGovernance",
              type: "event",
            },
            "NewPendingImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldPendingImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newPendingImplementation", type: "address" },
              ],
              name: "NewPendingImplementation",
              type: "event",
            },
            "TransferMinter(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "minter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferMinter",
              type: "event",
            },
            "TransferOperator(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "operator", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferOperator",
              type: "event",
            },
            "TransferStrategist(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "strategist", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferStrategist",
              type: "event",
            },
            "TransferTreasury(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "treasurer", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferTreasury",
              type: "event",
            },
          },
          methods: {
            "acceptGovernance()": {
              inputs: [],
              name: "acceptGovernance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Governance function for pending governance to accept role and update Governance",
              notice: "Accepts transfer of Governance rights. msg.sender must be pendingGovernance",
            },
            "acceptImplementation()": {
              inputs: [],
              name: "acceptImplementation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Governance function for new implementation to accept it's role as implementation",
              notice: "Accepts new implementation of registry. msg.sender must be pendingImplementation",
            },
            "creditPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "creditPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "creaditPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "governance()": {
              inputs: [],
              name: "governance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Governance of optyfi's earn protocol",
            },
            "liquidityPoolToAdapter(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToAdapter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its adapter",
            },
            "liquidityPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Minter for OPTY token",
            },
            "operator()": {
              inputs: [],
              name: "operator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Operator of optyfi's earn protocol",
            },
            "pendingGovernance()": {
              inputs: [],
              name: "pendingGovernance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending governance for optyfi's earn protocol",
            },
            "pendingRegistryImplementation()": {
              inputs: [],
              name: "pendingRegistryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Registry",
            },
            "registryImplementation()": {
              inputs: [],
              name: "registryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Registry",
            },
            "riskProfiles(string)": {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "riskProfiles",
              outputs: [
                { internalType: "uint256", name: "index", type: "uint256" },
                { internalType: "uint8", name: "steps", type: "uint8" },
                { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { internalType: "uint8", name: "upperLimit", type: "uint8" },
                { internalType: "bool", name: "exists", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "riskProfile mapped to its struct `RiskProfile`",
            },
            "riskProfilesArray(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "riskProfilesArray",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the riskProfiles",
            },
            "setMinter(address)": {
              inputs: [{ internalType: "address", name: "_minter", type: "address" }],
              name: "setMinter",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers minter to a new account (`_minter`).",
              params: { _minter: "address of minter's account Requirements: - `msg.sender` Can only be governance." },
            },
            "setOperator(address)": {
              inputs: [{ internalType: "address", name: "_operator", type: "address" }],
              name: "setOperator",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers operator to a new account (`_operator`).",
              params: {
                _operator: "address of Operator's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "setPendingGovernance(address)": {
              inputs: [{ internalType: "address", name: "newPendingGovernance", type: "address" }],
              name: "setPendingGovernance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Governance function to begin change of governance.      The newPendingGovernance must call `acceptGovernance`      to finalize the transfer.",
              params: { newPendingGovernance: "New pending governance." },
              notice:
                "Begins transfer of governance rights.         The newPendingGovernance must call `acceptGovernance`         to finalize the transfer.",
            },
            "setPendingImplementation(address)": {
              inputs: [{ internalType: "address", name: "newPendingImplementation", type: "address" }],
              name: "setPendingImplementation",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Set the registry contract as pending implementation initally",
              params: {
                newPendingImplementation: "registry contract address to act as pending        implementation initally",
              },
            },
            "setStrategist(address)": {
              inputs: [{ internalType: "address", name: "_strategist", type: "address" }],
              name: "setStrategist",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Transfers strategist to a new account (`_strategist`).",
              params: {
                _strategist: "address of strategist's account Requirements: - `msg.sender` Can only be governance.",
              },
            },
            "strategist()": {
              inputs: [],
              name: "strategist",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Strategist for this contract",
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "strategyProvider contract address",
            },
            "tokens(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "tokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "token address status which are approved or not",
            },
            "tokensHashIndexes(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "tokensHashIndexes",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the tokenHashes",
            },
            "tokensHashToTokens(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "tokensHashToTokens",
              outputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "token data mapped to token/tokens address/addresses hash",
            },
            "treasury()": {
              inputs: [],
              name: "treasury",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Treasury for this contract",
            },
            "underlyingAssetHashToRPToVaults(bytes32,string)": {
              inputs: [
                { internalType: "bytes32", name: "", type: "bytes32" },
                { internalType: "string", name: "", type: "string" },
              ],
              name: "underlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice:
                "underlying asset (token address's hash) mapped to riskProfile and vault contract         address for keeping track of all the vault contracts",
            },
            "vaultStepInvestStrategyDefinitionRegistry()": {
              inputs: [],
              name: "vaultStepInvestStrategyDefinitionRegistry",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "vaultStepInvestStrategyDefinitionRegistry contract address",
            },
            "vaultToDiscontinued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToDiscontinued",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether discontinued or not",
            },
            "vaultToPaused(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToPaused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether paused or not",
            },
          },
        },
        "contracts/protocol/configuration/RegistryStorage.sol:RegistryAdminStorage": {
          source: "contracts/protocol/configuration/RegistryStorage.sol",
          name: "RegistryAdminStorage",
          title: "RegistryAdminStorage",
          author: "Opty.fi",
          details: "Contract used to store registry's admin account",
          events: {
            "TransferMinter(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "minter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferMinter",
              type: "event",
            },
            "TransferOperator(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "operator", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferOperator",
              type: "event",
            },
            "TransferStrategist(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "strategist", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferStrategist",
              type: "event",
            },
            "TransferTreasury(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "treasurer", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferTreasury",
              type: "event",
            },
          },
          methods: {
            "governance()": {
              inputs: [],
              name: "governance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Governance of optyfi's earn protocol",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Minter for OPTY token",
            },
            "operator()": {
              inputs: [],
              name: "operator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Operator of optyfi's earn protocol",
            },
            "pendingGovernance()": {
              inputs: [],
              name: "pendingGovernance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending governance for optyfi's earn protocol",
            },
            "pendingRegistryImplementation()": {
              inputs: [],
              name: "pendingRegistryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Registry",
            },
            "registryImplementation()": {
              inputs: [],
              name: "registryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Registry",
            },
            "strategist()": {
              inputs: [],
              name: "strategist",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Strategist for this contract",
            },
            "treasury()": {
              inputs: [],
              name: "treasury",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Treasury for this contract",
            },
          },
        },
        "contracts/protocol/configuration/RegistryStorage.sol:RegistryStorage": {
          source: "contracts/protocol/configuration/RegistryStorage.sol",
          name: "RegistryStorage",
          title: "RegistryStorage",
          author: "Opty.fi",
          details: "Contract used to store registry's contract state variables and events",
          events: {
            "LogCreditPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogCreditPool",
              type: "event",
            },
            "LogDiscontinueVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "discontinued", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogDiscontinueVault",
              type: "event",
            },
            "LogLiquidityPool(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPool",
              type: "event",
            },
            "LogLiquidityPoolToDepositToken(address,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "address", name: "adapter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogLiquidityPoolToDepositToken",
              type: "event",
            },
            "LogPauseVault(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !0, internalType: "bool", name: "paused", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogPauseVault",
              type: "event",
            },
            "LogRPPoolRatings(uint256,uint8,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { indexed: !0, internalType: "uint8", name: "upperLimit", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRPPoolRatings",
              type: "event",
            },
            "LogRateCreditPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateCreditPool",
              type: "event",
            },
            "LogRateLiquidityPool(address,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "pool", type: "address" },
                { indexed: !0, internalType: "uint8", name: "rate", type: "uint8" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRateLiquidityPool",
              type: "event",
            },
            "LogRiskProfile(uint256,bool,uint8,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "bool", name: "exists", type: "bool" },
                { indexed: !0, internalType: "uint8", name: "steps", type: "uint8" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogRiskProfile",
              type: "event",
            },
            "LogScoreStrategy(address,bytes32,uint8)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
                { indexed: !0, internalType: "bytes32", name: "hash", type: "bytes32" },
                { indexed: !0, internalType: "uint8", name: "score", type: "uint8" },
              ],
              name: "LogScoreStrategy",
              type: "event",
            },
            "LogToken(address,bool,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "token", type: "address" },
                { indexed: !0, internalType: "bool", name: "enabled", type: "bool" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogToken",
              type: "event",
            },
            "LogTokensToTokensHash(bytes32,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogTokensToTokensHash",
              type: "event",
            },
            "LogUnderlyingAssetHashToRPToVaults(bytes32,string,address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "underlyingAssetHash", type: "bytes32" },
                { indexed: !0, internalType: "string", name: "riskProfile", type: "string" },
                { indexed: !0, internalType: "address", name: "vault", type: "address" },
                { indexed: !1, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogUnderlyingAssetHashToRPToVaults",
              type: "event",
            },
            "TransferMinter(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "minter", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferMinter",
              type: "event",
            },
            "TransferOperator(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "operator", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferOperator",
              type: "event",
            },
            "TransferStrategist(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "strategist", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferStrategist",
              type: "event",
            },
            "TransferTreasury(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "treasurer", type: "address" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "TransferTreasury",
              type: "event",
            },
          },
          methods: {
            "creditPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "creditPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "creaditPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "governance()": {
              inputs: [],
              name: "governance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Governance of optyfi's earn protocol",
            },
            "liquidityPoolToAdapter(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToAdapter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its adapter",
            },
            "liquidityPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPools",
              outputs: [
                { internalType: "uint8", name: "rating", type: "uint8" },
                { internalType: "bool", name: "isLiquidityPool", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "liquidityPool address mapped to its struct having `pool`, `outputToken`, `isBorrow`",
            },
            "minter()": {
              inputs: [],
              name: "minter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Minter for OPTY token",
            },
            "operator()": {
              inputs: [],
              name: "operator",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Operator of optyfi's earn protocol",
            },
            "pendingGovernance()": {
              inputs: [],
              name: "pendingGovernance",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending governance for optyfi's earn protocol",
            },
            "pendingRegistryImplementation()": {
              inputs: [],
              name: "pendingRegistryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Registry",
            },
            "registryImplementation()": {
              inputs: [],
              name: "registryImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Registry",
            },
            "riskProfiles(string)": {
              inputs: [{ internalType: "string", name: "", type: "string" }],
              name: "riskProfiles",
              outputs: [
                { internalType: "uint256", name: "index", type: "uint256" },
                { internalType: "uint8", name: "steps", type: "uint8" },
                { internalType: "uint8", name: "lowerLimit", type: "uint8" },
                { internalType: "uint8", name: "upperLimit", type: "uint8" },
                { internalType: "bool", name: "exists", type: "bool" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "riskProfile mapped to its struct `RiskProfile`",
            },
            "riskProfilesArray(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "riskProfilesArray",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the riskProfiles",
            },
            "strategist()": {
              inputs: [],
              name: "strategist",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Strategist for this contract",
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "strategyProvider contract address",
            },
            "tokens(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "tokens",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "token address status which are approved or not",
            },
            "tokensHashIndexes(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "tokensHashIndexes",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "List of all the tokenHashes",
            },
            "tokensHashToTokens(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "tokensHashToTokens",
              outputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "token data mapped to token/tokens address/addresses hash",
            },
            "treasury()": {
              inputs: [],
              name: "treasury",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Treasury for this contract",
            },
            "underlyingAssetHashToRPToVaults(bytes32,string)": {
              inputs: [
                { internalType: "bytes32", name: "", type: "bytes32" },
                { internalType: "string", name: "", type: "string" },
              ],
              name: "underlyingAssetHashToRPToVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice:
                "underlying asset (token address's hash) mapped to riskProfile and vault contract         address for keeping track of all the vault contracts",
            },
            "vaultStepInvestStrategyDefinitionRegistry()": {
              inputs: [],
              name: "vaultStepInvestStrategyDefinitionRegistry",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "vaultStepInvestStrategyDefinitionRegistry contract address",
            },
            "vaultToDiscontinued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToDiscontinued",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether discontinued or not",
            },
            "vaultToPaused(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "vaultToPaused",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "vault contract address mapped to boolean whether paused or not",
            },
          },
        },
        "contracts/protocol/configuration/RiskManager.sol:RiskManager": {
          source: "contracts/protocol/configuration/RiskManager.sol",
          name: "RiskManager",
          title: "RiskManager",
          author: "Opty.fi",
          details: "An extra protection for the best strategy of the opty-fi vault's      underlying token",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "Zero bytes32 type Constant",
            },
            "become(address)": {
              inputs: [{ internalType: "contract RiskManagerProxy", name: "_riskManagerProxy", type: "address" }],
              name: "become",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Set RiskManagerProxy to act as RiskManager",
              params: {
                _riskManagerProxy:
                  "RiskManagerProxy contract address to act as RiskManager  Requirements: - `msg.sender` can only be Governance",
              },
            },
            "getBestStrategy(string,address[])": {
              inputs: [
                { internalType: "string", name: "_profile", type: "string" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
              ],
              name: "getBestStrategy",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              details: "Get the best strategy for respective RiskProfiles",
              params: {
                _profile: "risk profile corresponding to which get the best strategy",
                _underlyingTokens: "array of underlying token addresses",
              },
              returns: {
                _0:
                  'Returns the hash of the best strategy corresponding to the riskProfile provided Requirements: - `_profile` can be among these values ["RP1"/"RP2"/"RP3"] or as decided by governance      - Can not be empty - `_underlyingTokens` is an array of underlying tokens like dai, usdc and so forth      - Can not have length 0',
              },
            },
            "getVaultRewardTokenStrategy(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_vaultRewardTokenHash", type: "bytes32" }],
              name: "getVaultRewardTokenStrategy",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "_vaultRewardStrategy",
                  type: "tuple",
                },
              ],
              stateMutability: "view",
              type: "function",
              details: "Get the VaultRewardToken strategy for respective VaultRewardToken hash",
              params: { _vaultRewardTokenHash: "Hash of vault contract and reward token address" },
              returns: {
                _vaultRewardStrategy:
                  "Returns the the VaultRewardToken strategy corresponding          to the `_vaultRewardTokenHash` provided Requirements: - `_vaultRewardTokenHash` is the hash of Vault and RewardToken addresses      - Can not be empty",
              },
            },
            "pendingRiskManagerImplementation()": {
              inputs: [],
              name: "pendingRiskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Risk Manager",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "riskManagerImplementation()": {
              inputs: [],
              name: "riskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Risk Manager",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "contract StrategyProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "StrategyProvider contract address",
            },
          },
        },
        "contracts/protocol/configuration/RiskManagerProxy.sol:RiskManagerProxy": {
          source: "contracts/protocol/configuration/RiskManagerProxy.sol",
          name: "RiskManagerProxy",
          title: "RiskManagerProxy",
          author: "Opty.fi",
          details:
            "Storage for the RiskManager is at this address, while execution is delegated to the      `riskManagerImplementation`. RiskManager should reference this contract as their controller.",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          fallback: { stateMutability: "payable", type: "fallback" },
          receive: { stateMutability: "payable", type: "receive" },
          events: {
            "NewImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newImplementation", type: "address" },
              ],
              name: "NewImplementation",
              type: "event",
            },
            "NewPendingImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldPendingImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newPendingImplementation", type: "address" },
              ],
              name: "NewPendingImplementation",
              type: "event",
            },
          },
          methods: {
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "Zero bytes32 type Constant",
            },
            "acceptImplementation()": {
              inputs: [],
              name: "acceptImplementation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Governance function for new implementation to accept it's role as implementation",
              notice: "Accepts new implementation of riskManager. msg.sender must be pendingImplementation",
            },
            "pendingRiskManagerImplementation()": {
              inputs: [],
              name: "pendingRiskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Risk Manager",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "riskManagerImplementation()": {
              inputs: [],
              name: "riskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Risk Manager",
            },
            "setPendingImplementation(address)": {
              inputs: [{ internalType: "address", name: "newPendingImplementation", type: "address" }],
              name: "setPendingImplementation",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Set the riskManager contract as pending implementation initally",
              params: {
                newPendingImplementation:
                  "riskManager contract address to act as pending        implementation initally",
              },
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "contract StrategyProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "StrategyProvider contract address",
            },
          },
        },
        "contracts/protocol/configuration/RiskManagerStorage.sol:RiskManagerStorage": {
          source: "contracts/protocol/configuration/RiskManagerStorage.sol",
          name: "RiskManagerStorage",
          title: "RiskManagerStorage",
          author: "Opty.fi",
          details: "Contract to store the state variables of the      RiskManager",
          methods: {
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "Zero bytes32 type Constant",
            },
            "pendingRiskManagerImplementation()": {
              inputs: [],
              name: "pendingRiskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Risk Manager",
            },
            "riskManagerImplementation()": {
              inputs: [],
              name: "riskManagerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Risk Manager",
            },
            "strategyProvider()": {
              inputs: [],
              name: "strategyProvider",
              outputs: [{ internalType: "contract StrategyProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "StrategyProvider contract address",
            },
          },
        },
        "contracts/protocol/configuration/StrategyManager.sol:StrategyManager": {
          source: "contracts/protocol/configuration/StrategyManager.sol",
          name: "StrategyManager",
          title: "StrategyManager",
          author: "Opty.fi",
          details: "Central processing unit of the earn protocol",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
              notice: "Zero bytes32 type Constant",
            },
            "getBalanceInUnderlyingToken(address,address,bytes32)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "bytes32", name: "_hash", type: "bytes32" },
              ],
              name: "getBalanceInUnderlyingToken",
              outputs: [{ internalType: "uint256", name: "_balance", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardStepsCount(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getClaimRewardStepsCount",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllStepCount(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getDepositAllStepCount",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestRewardStepsCount(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getHarvestRewardStepsCount",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "getLpAdapterRewardToken(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_investStrategyHash", type: "bytes32" }],
              name: "getLpAdapterRewardToken",
              outputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_optyAdapter", type: "address" },
                { internalType: "address", name: "_rewardToken", type: "address" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "getPoolClaimAllRewardCodes(address,bytes32,uint8,uint8)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "bytes32", name: "_hash", type: "bytes32" },
                { internalType: "uint8", name: "_stepIndex", type: "uint8" },
                { internalType: "uint8", name: "_stepCount", type: "uint8" },
              ],
              name: "getPoolClaimAllRewardCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolDepositAllCodes(address,address,bytes32,uint8,uint8)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "bytes32", name: "_hash", type: "bytes32" },
                { internalType: "uint8", name: "_stepIndex", type: "uint8" },
                { internalType: "uint8", name: "_stepCount", type: "uint8" },
              ],
              name: "getPoolDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolHarvestAllRewardCodes(address,address,bytes32,uint8,uint8)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "bytes32", name: "_investStrategyHash", type: "bytes32" },
                { internalType: "uint8", name: "_stepIndex", type: "uint8" },
                { internalType: "uint8", name: "_stepCount", type: "uint8" },
              ],
              name: "getPoolHarvestAllRewardCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolHarvestSomeRewardCodes(address,address,bytes32,uint256,uint8,uint8)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "bytes32", name: "_investStrategyHash", type: "bytes32" },
                { internalType: "uint256", name: "_convertRewardTokensPercent", type: "uint256" },
                { internalType: "uint8", name: "_stepIndex", type: "uint8" },
                { internalType: "uint8", name: "_stepCount", type: "uint8" },
              ],
              name: "getPoolHarvestSomeRewardCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolWithdrawAllCodes(address,address,bytes32,uint8,uint8)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "bytes32", name: "_hash", type: "bytes32" },
                { internalType: "uint8", name: "_stepIndex", type: "uint8" },
                { internalType: "uint8", name: "_stepCount", type: "uint8" },
              ],
              name: "getPoolWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllStepsCount(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getWithdrawAllStepsCount",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "HarvestCodeProvider contract address",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/configuration/StrategyProvider.sol:StrategyProvider": {
          source: "contracts/protocol/configuration/StrategyProvider.sol",
          name: "StrategyProvider",
          details: "Serves as an oracle service of opty-fi's earn protocol      for best strategy",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rpToTokenToBestStrategy(string,bytes32)": {
              inputs: [
                { internalType: "string", name: "", type: "string" },
                { internalType: "bytes32", name: "", type: "bytes32" },
              ],
              name: "rpToTokenToBestStrategy",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "rpToTokenToDefaultStrategy(string,bytes32)": {
              inputs: [
                { internalType: "string", name: "", type: "string" },
                { internalType: "bytes32", name: "", type: "bytes32" },
              ],
              name: "rpToTokenToDefaultStrategy",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "setBestDefaultStrategy(string,bytes32,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
                { internalType: "bytes32", name: "_strategyHash", type: "bytes32" },
              ],
              name: "setBestDefaultStrategy",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setBestStrategy(string,bytes32,bytes32)": {
              inputs: [
                { internalType: "string", name: "_riskProfile", type: "string" },
                { internalType: "bytes32", name: "_tokenHash", type: "bytes32" },
                { internalType: "bytes32", name: "_strategyHash", type: "bytes32" },
              ],
              name: "setBestStrategy",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setVaultRewardStrategy(bytes32,(uint256,uint256))": {
              inputs: [
                { internalType: "bytes32", name: "_vaultRewardTokenHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "_vaultRewardStrategy",
                  type: "tuple",
                },
              ],
              name: "setVaultRewardStrategy",
              outputs: [
                {
                  components: [
                    { internalType: "uint256", name: "hold", type: "uint256" },
                    { internalType: "uint256", name: "convert", type: "uint256" },
                  ],
                  internalType: "struct DataTypes.VaultRewardStrategy",
                  name: "",
                  type: "tuple",
                },
              ],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign strategy in form of `_vaultRewardStrategy` to the `_vaultRewardTokenHash`. Returns a vaultRewardStrategy hash value indicating successful operation. Emits a {LogSetVaultRewardStrategy} event. Requirements: - msg.sender should be operator. - `hold` in {_vaultRewardStrategy} shoould be greater than 0 and should be in `basis` format.      For eg: If hold is 50%, then it's basis will be 5000, Similarly, if it 20%, then it's basis is 2000. - `convert` in {_vaultRewardStrategy} should be approved      For eg: If convert is 50%, then it's basis will be 5000, Similarly, if it 20%, then it's basis is 2000.",
            },
            "vaultRewardTokenHashToVaultRewardTokenStrategy(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "vaultRewardTokenHashToVaultRewardTokenStrategy",
              outputs: [
                { internalType: "uint256", name: "hold", type: "uint256" },
                { internalType: "uint256", name: "convert", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/configuration/VaultStepInvestStrategyDefinitionRegistry.sol:VaultStepInvestStrategyDefinitionRegistry": {
          source: "contracts/protocol/configuration/VaultStepInvestStrategyDefinitionRegistry.sol",
          name: "VaultStepInvestStrategyDefinitionRegistry",
          title: "VaultStepInvestStrategyDefinitionRegistry",
          author: "Opty.fi",
          details: "Contract to persist vault's step invest strategy definition",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "LogSetVaultInvestStrategy(bytes32,bytes32,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "bytes32", name: "tokensHash", type: "bytes32" },
                { indexed: !0, internalType: "bytes32", name: "hash", type: "bytes32" },
                { indexed: !0, internalType: "address", name: "caller", type: "address" },
              ],
              name: "LogSetVaultInvestStrategy",
              type: "event",
            },
          },
          methods: {
            "getStrategy(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_hash", type: "bytes32" }],
              name: "getStrategy",
              outputs: [
                { internalType: "uint256", name: "_index", type: "uint256" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[]",
                  name: "_strategySteps",
                  type: "tuple[]",
                },
              ],
              stateMutability: "view",
              type: "function",
              details: "Returns the Strategy by `_hash`.",
            },
            "getTokenToStrategies(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_tokensHash", type: "bytes32" }],
              name: "getTokenToStrategies",
              outputs: [{ internalType: "bytes32[]", name: "", type: "bytes32[]" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the list of strategy hashes by `_token`.",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setStrategy(bytes32,(address,address,bool)[][])": {
              inputs: [
                { internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[][]",
                  name: "_strategySteps",
                  type: "tuple[][]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign multiple strategies in form of `_strategySteps` to the `_tokensHash`. Emits a {LogSetVaultInvestStrategy} event per successful assignment of the strategy. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
            "setStrategy(bytes32,(address,address,bool)[])": {
              inputs: [
                { internalType: "bytes32", name: "_tokensHash", type: "bytes32" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[]",
                  name: "_strategySteps",
                  type: "tuple[]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign strategy in form of `_strategySteps` to the `_tokensHash`. Returns true indicating successful operation. Emits a {LogSetVaultInvestStrategy} event. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
            "setStrategy(bytes32[],(address,address,bool)[][])": {
              inputs: [
                { internalType: "bytes32[]", name: "_tokensHash", type: "bytes32[]" },
                {
                  components: [
                    { internalType: "address", name: "pool", type: "address" },
                    { internalType: "address", name: "outputToken", type: "address" },
                    { internalType: "bool", name: "isBorrow", type: "bool" },
                  ],
                  internalType: "struct DataTypes.StrategyStep[][]",
                  name: "_strategySteps",
                  type: "tuple[][]",
                },
              ],
              name: "setStrategy",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "assign multiple strategies in form of `_strategySteps` to multiple tokens in form of `_tokensHash`. Emits a {LogSetVaultInvestStrategy} event per successful assignment of the strategy. Requirements: - msg.sender should be operator. - `creditPool` and `borrowToken` in {_strategySteps}can be zero address simultaneously only - `token`, `liquidityPool` and `strategyContract` cannot be zero address or EOA.",
            },
            "strategies(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              name: "strategies",
              outputs: [{ internalType: "uint256", name: "index", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "strategyHashIndexes(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "strategyHashIndexes",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "tokenToStrategies(bytes32,uint256)": {
              inputs: [
                { internalType: "bytes32", name: "", type: "bytes32" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "tokenToStrategies",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/aave/AaveV1Adapter.sol:AaveV1Adapter": {
          source: "contracts/protocol/defiAdapters/aave/AaveV1Adapter.sol",
          name: "AaveV1Adapter",
          details: "Abstraction layer to Aave V1's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_underlyingTokenAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenBalance", type: "uint256" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPoolToken", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProvider", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "healthFactor()": {
              inputs: [],
              name: "healthFactor",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "ltv()": {
              inputs: [],
              name: "ltv",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "max()": {
              inputs: [],
              name: "max",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/aave/AaveV2Adapter.sol:AaveV2Adapter": {
          source: "contracts/protocol/defiAdapters/aave/AaveV2Adapter.sol",
          name: "AaveV2Adapter",
          details: "Abstraction layer to Aave V2's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "PROTOCOL_DATA_PROVIDER_ID()": {
              inputs: [],
              name: "PROTOCOL_DATA_PROVIDER_ID",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_underlyingTokenAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "address", name: "_outputToken", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenBalance", type: "uint256" },
                { internalType: "address", name: "_borrowToken", type: "address" },
                { internalType: "uint256", name: "_borrowAmount", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPoolToken", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "healthFactor()": {
              inputs: [],
              name: "healthFactor",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPoolAddressProviderRegistry", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "ltv()": {
              inputs: [],
              name: "ltv",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "max()": {
              inputs: [],
              name: "max",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/compound/CompoundAdapter.sol:CompoundAdapter": {
          source: "contracts/protocol/defiAdapters/compound/CompoundAdapter.sol",
          name: "CompoundAdapter",
          details: "Abstraction layer to Compound's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "WETH()": {
              inputs: [],
              name: "WETH",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "comptroller()": {
              inputs: [],
              name: "comptroller",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardToken()": {
              inputs: [],
              name: "rewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setComptroller(address)": {
              inputs: [{ internalType: "address", name: "_comptroller", type: "address" }],
              name: "setComptroller",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_rewardToken", type: "address" }],
              name: "setRewardToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/cream/CreamAdapter.sol:CreamAdapter": {
          source: "contracts/protocol/defiAdapters/cream/CreamAdapter.sol",
          name: "CreamAdapter",
          details: "Abstraction layer to Cream's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "HBTC()": {
              inputs: [],
              name: "HBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "comptroller()": {
              inputs: [],
              name: "comptroller",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardToken()": {
              inputs: [],
              name: "rewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setComptroller(address)": {
              inputs: [{ internalType: "address", name: "_comptroller", type: "address" }],
              name: "setComptroller",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_rewardToken", type: "address" }],
              name: "setRewardToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/curve/CurvePoolAdapter.sol:CurvePoolAdapter": {
          source: "contracts/protocol/defiAdapters/curve/CurvePoolAdapter.sol",
          name: "CurvePoolAdapter",
          details: "Abstraction layer to Curve's deposit pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
              { internalType: "address", name: "_oracle", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "BUSD()": {
              inputs: [],
              name: "BUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "BUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "BUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "BUSD_GAUGE()": {
              inputs: [],
              name: "BUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "BUSD_SWAP_POOL()": {
              inputs: [],
              name: "BUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "COMPOUND_DEPOSIT_POOL()": {
              inputs: [],
              name: "COMPOUND_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "COMPOUND_GAUGE()": {
              inputs: [],
              name: "COMPOUND_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "COMPOUND_SWAP_POOL()": {
              inputs: [],
              name: "COMPOUND_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DAI()": {
              inputs: [],
              name: "DAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD()": {
              inputs: [],
              name: "DUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "DUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD_GAUGE()": {
              inputs: [],
              name: "DUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD_SWAP_POOL()": {
              inputs: [],
              name: "DUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD()": {
              inputs: [],
              name: "GUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "GUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD_GAUGE()": {
              inputs: [],
              name: "GUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD_SWAP_POOL()": {
              inputs: [],
              name: "GUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HBTC()": {
              inputs: [],
              name: "HBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HBTC_SWAP_POOL()": {
              inputs: [],
              name: "HBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD()": {
              inputs: [],
              name: "HUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "HUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD_GAUGE()": {
              inputs: [],
              name: "HUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD_SWAP_POOL()": {
              inputs: [],
              name: "HUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD()": {
              inputs: [],
              name: "LINKUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "LINKUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD_SWAP_POOL()": {
              inputs: [],
              name: "LINKUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD()": {
              inputs: [],
              name: "MUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "MUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD_GAUGE()": {
              inputs: [],
              name: "MUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD_SWAP_POOL()": {
              inputs: [],
              name: "MUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX()": {
              inputs: [],
              name: "PAX",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX_DEPOSIT_POOL()": {
              inputs: [],
              name: "PAX_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX_GAUGE()": {
              inputs: [],
              name: "PAX_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX_SWAP_POOL()": {
              inputs: [],
              name: "PAX_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "REN_SWAP_POOL()": {
              inputs: [],
              name: "REN_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV()": {
              inputs: [],
              name: "RSV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV_DEPOSIT_POOL()": {
              inputs: [],
              name: "RSV_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV_GAUGE()": {
              inputs: [],
              name: "RSV_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV_SWAP_POOL()": {
              inputs: [],
              name: "RSV_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SBTC_SWAP_POOL()": {
              inputs: [],
              name: "SBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD()": {
              inputs: [],
              name: "SUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "SUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD_GAUGE()": {
              inputs: [],
              name: "SUSD_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD_SWAP_POOL()": {
              inputs: [],
              name: "SUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC()": {
              inputs: [],
              name: "TBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_DEPOSIT_POOL()": {
              inputs: [],
              name: "TBTC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_GAUGE()": {
              inputs: [],
              name: "TBTC_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_SWAP_POOL()": {
              inputs: [],
              name: "TBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "THREE_SWAP_POOL()": {
              inputs: [],
              name: "THREE_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TUSD()": {
              inputs: [],
              name: "TUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDC()": {
              inputs: [],
              name: "USDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK()": {
              inputs: [],
              name: "USDK",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK_DEPOSIT_POOL()": {
              inputs: [],
              name: "USDK_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK_GAUGE()": {
              inputs: [],
              name: "USDK_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK_SWAP_POOL()": {
              inputs: [],
              name: "USDK_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN()": {
              inputs: [],
              name: "USDN",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN_DEPOSIT_POOL()": {
              inputs: [],
              name: "USDN_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN_GAUGE()": {
              inputs: [],
              name: "USDN_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN_SWAP_POOL()": {
              inputs: [],
              name: "USDN_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT()": {
              inputs: [],
              name: "USDT",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_DEPOSIT_POOL()": {
              inputs: [],
              name: "USDT_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_GAUGE()": {
              inputs: [],
              name: "USDT_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_SWAP_POOL()": {
              inputs: [],
              name: "USDT_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "Y_DEPOSIT_POOL()": {
              inputs: [],
              name: "Y_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "Y_GAUGE()": {
              inputs: [],
              name: "Y_GAUGE",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "Y_SWAP_POOL()": {
              inputs: [],
              name: "Y_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_holder", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken in staking pool(gauge)",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Calls the appropriate deploy function depending on N_COINS ",
              params: {
                _amounts: "Quantity of _underlyingToken to deposit",
                _liquidityPool: "Address of the pool deposit (or swap, in some cases) contract",
              },
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getMinter(address)": {
              inputs: [{ internalType: "address", name: "_gauge", type: "address" }],
              name: "getMinter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_stakeAmount", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_unstakeAmount", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Swaps _amount of _liquidityPoolToken for _underlyingToken",
              params: {
                _amount: "Quantity of _liquidityPoolToken to swap for _underlyingToken",
                _liquidityPool: "Address of the token that represents users' holdings in the pool",
              },
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToGauges(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToGauges",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToSwap(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToSwap",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToUnderlyingTokens(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "liquidityPoolToUnderlyingTokens",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit2Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit2Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit3Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit3Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit4Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit4Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "oracleContract()": {
              inputs: [],
              name: "oracleContract",
              outputs: [{ internalType: "contract PriceOracle", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquidityPoolToSwap(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_swapPool", type: "address" },
              ],
              name: "setLiquidityPoolToSwap",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquidityPoolToUnderlyingTokens(address,address[])": {
              inputs: [
                { internalType: "address", name: "_lendingPool", type: "address" },
                { internalType: "address[]", name: "_tokens", type: "address[]" },
              ],
              name: "setLiquidityPoolToUnderlyingTokens",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquiidtyPoolToGauges(address,address)": {
              inputs: [
                { internalType: "address", name: "_pool", type: "address" },
                { internalType: "address", name: "_gauge", type: "address" },
              ],
              name: "setLiquiidtyPoolToGauges",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit2Amount(address,uint256[2])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[2]", name: "_maxDepositAmount", type: "uint256[2]" },
              ],
              name: "setMaxDeposit2Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit3Amount(address,uint256[3])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[3]", name: "_maxDepositAmount", type: "uint256[3]" },
              ],
              name: "setMaxDeposit3Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit4Amount(address,uint256[4])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[4]", name: "_maxDepositAmount", type: "uint256[4]" },
              ],
              name: "setMaxDeposit4Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256[4])": {
              inputs: [{ internalType: "uint256[4]", name: "_maxDepositAmountDefault", type: "uint256[4]" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOracle(address)": {
              inputs: [{ internalType: "address", name: "_oracle", type: "address" }],
              name: "setOracle",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/curve/CurveSwapAdapter.sol:CurveSwapAdapter": {
          source: "contracts/protocol/defiAdapters/curve/CurveSwapAdapter.sol",
          name: "CurveSwapAdapter",
          details: "Abstraction layer to Curve's swap pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "BUSD_SWAP_POOL()": {
              inputs: [],
              name: "BUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CDAI()": {
              inputs: [],
              name: "CDAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CDAI_CUSDC()": {
              inputs: [],
              name: "CDAI_CUSDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CDAI_CUSD_CUSDT()": {
              inputs: [],
              name: "CDAI_CUSD_CUSDT",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "COMPOUND_SWAP_POOL()": {
              inputs: [],
              name: "COMPOUND_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CRV_PLAIN_3_AND_SUSD()": {
              inputs: [],
              name: "CRV_PLAIN_3_AND_SUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CRV_REN_BTC_WBTC_SBTC()": {
              inputs: [],
              name: "CRV_REN_BTC_WBTC_SBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CRV_REN_WBTC()": {
              inputs: [],
              name: "CRV_REN_WBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "CUSDC()": {
              inputs: [],
              name: "CUSDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DAI()": {
              inputs: [],
              name: "DAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD()": {
              inputs: [],
              name: "DUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD_SWAP_POOL()": {
              inputs: [],
              name: "DUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DUSD_THREE_CRV()": {
              inputs: [],
              name: "DUSD_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD()": {
              inputs: [],
              name: "GUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD_SWAP_POOL()": {
              inputs: [],
              name: "GUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "GUSD_THREE_CRV()": {
              inputs: [],
              name: "GUSD_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HBTC()": {
              inputs: [],
              name: "HBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HBTC_SWAP_POOL()": {
              inputs: [],
              name: "HBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HCRV()": {
              inputs: [],
              name: "HCRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD()": {
              inputs: [],
              name: "HUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD_SWAP_POOL()": {
              inputs: [],
              name: "HUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "HUSD_THREE_CRV()": {
              inputs: [],
              name: "HUSD_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD()": {
              inputs: [],
              name: "LINKUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD_SWAP_POOL()": {
              inputs: [],
              name: "LINKUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "LINKUSD_THREE_CRV()": {
              inputs: [],
              name: "LINKUSD_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD()": {
              inputs: [],
              name: "MUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD_SWAP_POOL()": {
              inputs: [],
              name: "MUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "MUSD_THREE_CRV()": {
              inputs: [],
              name: "MUSD_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX()": {
              inputs: [],
              name: "PAX",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "PAX_SWAP_POOL()": {
              inputs: [],
              name: "PAX_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "REN_BTC()": {
              inputs: [],
              name: "REN_BTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "REN_SWAP_POOL()": {
              inputs: [],
              name: "REN_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV()": {
              inputs: [],
              name: "RSV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV_SWAP_POOL()": {
              inputs: [],
              name: "RSV_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "RSV_THREE_CRV()": {
              inputs: [],
              name: "RSV_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SBTC()": {
              inputs: [],
              name: "SBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SBTC_SWAP_POOL()": {
              inputs: [],
              name: "SBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD()": {
              inputs: [],
              name: "SUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SUSD_SWAP_POOL()": {
              inputs: [],
              name: "SUSD_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC()": {
              inputs: [],
              name: "TBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_SBTC_CRV()": {
              inputs: [],
              name: "TBTC_SBTC_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_SWAP_POOL()": {
              inputs: [],
              name: "TBTC_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "THREE_CRV()": {
              inputs: [],
              name: "THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "THREE_SWAP_POOL()": {
              inputs: [],
              name: "THREE_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDC()": {
              inputs: [],
              name: "USDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK()": {
              inputs: [],
              name: "USDK",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK_SWAP_POOL()": {
              inputs: [],
              name: "USDK_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDK_THREE_CRV()": {
              inputs: [],
              name: "USDK_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN()": {
              inputs: [],
              name: "USDN",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN_SWAP_POOL()": {
              inputs: [],
              name: "USDN_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDN_THREE_CRV()": {
              inputs: [],
              name: "USDN_THREE_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT()": {
              inputs: [],
              name: "USDT",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_SWAP_POOL()": {
              inputs: [],
              name: "USDT_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "WBTC()": {
              inputs: [],
              name: "WBTC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YBUSD()": {
              inputs: [],
              name: "YBUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YCDAI()": {
              inputs: [],
              name: "YCDAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YCUSDC()": {
              inputs: [],
              name: "YCUSDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YCUSDT()": {
              inputs: [],
              name: "YCUSDT",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YDAI()": {
              inputs: [],
              name: "YDAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YDAI_YUSDC_YUSDT_YBUSD()": {
              inputs: [],
              name: "YDAI_YUSDC_YUSDT_YBUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YDAI_YUSDC_YUSDT_YTUSD()": {
              inputs: [],
              name: "YDAI_YUSDC_YUSDT_YTUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YTUSD()": {
              inputs: [],
              name: "YTUSD",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YUSDC()": {
              inputs: [],
              name: "YUSDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YUSDT()": {
              inputs: [],
              name: "YUSDT",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "Y_PAX_CRV()": {
              inputs: [],
              name: "Y_PAX_CRV",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "Y_SWAP_POOL()": {
              inputs: [],
              name: "Y_SWAP_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken in staking pool(gauge)",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Calls the appropriate deploy function depending on N_COINS ",
              params: {
                _amounts: "Quantity of _underlyingToken to deposit",
                _liquidityPool: "Address of the pool deposit (or swap, in some cases) contract",
              },
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getMinter(address)": {
              inputs: [{ internalType: "address", name: "_gauge", type: "address" }],
              name: "getMinter",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_liquidityPool", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details:
                "Calls the appropriate deploy function depending on N_COINSThis function needs an address _underlyingToken argument to get how many _underlyingToken equal      the user's balance in _liquidityPoolToken",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_stakeAmount", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_unstakeAmount", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
              details: "Swaps _amount of _liquidityPoolToken for _underlyingToken",
              params: {
                _amount: "Quantity of _liquidityPoolToken to swap for _underlyingToken",
                _liquidityPool: "Address of the token that represents users' holdings in the pool",
              },
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit2Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit2Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit3Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit3Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDeposit4Amount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "maxDeposit4Amount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "noRemoveLiquidityOneCoin(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "noRemoveLiquidityOneCoin",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardToken()": {
              inputs: [],
              name: "rewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "_swapPool", type: "address" },
                { internalType: "address", name: "_liquidityPoolToken", type: "address" },
              ],
              name: "setLiquidityPoolToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit2Amount(address,uint256[2])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[2]", name: "_maxDepositAmount", type: "uint256[2]" },
              ],
              name: "setMaxDeposit2Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit3Amount(address,uint256[3])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[3]", name: "_maxDepositAmount", type: "uint256[3]" },
              ],
              name: "setMaxDeposit3Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDeposit4Amount(address,uint256[4])": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[4]", name: "_maxDepositAmount", type: "uint256[4]" },
              ],
              name: "setMaxDeposit4Amount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256[4])": {
              inputs: [{ internalType: "uint256[4]", name: "_maxDepositAmountDefault", type: "uint256[4]" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_rewardToken", type: "address" }],
              name: "setRewardToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setSwapPoolToGauges(address,address)": {
              inputs: [
                { internalType: "address", name: "_pool", type: "address" },
                { internalType: "address", name: "_gauge", type: "address" },
              ],
              name: "setSwapPoolToGauges",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setSwapPoolToUnderlyingTokens(address,address[])": {
              inputs: [
                { internalType: "address", name: "_lendingPool", type: "address" },
                { internalType: "address[]", name: "_tokens", type: "address[]" },
              ],
              name: "setSwapPoolToUnderlyingTokens",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "swapPoolToGauges(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "swapPoolToGauges",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "swapPoolToLiquidityPoolToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "swapPoolToLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "swapPoolToUnderlyingTokens(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "swapPoolToUnderlyingTokens",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "toggleNoRemoveLiquidityOneCoin(address)": {
              inputs: [{ internalType: "address", name: "_pool", type: "address" }],
              name: "toggleNoRemoveLiquidityOneCoin",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/dYdX/dYdXAdapter.sol:DyDxAdapter": {
          source: "contracts/protocol/defiAdapters/dYdX/dYdXAdapter.sol",
          name: "DyDxAdapter",
          details: "Abstraction layer to DyDx's pools",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "DAI()": {
              inputs: [],
              name: "DAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DYDX_LIQUIIDTY_POOL()": {
              inputs: [],
              name: "DYDX_LIQUIIDTY_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "SAI()": {
              inputs: [],
              name: "SAI",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDC()": {
              inputs: [],
              name: "USDC",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "WETH()": {
              inputs: [],
              name: "WETH",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "addMarket(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "uint256", name: "_marketIndex", type: "uint256" },
              ],
              name: "addMarket",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToUnderlyingTokens(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "liquidityPoolToUnderlyingTokens",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "marketToIndexes(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "marketToIndexes",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setLiquidityPoolToUnderlyingTokens(address,address[])": {
              inputs: [
                { internalType: "address", name: "_lendingPool", type: "address" },
                { internalType: "address[]", name: "_tokens", type: "address[]" },
              ],
              name: "setLiquidityPoolToUnderlyingTokens",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/dforce/DForceAdapter.sol:DForceAdapter": {
          source: "contracts/protocol/defiAdapters/dforce/DForceAdapter.sol",
          name: "DForceAdapter",
          details: "Abstraction layer to DForce's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "DAI_DEPOSIT_POOL()": {
              inputs: [],
              name: "DAI_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "DAI_STAKING_POOL()": {
              inputs: [],
              name: "DAI_STAKING_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDC_DEPOSIT_POOL()": {
              inputs: [],
              name: "USDC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDC_STAKING_POOL()": {
              inputs: [],
              name: "USDC_STAKING_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_DEPOSIT_POOL()": {
              inputs: [],
              name: "USDT_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "USDT_STAKING_POOL()": {
              inputs: [],
              name: "USDT_STAKING_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToStakingPool(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToStakingPool",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardToken()": {
              inputs: [],
              name: "rewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquidityPoolToStakingPool(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "setLiquidityPoolToStakingPool",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_rewardToken", type: "address" }],
              name: "setRewardToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/fulcrum/FulcrumAdapter.sol:FulcrumAdapter": {
          source: "contracts/protocol/defiAdapters/fulcrum/FulcrumAdapter.sol",
          name: "FulcrumAdapter",
          details: "Abstraction layer to Fulcrum's pools",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_burnAmount", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/harvest.finance/HarvestAdapter.sol:HarvestAdapter": {
          source: "contracts/protocol/defiAdapters/harvest.finance/HarvestAdapter.sol",
          name: "HarvestAdapter",
          details: "Abstraction layer to harvest finance's pools",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_harvestCodeProvider", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "F_CDAI_CUSDC_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_CDAI_CUSDC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_CDAI_CUSDC_STAKE_POOL()": {
              inputs: [],
              name: "F_CDAI_CUSDC_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_CRV_RENBTC_STAKE_POOL()": {
              inputs: [],
              name: "F_CRV_RENBTC_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_CRV_REN_WBTC_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_CRV_REN_WBTC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_DAI_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_DAI_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_DAI_STAKE_POOL()": {
              inputs: [],
              name: "F_DAI_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_RENBTC_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_RENBTC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_RENBTC_STAKE_POOL()": {
              inputs: [],
              name: "F_RENBTC_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_TUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_TUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_TUSD_STAKE_POOL()": {
              inputs: [],
              name: "F_TUSD_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDC_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_USDC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDC_STAKE_POOL()": {
              inputs: [],
              name: "F_USDC_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDN_THREE_CRV_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_USDN_THREE_CRV_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDN_THREE_CRV_STAKE_POOL()": {
              inputs: [],
              name: "F_USDN_THREE_CRV_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDT_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_USDT_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_USDT_STAKE_POOL()": {
              inputs: [],
              name: "F_USDT_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_WBTC_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_WBTC_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_WBTC_STAKE_POOL()": {
              inputs: [],
              name: "F_WBTC_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_WETH_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_WETH_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_WETH_STAKE_POOL()": {
              inputs: [],
              name: "F_WETH_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_YDAI_YUSDC_YUSDT_YBUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "F_YDAI_YUSDC_YUSDT_YBUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "F_YDAI_YUSDC_YUSDT_YBUSD_STAKE_POOL()": {
              inputs: [],
              name: "F_YDAI_YUSDC_YUSDT_YBUSD_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_SBTC_CRV_DEPOSIT_POOL()": {
              inputs: [],
              name: "TBTC_SBTC_CRV_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "TBTC_SBTC_CRV_STAKE_POOL()": {
              inputs: [],
              name: "TBTC_SBTC_CRV_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "THREE_CRV_DEPOSIT_POOL()": {
              inputs: [],
              name: "THREE_CRV_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "THREE_CRV_STAKE_POOL()": {
              inputs: [],
              name: "THREE_CRV_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YDAI_YUSDC_YUSDT_YTUSD_DEPOSIT_POOL()": {
              inputs: [],
              name: "YDAI_YUSDC_YUSDT_YTUSD_DEPOSIT_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "YDAI_YUSDC_YUSDT_YTUSD_STAKE_POOL()": {
              inputs: [],
              name: "YDAI_YUSDC_YUSDT_YTUSD_STAKE_POOL",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_rewardTokenAmount", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "harvestCodeProviderContract()": {
              inputs: [],
              name: "harvestCodeProviderContract",
              outputs: [{ internalType: "contract HarvestCodeProvider", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "liquidityPoolToStakingPool(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "liquidityPoolToStakingPool",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardToken()": {
              inputs: [],
              name: "rewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setHarvestCodeProvider(address)": {
              inputs: [{ internalType: "address", name: "_harvestCodeProvider", type: "address" }],
              name: "setHarvestCodeProvider",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setLiquidityPoolToStakingPool(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "setLiquidityPoolToStakingPool",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardToken(address)": {
              inputs: [{ internalType: "address", name: "_rewardToken", type: "address" }],
              name: "setRewardToken",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/defiAdapters/yearn/YVaultAdapter.sol:YVaultAdapter": {
          source: "contracts/protocol/defiAdapters/yearn/YVaultAdapter.sol",
          name: "YVaultAdapter",
          details: "Abstraction layer to yVault's pools",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/defiAdapters/yearn/YearnAdapter.sol:YearnAdapter": {
          source: "contracts/protocol/defiAdapters/yearn/YearnAdapter.sol",
          name: "YearnAdapter",
          details: "Abstraction layer to yEarn's pools",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "calculateAmountInLPToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_depositAmount", type: "uint256" },
              ],
              name: "calculateAmountInLPToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmount(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmount",
              outputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "calculateRedeemableLPTokenAmountStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "calculateRedeemableLPTokenAmountStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "canStake(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "canStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInToken(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getAllAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenBorrow(address,address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getAllAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getAllAmountInTokenStake(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getAllAmountInTokenStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBorrowAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getBorrowAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getClaimRewardTokenCode(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getClaimRewardTokenCode",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getDepositAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getDepositSomeCodes(address,address[],address,uint256[])": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256[]", name: "_amounts", type: "uint256[]" },
              ],
              name: "getDepositSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestAllCodes(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getHarvestAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getHarvestSomeCodes(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getHarvestSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolToken(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalance(address,address,address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getLiquidityPoolTokenBalanceStake(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getLiquidityPoolTokenBalanceStake",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPoolValue(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getPoolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getRepayAndWithdrawAllCodes(address,address[],address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getRepayAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getRewardToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "getRewardToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInToken(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_liquidityPoolTokenAmount", type: "uint256" },
              ],
              name: "getSomeAmountInToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getSomeAmountInTokenBorrow(address,address,address,uint256,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getSomeAmountInTokenBorrow",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getStakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getStakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getStakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnclaimedRewardTokenAmount(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnclaimedRewardTokenAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnderlyingTokens(address,address)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnderlyingTokens",
              outputs: [{ internalType: "address[]", name: "_underlyingTokens", type: "address[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAllCodes(address,address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "getUnstakeAndWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeAndWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeAndWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getUnstakeSomeCodes(address,uint256)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "getUnstakeSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawAllCodes(address,address[],address)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address[]", name: "_underlyingTokens", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
              ],
              name: "getWithdrawAllCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "getWithdrawSomeCodes(address,address[],address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address[]", name: "", type: "address[]" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "getWithdrawSomeCodes",
              outputs: [{ internalType: "bytes[]", name: "_codes", type: "bytes[]" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficient(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_redeemAmount", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficient",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "isRedeemableAmountSufficientStake(address,address,address,uint256)": {
              inputs: [
                { internalType: "address payable", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "isRedeemableAmountSufficientStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmount(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositAmount",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositAmountDefault()": {
              inputs: [],
              name: "maxDepositAmountDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPct(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "maxDepositPoolPct",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxDepositPoolPctDefault()": {
              inputs: [],
              name: "maxDepositPoolPctDefault",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "maxExposureType()": {
              inputs: [],
              name: "maxExposureType",
              outputs: [{ internalType: "enum DataTypes.MaxExposure", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setMaxDepositAmount(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositAmount", type: "uint256" },
              ],
              name: "setMaxDepositAmount",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositAmountDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositAmountDefault", type: "uint256" }],
              name: "setMaxDepositAmountDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPct(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_liquidityPool", type: "address" },
                { internalType: "uint256", name: "_maxDepositPoolPct", type: "uint256" },
              ],
              name: "setMaxDepositPoolPct",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolPctDefault(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxDepositPoolPctDefault", type: "uint256" }],
              name: "setMaxDepositPoolPctDefault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setMaxDepositPoolType(uint8)": {
              inputs: [{ internalType: "enum DataTypes.MaxExposure", name: "_type", type: "uint8" }],
              name: "setMaxDepositPoolType",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
          },
        },
        "contracts/protocol/partnership/VaultBooster.sol:VaultBooster": {
          source: "contracts/protocol/partnership/VaultBooster.sol",
          name: "VaultBooster",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_odefi", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "addOdefiVault(address)": {
              inputs: [{ internalType: "address", name: "_odefiVault", type: "address" }],
              name: "addOdefiVault",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "allOdefiVaults(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allOdefiVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "claimODEFI(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "claimODEFI",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: { _holder: "The address to claim ODEFI for" },
              notice: "Claim all the ODEFI accrued by holder in all markets",
            },
            "claimODEFI(address[],address[])": {
              inputs: [
                { internalType: "address[]", name: "_holders", type: "address[]" },
                { internalType: "address[]", name: "_odefiVaults", type: "address[]" },
              ],
              name: "claimODEFI",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: {
                _holders: "The addresses to claim ODEFI for",
                _odefiVaults: "The list of vaults to claim ODEFI in",
              },
              notice: "Claim all odefi accrued by the holders",
            },
            "claimODEFI(address,address[])": {
              inputs: [
                { internalType: "address", name: "_holder", type: "address" },
                { internalType: "address[]", name: "_odefiVaults", type: "address[]" },
              ],
              name: "claimODEFI",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: {
                _holder: "The address to claim ODEFI for",
                _odefiVaults: "The list of vaults to claim ODEFI in",
              },
              notice: "Claim all the ODEFI accrued by holder in the specified markets",
            },
            "claimableODEFI(address,address[])": {
              inputs: [
                { internalType: "address", name: "_holder", type: "address" },
                { internalType: "address[]", name: "_odefiVaults", type: "address[]" },
              ],
              name: "claimableODEFI",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              params: {
                _holder: "The address to claim ODEFI for",
                _odefiVaults: "The list of vaults to claim ODEFI in",
              },
              notice: "Claim all the odefi accrued by holder in the specified markets",
            },
            "claimableODEFI(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "claimableODEFI",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              params: { _holder: "The address to claim ODEFI for" },
              notice: "Claim all the odefi accrued by holder in all markets",
            },
            "currentOdefiVaultIndex(address)": {
              inputs: [{ internalType: "address", name: "_odefiVault", type: "address" }],
              name: "currentOdefiVaultIndex",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBlockTimestamp()": {
              inputs: [],
              name: "getBlockTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getOdefiAddress()": {
              inputs: [],
              name: "getOdefiAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "lastUserUpdate(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "lastUserUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiAccrued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI accrued but not yet transferred to each user",
            },
            "odefiAddress()": {
              inputs: [],
              name: "odefiAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiTotalRate()": {
              inputs: [],
              name: "odefiTotalRate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The rate at which the flywheel distributes ODEFI, per block",
            },
            "odefiUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "odefiUserStateInVault",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI index for each market for each user as of the last time they accrued ODEFI",
            },
            "odefiVaultEnabled(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultEnabled",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiVaultRatePerSecond(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of odefiRate that each market currently receives",
            },
            "odefiVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of odefiRate that each market currently receives divided by the amount of LP tokens",
            },
            "odefiVaultStartTimestamp(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultStartTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiVaultState(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultState",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI market supply state for each pool",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "rewardDepletionSeconds(address)": {
              inputs: [{ internalType: "address", name: "_odefiVault", type: "address" }],
              name: "rewardDepletionSeconds",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "rewarders(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "rewarders",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setOdefiVault(address,bool)": {
              inputs: [
                { internalType: "address", name: "_odefiVault", type: "address" },
                { internalType: "bool", name: "_enable", type: "bool" },
              ],
              name: "setOdefiVault",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRewardRate(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_odefiVault", type: "address" },
                { internalType: "uint256", name: "_rate", type: "uint256" },
              ],
              name: "setRewardRate",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              returns: { _0: "The amount of ODEFI which was NOT transferred to the user" },
              notice: "Set the ODEFI rate for a specific pool",
            },
            "setRewarder(address,address)": {
              inputs: [
                { internalType: "address", name: "_odefiVault", type: "address" },
                { internalType: "address", name: "_rewarder", type: "address" },
              ],
              name: "setRewarder",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "updateOdefiVaultIndex(address)": {
              inputs: [{ internalType: "address", name: "_odefiVault", type: "address" }],
              name: "updateOdefiVaultIndex",
              outputs: [{ internalType: "uint224", name: "", type: "uint224" }],
              stateMutability: "nonpayable",
              type: "function",
              params: { _odefiVault: "The market whose index to update" },
              notice: "Accrue ODEFI to the market by updating the supply index",
            },
            "updateOdefiVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "_odefiVault", type: "address" }],
              name: "updateOdefiVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              returns: { _0: "The amount of ODEFI which was NOT transferred to the user" },
              notice: "Set the ODEFI rate for a specific pool",
            },
            "updateUserRewards(address,address)": {
              inputs: [
                { internalType: "address", name: "_odefiVault", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "updateUserRewards",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              params: { _user: "The address to calculate contributor rewards for" },
              notice: "Calculate additional accrued ODEFI for a contributor since last accrual",
            },
            "updateUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "_odefiVault", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "updateUserStateInVault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/partnership/VaultBoosterStorage.sol:VaultBoosterStorage": {
          source: "contracts/protocol/partnership/VaultBoosterStorage.sol",
          name: "VaultBoosterStorage",
          methods: {
            "allOdefiVaults(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allOdefiVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "lastUserUpdate(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "lastUserUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiAccrued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI accrued but not yet transferred to each user",
            },
            "odefiAddress()": {
              inputs: [],
              name: "odefiAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiTotalRate()": {
              inputs: [],
              name: "odefiTotalRate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The rate at which the flywheel distributes ODEFI, per block",
            },
            "odefiUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "odefiUserStateInVault",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI index for each market for each user as of the last time they accrued ODEFI",
            },
            "odefiVaultEnabled(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultEnabled",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiVaultRatePerSecond(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of odefiRate that each market currently receives",
            },
            "odefiVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of odefiRate that each market currently receives divided by the amount of LP tokens",
            },
            "odefiVaultStartTimestamp(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultStartTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "odefiVaultState(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "odefiVaultState",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The ODEFI market supply state for each pool",
            },
            "rewarders(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "rewarders",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/IncentivisedERC20.sol:IncentivisedERC20": {
          source: "contracts/protocol/tokenization/IncentivisedERC20.sol",
          name: "IncentivisedERC20",
          details:
            "Implementation of the {IERC20} interface. This implementation is agnostic to the way tokens are created. This means that a supply mechanism has to be added in a derived contract using {_mint}. For a generic mechanism see {ERC20PresetMinterPauser}. TIP: For a detailed writeup see our guide https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How to implement supply mechanisms]. We have followed general OpenZeppelin guidelines: functions revert instead of returning `false` on failure. This behavior is nonetheless conventional and does not conflict with the expectations of ERC20 applications. Additionally, an {Approval} event is emitted on calls to {transferFrom}. This allows applications to reconstruct the allowance for all accounts just by listening to said events. Other implementations of the EIP may not emit these events, as it isn't required by the specification. Finally, the non-standard {decreaseAllowance} and {increaseAllowance} functions have been added to mitigate the well-known issues around setting allowances. See {IERC20-approve}.",
          constructor: {
            inputs: [
              { internalType: "string", name: "name_", type: "string" },
              { internalType: "string", name: "symbol_", type: "string" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
          },
        },
        "contracts/protocol/tokenization/OPTY.sol:OPTY": {
          source: "contracts/protocol/tokenization/OPTY.sol",
          name: "OPTY",
          details: "optyfi's governance token",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "uint256", name: "initialSupply", type: "uint256" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "mint(address,uint256)": {
              inputs: [
                { internalType: "address", name: "to", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "mint",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYMinter.sol:OPTYMinter": {
          source: "contracts/protocol/tokenization/OPTYMinter.sol",
          name: "OPTYMinter",
          details: "Contract distributing $OPTY to opty-fi earn protocol's users",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_opty", type: "address" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "addOptyVault(address)": {
              inputs: [{ internalType: "address", name: "_optyVault", type: "address" }],
              name: "addOptyVault",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "allOptyVaults(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allOptyVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "claimAndStake(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "claimAndStake",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "claimOpty(address[],address[])": {
              inputs: [
                { internalType: "address[]", name: "_holders", type: "address[]" },
                { internalType: "address[]", name: "_optyVaults", type: "address[]" },
              ],
              name: "claimOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: {
                _holders: "The addresses to claim OPTY for",
                _optyVaults: "The list of vaults to claim OPTY in",
              },
              notice: "Claim all opty accrued by the holders",
            },
            "claimOpty(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "claimOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: { _holder: "The address to claim OPTY for" },
              notice: "Claim all the OPTY accrued by holder in all markets",
            },
            "claimOpty(address,address[])": {
              inputs: [
                { internalType: "address", name: "_holder", type: "address" },
                { internalType: "address[]", name: "_optyVaults", type: "address[]" },
              ],
              name: "claimOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              params: { _holder: "The address to claim OPTY for", _optyVaults: "The list of vaults to claim OPTY in" },
              notice: "Claim all the OPTY accrued by holder in the specified markets",
            },
            "claimableOpty(address,address[])": {
              inputs: [
                { internalType: "address", name: "_holder", type: "address" },
                { internalType: "address[]", name: "_optyVaults", type: "address[]" },
              ],
              name: "claimableOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              params: { _holder: "The address to claim OPTY for", _optyVaults: "The list of vaults to claim OPTY in" },
              notice: "Claim all the opty accrued by holder in the specified markets",
            },
            "claimableOpty(address)": {
              inputs: [{ internalType: "address", name: "_holder", type: "address" }],
              name: "claimableOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              params: { _holder: "The address to claim OPTY for" },
              notice: "Claim all the opty accrued by holder in all markets",
            },
            "currentOptyVaultIndex(address)": {
              inputs: [{ internalType: "address", name: "_optyVault", type: "address" }],
              name: "currentOptyVaultIndex",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getBlockTimestamp()": {
              inputs: [],
              name: "getBlockTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getOptyAddress()": {
              inputs: [],
              name: "getOptyAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "lastUserUpdate(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "lastUserUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "mintOpty(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_user", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "mintOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "optyAccrued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY accrued but not yet transferred to each user",
            },
            "optyAddress()": {
              inputs: [],
              name: "optyAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "optyTotalRate()": {
              inputs: [],
              name: "optyTotalRate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The rate at which the flywheel distributes OPTY, per block",
            },
            "optyUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "optyUserStateInVault",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY index for each market for each user as of the last time they accrued OPTY",
            },
            "optyVaultEnabled(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultEnabled",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "optyVaultRatePerSecond(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of optyRate that each market currently receives",
            },
            "optyVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of optyRate that each market currently receives divided by the amount of LP tokens",
            },
            "optyVaultStartTimestamp(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultStartTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyVaultState(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultState",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY market supply state for each optyPool",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setOptyVault(address,bool)": {
              inputs: [
                { internalType: "address", name: "_optyVault", type: "address" },
                { internalType: "bool", name: "_enable", type: "bool" },
              ],
              name: "setOptyVault",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOptyVaultRate(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_optyVault", type: "address" },
                { internalType: "uint256", name: "_rate", type: "uint256" },
              ],
              name: "setOptyVaultRate",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              returns: { _0: "The amount of OPTY which was NOT transferred to the user" },
              notice: "Set the OPTY rate for a specific pool",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setStakingPool(address,bool)": {
              inputs: [
                { internalType: "address", name: "_stakingPool", type: "address" },
                { internalType: "bool", name: "_enable", type: "bool" },
              ],
              name: "setStakingPool",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Maps staking pool to a boolean variable that indicates wether the staking pool is enabled`or not",
            },
            "stakingPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPools",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "updateOptyVaultIndex(address)": {
              inputs: [{ internalType: "address", name: "_optyVault", type: "address" }],
              name: "updateOptyVaultIndex",
              outputs: [{ internalType: "uint224", name: "", type: "uint224" }],
              stateMutability: "nonpayable",
              type: "function",
              params: { _optyVault: "The market whose index to update" },
              notice: "Accrue OPTY to the market by updating the supply index",
            },
            "updateOptyVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "_optyVault", type: "address" }],
              name: "updateOptyVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              returns: { _0: "The amount of OPTY which was NOT transferred to the user" },
              notice: "Set the OPTY rate for a specific pool",
            },
            "updateUserRewards(address,address)": {
              inputs: [
                { internalType: "address", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "updateUserRewards",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              params: { _user: "The address to calculate contributor rewards for" },
              notice: "Calculate additional accrued OPTY for a contributor since last accrual",
            },
            "updateUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "_optyVault", type: "address" },
                { internalType: "address", name: "_user", type: "address" },
              ],
              name: "updateUserStateInVault",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYMinterStorage.sol:OPTYMinterStorage": {
          source: "contracts/protocol/tokenization/OPTYMinterStorage.sol",
          name: "OPTYMinterStorage",
          details: "Contract to store the OPTYMinter's state variables",
          methods: {
            "allOptyVaults(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "allOptyVaults",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "lastUserUpdate(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "lastUserUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyAccrued(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyAccrued",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY accrued but not yet transferred to each user",
            },
            "optyAddress()": {
              inputs: [],
              name: "optyAddress",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "optyTotalRate()": {
              inputs: [],
              name: "optyTotalRate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The rate at which the flywheel distributes OPTY, per block",
            },
            "optyUserStateInVault(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "optyUserStateInVault",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY index for each market for each user as of the last time they accrued OPTY",
            },
            "optyVaultEnabled(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultEnabled",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "optyVaultRatePerSecond(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of optyRate that each market currently receives",
            },
            "optyVaultRatePerSecondAndVaultToken(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultRatePerSecondAndVaultToken",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "The portion of optyRate that each market currently receives divided by the amount of LP tokens",
            },
            "optyVaultStartTimestamp(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultStartTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyVaultState(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "optyVaultState",
              outputs: [
                { internalType: "uint224", name: "index", type: "uint224" },
                { internalType: "uint32", name: "timestamp", type: "uint32" },
              ],
              stateMutability: "view",
              type: "function",
              notice: "The OPTY market supply state for each optyPool",
            },
            "stakingPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPools",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYStakingPool.sol:OPTYStakingPool": {
          source: "contracts/protocol/tokenization/OPTYStakingPool.sol",
          name: "OPTYStakingPool",
          details: "Opty.Fi's Staking Pool contract for OPTY",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "address", name: "_underlyingToken", type: "address" },
              { internalType: "address", name: "_optyMinter", type: "address" },
              { internalType: "uint256", name: "_timelock", type: "uint256" },
              { internalType: "address", name: "_optyStakingRateBalancer", type: "address" },
              { internalType: "string", name: "_numberOfDays", type: "string" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
          },
          methods: {
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Function to get the underlying token balance of OptyPool Contract",
            },
            "balanceInOpty(address)": {
              inputs: [{ internalType: "address", name: "_user", type: "address" }],
              name: "balanceInOpty",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "discontinue()": {
              inputs: [],
              name: "discontinue",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "getBlockTimestamp()": {
              inputs: [],
              name: "getBlockTimestamp",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "lastPoolUpdate()": {
              inputs: [],
              name: "lastPoolUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "optyMinterContract()": {
              inputs: [],
              name: "optyMinterContract",
              outputs: [{ internalType: "contract OPTYMinter", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "optyRatePerSecond()": {
              inputs: [],
              name: "optyRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyStakingRateBalancer()": {
              inputs: [],
              name: "optyStakingRateBalancer",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "poolValue()": {
              inputs: [],
              name: "poolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setOPTYMinter(address)": {
              inputs: [{ internalType: "address", name: "_optyMinter", type: "address" }],
              name: "setOPTYMinter",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOPTYStakingRateBalancer(address)": {
              inputs: [{ internalType: "address", name: "_optyStakingRateBalancer", type: "address" }],
              name: "setOPTYStakingRateBalancer",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOptyRatePerSecond(uint256)": {
              inputs: [{ internalType: "uint256", name: "_rate", type: "uint256" }],
              name: "setOptyRatePerSecond",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setPaused(bool)": {
              inputs: [{ internalType: "bool", name: "_paused", type: "bool" }],
              name: "setPaused",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setTimelockPeriod(uint256)": {
              inputs: [{ internalType: "uint256", name: "_timelock", type: "uint256" }],
              name: "setTimelockPeriod",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setToken(address)": {
              inputs: [{ internalType: "address", name: "_underlyingToken", type: "address" }],
              name: "setToken",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "timelockPeriod()": {
              inputs: [],
              name: "timelockPeriod",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
            "updatePool()": {
              inputs: [],
              name: "updatePool",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userLastUpdate(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "userLastUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "userStake(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userStakeAll()": {
              inputs: [],
              name: "userStakeAll",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userUnstake(uint256)": {
              inputs: [{ internalType: "uint256", name: "_redeemAmount", type: "uint256" }],
              name: "userUnstake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userUnstakeAll()": {
              inputs: [],
              name: "userUnstakeAll",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYStakingPoolStorage.sol:OPTYStakingPoolStorage": {
          source: "contracts/protocol/tokenization/OPTYStakingPoolStorage.sol",
          name: "OPTYStakingPoolStorage",
          details: "Control to store state variables of Staking pool",
          methods: {
            "lastPoolUpdate()": {
              inputs: [],
              name: "lastPoolUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyMinterContract()": {
              inputs: [],
              name: "optyMinterContract",
              outputs: [{ internalType: "contract OPTYMinter", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "optyRatePerSecond()": {
              inputs: [],
              name: "optyRatePerSecond",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyStakingRateBalancer()": {
              inputs: [],
              name: "optyStakingRateBalancer",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "poolValue()": {
              inputs: [],
              name: "poolValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "timelockPeriod()": {
              inputs: [],
              name: "timelockPeriod",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "token()": {
              inputs: [],
              name: "token",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "userLastUpdate(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "userLastUpdate",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYStakingRateBalancer.sol:OPTYStakingRateBalancer": {
          source: "contracts/protocol/tokenization/OPTYStakingRateBalancer.sol",
          name: "OPTYStakingRateBalancer",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          methods: {
            "become(address)": {
              inputs: [
                {
                  internalType: "contract OPTYStakingRateBalancerProxy",
                  name: "_optyStakingRateBalancerProxy",
                  type: "address",
                },
              ],
              name: "become",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Set OPTYStakingRateBalancerProxy to act as OPTYStakingRateBalancer",
            },
            "initialize(address,address,address,address)": {
              inputs: [
                { internalType: "address", name: "_stakingPool1DLockingTerm", type: "address" },
                { internalType: "address", name: "_stakingPool30DLockingTerm", type: "address" },
                { internalType: "address", name: "_stakingPool60DLockingTerm", type: "address" },
                { internalType: "address", name: "_stakingPool180DLockingTerm", type: "address" },
              ],
              name: "initialize",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "initialize the different stakingPools",
            },
            "optyStakingRateBalancerImplementation()": {
              inputs: [],
              name: "optyStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Staking Rate Balancer",
            },
            "pendingOPTYStakingRateBalancerImplementation()": {
              inputs: [],
              name: "pendingOPTYStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Staking Rate Balancer",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setStakingPoolMultipliers(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_stakingPool", type: "address" },
                { internalType: "uint256", name: "_multiplier", type: "uint256" },
              ],
              name: "setStakingPoolMultipliers",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setStakingPoolOPTYAllocation(uint256)": {
              inputs: [{ internalType: "uint256", name: "_stakingPoolOPTYAllocation", type: "uint256" }],
              name: "setStakingPoolOPTYAllocation",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "stakingPool180DLockingTerm()": {
              inputs: [],
              name: "stakingPool180DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 180 days locking term's staking pool address",
            },
            "stakingPool1DLockingTerm()": {
              inputs: [],
              name: "stakingPool1DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 1 day locking term's staking pool address",
            },
            "stakingPool30DLockingTerm()": {
              inputs: [],
              name: "stakingPool30DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 30 days locking term's staking pool address",
            },
            "stakingPool60DLockingTerm()": {
              inputs: [],
              name: "stakingPool60DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 60 days locking term's staking pool address",
            },
            "stakingPoolMultipliers(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolMultipliers",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolOPTYAllocation()": {
              inputs: [],
              name: "stakingPoolOPTYAllocation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolToStakedOPTY(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolToStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool",
            },
            "stakingPoolToUserStakedOPTY(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "stakingPoolToUserStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool per user",
            },
            "stakingPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPools",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores active staking pools",
            },
            "updateOptyRates()": {
              inputs: [],
              name: "updateOptyRates",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "updateStakedOPTY(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_staker", type: "address" },
                { internalType: "uint256", name: "_amount", type: "uint256" },
              ],
              name: "updateStakedOPTY",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "updateUnstakedOPTY(address,uint256)": {
              inputs: [
                { internalType: "address", name: "_staker", type: "address" },
                { internalType: "uint256", name: "_shares", type: "uint256" },
              ],
              name: "updateUnstakedOPTY",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYStakingRateBalancerProxy.sol:OPTYStakingRateBalancerProxy": {
          source: "contracts/protocol/tokenization/OPTYStakingRateBalancerProxy.sol",
          name: "OPTYStakingRateBalancerProxy",
          title: "OPTYStakingRateBalancerCore",
          details:
            "Storage for the OPTYStakingRateBalancer is at this address, while execution is delegated to the `optyStakingRateBalancerImplementation`. OPTYStakingRateBalancer should reference this contract as their controller.",
          constructor: {
            inputs: [{ internalType: "address", name: "_registry", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          fallback: { stateMutability: "payable", type: "fallback" },
          receive: { stateMutability: "payable", type: "receive" },
          events: {
            "NewImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newImplementation", type: "address" },
              ],
              name: "NewImplementation",
              type: "event",
            },
            "NewPendingImplementation(address,address)": {
              anonymous: !1,
              inputs: [
                { indexed: !1, internalType: "address", name: "oldPendingImplementation", type: "address" },
                { indexed: !1, internalType: "address", name: "newPendingImplementation", type: "address" },
              ],
              name: "NewPendingImplementation",
              type: "event",
            },
          },
          methods: {
            "acceptImplementation()": {
              inputs: [],
              name: "acceptImplementation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "Governance function for new implementation to accept it's role as implementation",
              notice: "Accepts new implementation of OPTYStakingRateBalancer. msg.sender must be pendingImplementation",
            },
            "optyStakingRateBalancerImplementation()": {
              inputs: [],
              name: "optyStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Staking Rate Balancer",
            },
            "pendingOPTYStakingRateBalancerImplementation()": {
              inputs: [],
              name: "pendingOPTYStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Staking Rate Balancer",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setPendingImplementation(address)": {
              inputs: [{ internalType: "address", name: "newPendingImplementation", type: "address" }],
              name: "setPendingImplementation",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              notice: "* Admin Functions **",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "stakingPool180DLockingTerm()": {
              inputs: [],
              name: "stakingPool180DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 180 days locking term's staking pool address",
            },
            "stakingPool1DLockingTerm()": {
              inputs: [],
              name: "stakingPool1DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 1 day locking term's staking pool address",
            },
            "stakingPool30DLockingTerm()": {
              inputs: [],
              name: "stakingPool30DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 30 days locking term's staking pool address",
            },
            "stakingPool60DLockingTerm()": {
              inputs: [],
              name: "stakingPool60DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 60 days locking term's staking pool address",
            },
            "stakingPoolMultipliers(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolMultipliers",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolOPTYAllocation()": {
              inputs: [],
              name: "stakingPoolOPTYAllocation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolToStakedOPTY(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolToStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool",
            },
            "stakingPoolToUserStakedOPTY(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "stakingPoolToUserStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool per user",
            },
            "stakingPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPools",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores active staking pools",
            },
          },
        },
        "contracts/protocol/tokenization/OPTYStakingRateBalancerStorage.sol:OPTYStakingRateBalancerStorage": {
          source: "contracts/protocol/tokenization/OPTYStakingRateBalancerStorage.sol",
          name: "OPTYStakingRateBalancerStorage",
          methods: {
            "optyStakingRateBalancerImplementation()": {
              inputs: [],
              name: "optyStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Active brains of Staking Rate Balancer",
            },
            "pendingOPTYStakingRateBalancerImplementation()": {
              inputs: [],
              name: "pendingOPTYStakingRateBalancerImplementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "Pending brains of Staking Rate Balancer",
            },
            "stakingPool180DLockingTerm()": {
              inputs: [],
              name: "stakingPool180DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 180 days locking term's staking pool address",
            },
            "stakingPool1DLockingTerm()": {
              inputs: [],
              name: "stakingPool1DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 1 day locking term's staking pool address",
            },
            "stakingPool30DLockingTerm()": {
              inputs: [],
              name: "stakingPool30DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 30 days locking term's staking pool address",
            },
            "stakingPool60DLockingTerm()": {
              inputs: [],
              name: "stakingPool60DLockingTerm",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores the 60 days locking term's staking pool address",
            },
            "stakingPoolMultipliers(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolMultipliers",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolOPTYAllocation()": {
              inputs: [],
              name: "stakingPoolOPTYAllocation",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "stakingPoolToStakedOPTY(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPoolToStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool",
            },
            "stakingPoolToUserStakedOPTY(address,address)": {
              inputs: [
                { internalType: "address", name: "", type: "address" },
                { internalType: "address", name: "", type: "address" },
              ],
              name: "stakingPoolToUserStakedOPTY",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores $OPTY staked in staking pool per user",
            },
            "stakingPools(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "stakingPools",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
              notice: "This variable stores active staking pools",
            },
          },
        },
        "contracts/protocol/tokenization/Vault.sol:Vault": {
          source: "contracts/protocol/tokenization/Vault.sol",
          name: "Vault",
          title: "Vault",
          author: "Opty.fi, inspired by the Aave V2 AToken.sol contract",
          details:
            "Opty.Fi's Vault contract for underlying tokens (for example DAI) and risk profiles (for example RP1)",
          constructor: {
            inputs: [
              { internalType: "address", name: "_registry", type: "address" },
              { internalType: "string", name: "_name", type: "string" },
              { internalType: "string", name: "_symbol", type: "string" },
              { internalType: "string", name: "_riskProfile", type: "string" },
            ],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          events: {
            "Approval(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "owner", type: "address" },
                { indexed: !0, internalType: "address", name: "spender", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Approval",
              type: "event",
            },
            "DepositQueue(address,uint256,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "sender", type: "address" },
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "DepositQueue",
              type: "event",
            },
            "Transfer(address,address,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "from", type: "address" },
                { indexed: !0, internalType: "address", name: "to", type: "address" },
                { indexed: !1, internalType: "uint256", name: "value", type: "uint256" },
              ],
              name: "Transfer",
              type: "event",
            },
            "WithdrawQueue(address,uint256,uint256)": {
              anonymous: !1,
              inputs: [
                { indexed: !0, internalType: "address", name: "sender", type: "address" },
                { indexed: !0, internalType: "uint256", name: "index", type: "uint256" },
                { indexed: !0, internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "WithdrawQueue",
              type: "event",
            },
          },
          methods: {
            "WITHDRAWAL_MAX()": {
              inputs: [],
              name: "WITHDRAWAL_MAX",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "allowance(address,address)": {
              inputs: [
                { internalType: "address", name: "owner", type: "address" },
                { internalType: "address", name: "spender", type: "address" },
              ],
              name: "allowance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-allowance}.",
            },
            "approve(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "approve",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details: "See {IERC20-approve}. Requirements: - `spender` cannot be the zero address.",
            },
            "balance()": {
              inputs: [],
              name: "balance",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "Function to get the underlying token balance of OptyVault Contract",
            },
            "balanceOf(address)": {
              inputs: [{ internalType: "address", name: "account", type: "address" }],
              name: "balanceOf",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-balanceOf}.",
            },
            "blockToBlockVaultValues(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "blockToBlockVaultValues",
              outputs: [
                { internalType: "uint256", name: "actualVaultValue", type: "uint256" },
                { internalType: "uint256", name: "blockMinVaultValue", type: "uint256" },
                { internalType: "uint256", name: "blockMaxVaultValue", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "chi()": {
              inputs: [],
              name: "chi",
              outputs: [{ internalType: "contract IFreeFromUpTo", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "chiDeploy(bytes)": {
              inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
              name: "chiDeploy",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "chiDeploy2(uint256,bytes)": {
              inputs: [
                { internalType: "uint256", name: "salt", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "chiDeploy2",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "decimals()": {
              inputs: [],
              name: "decimals",
              outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
              stateMutability: "view",
              type: "function",
              details:
                "Returns the number of decimals used to get its user representation. For example, if `decimals` equals `2`, a balance of `505` tokens should be displayed to a user as `5,05` (`505 / 10 ** 2`). Tokens usually opt for a value of 18, imitating the relationship between Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is called. NOTE: This information is only used for _display_ purposes: it in no way affects any of the arithmetic of the contract, including {IERC20-balanceOf} and {IERC20-transfer}.",
            },
            "decreaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "subtractedValue", type: "uint256" },
              ],
              name: "decreaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically decreases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address. - `spender` must have allowance for the caller of at least `subtractedValue`.",
            },
            "depositQueue()": {
              inputs: [],
              name: "depositQueue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "discontinue()": {
              inputs: [],
              name: "discontinue",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "gasOwedToOperator()": {
              inputs: [],
              name: "gasOwedToOperator",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "getPricePerFullShare()": {
              inputs: [],
              name: "getPricePerFullShare",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "gst()": {
              inputs: [],
              name: "gst",
              outputs: [{ internalType: "contract IFreeFromUpTo", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "gstDeploy(bytes)": {
              inputs: [{ internalType: "bytes", name: "data", type: "bytes" }],
              name: "gstDeploy",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "gstDeploy2(uint256,bytes)": {
              inputs: [
                { internalType: "uint256", name: "salt", type: "uint256" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "gstDeploy2",
              outputs: [{ internalType: "address", name: "contractAddress", type: "address" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "harvest(bytes32)": {
              inputs: [{ internalType: "bytes32", name: "_investStrategyHash", type: "bytes32" }],
              name: "harvest",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "increaseAllowance(address,uint256)": {
              inputs: [
                { internalType: "address", name: "spender", type: "address" },
                { internalType: "uint256", name: "addedValue", type: "uint256" },
              ],
              name: "increaseAllowance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "Atomically increases the allowance granted to `spender` by the caller. This is an alternative to {approve} that can be used as a mitigation for problems described in {IERC20-approve}. Emits an {Approval} event indicating the updated allowance. Requirements: - `spender` cannot be the zero address.",
            },
            "initialize(address,address,address,address,address,string,string,string)": {
              inputs: [
                { internalType: "address", name: "registry", type: "address" },
                { internalType: "address", name: "_riskManager", type: "address" },
                { internalType: "address", name: "_underlyingToken", type: "address" },
                { internalType: "address", name: "_strategyManager", type: "address" },
                { internalType: "address", name: "_optyMinter", type: "address" },
                { internalType: "string", name: "_name", type: "string" },
                { internalType: "string", name: "_symbol", type: "string" },
                { internalType: "string", name: "_riskProfile", type: "string" },
              ],
              name: "initialize",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "investStrategyHash()": {
              inputs: [],
              name: "investStrategyHash",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "isMaxVaultValueJumpAllowed(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "_diff", type: "uint256" },
                { internalType: "uint256", name: "_currentVaultValue", type: "uint256" },
              ],
              name: "isMaxVaultValueJumpAllowed",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "view",
              type: "function",
            },
            "maxVaultValueJump()": {
              inputs: [],
              name: "maxVaultValueJump",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "name()": {
              inputs: [],
              name: "name",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the name of the token.",
            },
            "opTOKEN_REVISION()": {
              inputs: [],
              name: "opTOKEN_REVISION",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyMinterContract()": {
              inputs: [],
              name: "optyMinterContract",
              outputs: [{ internalType: "contract OPTYMinter", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "pendingDeposits(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "pendingDeposits",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "pendingWithdraws(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "pendingWithdraws",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "profile()": {
              inputs: [],
              name: "profile",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            "queue(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "queue",
              outputs: [
                { internalType: "address", name: "account", type: "address" },
                { internalType: "bool", name: "isDeposit", type: "bool" },
                { internalType: "uint256", name: "value", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "rebalance()": {
              inputs: [],
              name: "rebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "registryContract()": {
              inputs: [],
              name: "registryContract",
              outputs: [{ internalType: "contract Registry", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "riskManagerContract()": {
              inputs: [],
              name: "riskManagerContract",
              outputs: [{ internalType: "contract RiskManager", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "setMaxVaultValueJump(uint256)": {
              inputs: [{ internalType: "uint256", name: "_maxVaultValueJump", type: "uint256" }],
              name: "setMaxVaultValueJump",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setOPTYMinter(address)": {
              inputs: [{ internalType: "address", name: "_optyMinter", type: "address" }],
              name: "setOPTYMinter",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setPaused(bool)": {
              inputs: [{ internalType: "bool", name: "_paused", type: "bool" }],
              name: "setPaused",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setProfile(string)": {
              inputs: [{ internalType: "string", name: "_profile", type: "string" }],
              name: "setProfile",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setRegistry(address)": {
              inputs: [{ internalType: "address", name: "_registry", type: "address" }],
              name: "setRegistry",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Sets the regsitry contract address",
              params: {
                _registry:
                  "address of registry contract Requirements: - `msg.sender` should be operator - `registry` can not be zero address",
              },
            },
            "setRiskManager(address)": {
              inputs: [{ internalType: "address", name: "_riskManager", type: "address" }],
              name: "setRiskManager",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setStrategyManager(address)": {
              inputs: [{ internalType: "address", name: "_strategyManager", type: "address" }],
              name: "setStrategyManager",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setToken(address)": {
              inputs: [{ internalType: "address", name: "_underlyingToken", type: "address" }],
              name: "setToken",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "setWithdrawalFee(uint256)": {
              inputs: [{ internalType: "uint256", name: "_withdrawalFee", type: "uint256" }],
              name: "setWithdrawalFee",
              outputs: [{ internalType: "bool", name: "_success", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "strategyManagerContract()": {
              inputs: [],
              name: "strategyManagerContract",
              outputs: [{ internalType: "contract StrategyManager", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "symbol()": {
              inputs: [],
              name: "symbol",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
              details: "Returns the symbol of the token, usually a shorter version of the name.",
            },
            "totalSupply()": {
              inputs: [],
              name: "totalSupply",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
              details: "See {IERC20-totalSupply}.",
            },
            "transfer(address,uint256)": {
              inputs: [
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transfer",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transfer}. Requirements: - `recipient` cannot be the zero address. - the caller must have a balance of at least `amount`.",
            },
            "transferFrom(address,address,uint256)": {
              inputs: [
                { internalType: "address", name: "sender", type: "address" },
                { internalType: "address", name: "recipient", type: "address" },
                { internalType: "uint256", name: "amount", type: "uint256" },
              ],
              name: "transferFrom",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
              details:
                "See {IERC20-transferFrom}. Emits an {Approval} event indicating the updated allowance. This is not required by the EIP. See the note at the beginning of {ERC20}. Requirements: - `sender` and `recipient` cannot be the zero address. - `sender` must have a balance of at least `amount`. - the caller must have allowance for ``sender``'s tokens of at least `amount`.",
            },
            "underlyingToken()": {
              inputs: [],
              name: "underlyingToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "userDeposit(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDeposit",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAll()": {
              inputs: [],
              name: "userDepositAll",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllAndStake(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllAndStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllAndStakeWithCHI(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalance()": {
              inputs: [],
              name: "userDepositAllRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceAndStake(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllRebalanceAndStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceAndStakeWithCHI(address)": {
              inputs: [{ internalType: "address", name: "_stakingPool", type: "address" }],
              name: "userDepositAllRebalanceAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllRebalanceWithCHI()": {
              inputs: [],
              name: "userDepositAllRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAllWithCHI()": {
              inputs: [],
              name: "userDepositAllWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAndStake(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositAndStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositAndStakeWithCHI(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalance(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositRebalance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceAndStake(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositRebalanceAndStake",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceAndStakeWithCHI(uint256,address)": {
              inputs: [
                { internalType: "uint256", name: "_amount", type: "uint256" },
                { internalType: "address", name: "_stakingPool", type: "address" },
              ],
              name: "userDepositRebalanceAndStakeWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositRebalanceWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userDepositWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_amount", type: "uint256" }],
              name: "userDepositWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawAllRebalance()": {
              inputs: [],
              name: "userWithdrawAllRebalance",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawAllRebalanceWithCHI()": {
              inputs: [],
              name: "userWithdrawAllRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawRebalance(uint256)": {
              inputs: [{ internalType: "uint256", name: "_redeemAmount", type: "uint256" }],
              name: "userWithdrawRebalance",
              outputs: [{ internalType: "bool", name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            },
            "userWithdrawRebalanceWithCHI(uint256)": {
              inputs: [{ internalType: "uint256", name: "_redeemAmount", type: "uint256" }],
              name: "userWithdrawRebalanceWithCHI",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
            },
            "vaultValue()": {
              inputs: [],
              name: "vaultValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "withdrawQueue()": {
              inputs: [],
              name: "withdrawQueue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "withdrawalFee()": {
              inputs: [],
              name: "withdrawalFee",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
        "contracts/protocol/tokenization/VaultProxy.sol:Address": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "Address",
          details: "Collection of functions related to the address type",
        },
        "contracts/protocol/tokenization/VaultProxy.sol:BaseImmutableAdminUpgradeabilityProxy": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "BaseImmutableAdminUpgradeabilityProxy",
          title: "BaseImmutableAdminUpgradeabilityProxy",
          author: "Aave, inspired by the OpenZeppelin upgradeability proxy pattern",
          details:
            "This contract combines an upgradeability proxy with an authorization mechanism for administrative tasks. The admin role is stored in an immutable, which helps saving transactions costs All external functions in this contract must be guarded by the `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity feature proposal that would enable this to be done automatically.",
          constructor: {
            inputs: [{ internalType: "address", name: "admin", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          fallback: { stateMutability: "payable", type: "fallback" },
          events: {
            "Upgraded(address)": {
              anonymous: !1,
              inputs: [{ indexed: !0, internalType: "address", name: "implementation", type: "address" }],
              name: "Upgraded",
              type: "event",
            },
          },
          methods: {
            "admin()": {
              inputs: [],
              name: "admin",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              returns: { _0: "The address of the proxy admin." },
            },
            "implementation()": {
              inputs: [],
              name: "implementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              returns: { _0: "The address of the implementation." },
            },
            "upgradeTo(address)": {
              inputs: [{ internalType: "address", name: "newImplementation", type: "address" }],
              name: "upgradeTo",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Upgrade the backing implementation of the proxy. Only the admin can call this function.",
              params: { newImplementation: "Address of the new implementation." },
            },
            "upgradeToAndCall(address,bytes)": {
              inputs: [
                { internalType: "address", name: "newImplementation", type: "address" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "upgradeToAndCall",
              outputs: [],
              stateMutability: "payable",
              type: "function",
              details:
                "Upgrade the backing implementation of the proxy and call a function on the new implementation. This is useful to initialize the proxied contract.",
              params: {
                data:
                  "Data to send as msg.data in the low level call. It should include the signature and the parameters of the function to be called, as described in https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
                newImplementation: "Address of the new implementation.",
              },
            },
          },
        },
        "contracts/protocol/tokenization/VaultProxy.sol:BaseUpgradeabilityProxy": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "BaseUpgradeabilityProxy",
          title: "BaseUpgradeabilityProxy",
          details:
            "This contract implements a proxy that allows to change the implementation address to which it will delegate. Such a change is called an implementation upgrade.",
          fallback: { stateMutability: "payable", type: "fallback" },
          events: {
            "Upgraded(address)": {
              anonymous: !1,
              inputs: [{ indexed: !0, internalType: "address", name: "implementation", type: "address" }],
              name: "Upgraded",
              type: "event",
            },
          },
        },
        "contracts/protocol/tokenization/VaultProxy.sol:InitializableImmutableAdminUpgradeabilityProxy": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "InitializableImmutableAdminUpgradeabilityProxy",
          title: "InitializableAdminUpgradeabilityProxy",
          details: "Extends BaseAdminUpgradeabilityProxy with an initializer function",
          constructor: {
            inputs: [{ internalType: "address", name: "admin", type: "address" }],
            stateMutability: "nonpayable",
            type: "constructor",
          },
          fallback: { stateMutability: "payable", type: "fallback" },
          events: {
            "Upgraded(address)": {
              anonymous: !1,
              inputs: [{ indexed: !0, internalType: "address", name: "implementation", type: "address" }],
              name: "Upgraded",
              type: "event",
            },
          },
          methods: {
            "admin()": {
              inputs: [],
              name: "admin",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              returns: { _0: "The address of the proxy admin." },
            },
            "implementation()": {
              inputs: [],
              name: "implementation",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
              returns: { _0: "The address of the implementation." },
            },
            "initialize(address,bytes)": {
              inputs: [
                { internalType: "address", name: "_logic", type: "address" },
                { internalType: "bytes", name: "_data", type: "bytes" },
              ],
              name: "initialize",
              outputs: [],
              stateMutability: "payable",
              type: "function",
              details: "Contract initializer.",
              params: {
                _data:
                  "Data to send as msg.data to the implementation to initialize the proxied contract. It should include the signature and the parameters of the function to be called, as described in https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding. This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.",
                _logic: "Address of the initial implementation.",
              },
            },
            "upgradeTo(address)": {
              inputs: [{ internalType: "address", name: "newImplementation", type: "address" }],
              name: "upgradeTo",
              outputs: [],
              stateMutability: "nonpayable",
              type: "function",
              details: "Upgrade the backing implementation of the proxy. Only the admin can call this function.",
              params: { newImplementation: "Address of the new implementation." },
            },
            "upgradeToAndCall(address,bytes)": {
              inputs: [
                { internalType: "address", name: "newImplementation", type: "address" },
                { internalType: "bytes", name: "data", type: "bytes" },
              ],
              name: "upgradeToAndCall",
              outputs: [],
              stateMutability: "payable",
              type: "function",
              details:
                "Upgrade the backing implementation of the proxy and call a function on the new implementation. This is useful to initialize the proxied contract.",
              params: {
                data:
                  "Data to send as msg.data in the low level call. It should include the signature and the parameters of the function to be called, as described in https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.",
                newImplementation: "Address of the new implementation.",
              },
            },
          },
        },
        "contracts/protocol/tokenization/VaultProxy.sol:InitializableUpgradeabilityProxy": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "InitializableUpgradeabilityProxy",
          title: "InitializableUpgradeabilityProxy",
          details: "Extends BaseUpgradeabilityProxy with an initializer for initializing implementation and init data.",
          fallback: { stateMutability: "payable", type: "fallback" },
          events: {
            "Upgraded(address)": {
              anonymous: !1,
              inputs: [{ indexed: !0, internalType: "address", name: "implementation", type: "address" }],
              name: "Upgraded",
              type: "event",
            },
          },
          methods: {
            "initialize(address,bytes)": {
              inputs: [
                { internalType: "address", name: "_logic", type: "address" },
                { internalType: "bytes", name: "_data", type: "bytes" },
              ],
              name: "initialize",
              outputs: [],
              stateMutability: "payable",
              type: "function",
              details: "Contract initializer.",
              params: {
                _data:
                  "Data to send as msg.data to the implementation to initialize the proxied contract. It should include the signature and the parameters of the function to be called, as described in https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding. This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.",
                _logic: "Address of the initial implementation.",
              },
            },
          },
        },
        "contracts/protocol/tokenization/VaultProxy.sol:Proxy": {
          source: "contracts/protocol/tokenization/VaultProxy.sol",
          name: "Proxy",
          title: "Proxy",
          details:
            "Implements delegation of calls to other contracts, with proper forwarding of return values and bubbling of failures. It defines a fallback function that delegates all calls to the address returned by the abstract _implementation() internal function.",
          fallback: { stateMutability: "payable", type: "fallback" },
        },
        "contracts/protocol/tokenization/VaultStorage.sol:VaultStorage": {
          source: "contracts/protocol/tokenization/VaultStorage.sol",
          name: "VaultStorage",
          methods: {
            "WITHDRAWAL_MAX()": {
              inputs: [],
              name: "WITHDRAWAL_MAX",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "ZERO_BYTES32()": {
              inputs: [],
              name: "ZERO_BYTES32",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "blockToBlockVaultValues(uint256,uint256)": {
              inputs: [
                { internalType: "uint256", name: "", type: "uint256" },
                { internalType: "uint256", name: "", type: "uint256" },
              ],
              name: "blockToBlockVaultValues",
              outputs: [
                { internalType: "uint256", name: "actualVaultValue", type: "uint256" },
                { internalType: "uint256", name: "blockMinVaultValue", type: "uint256" },
                { internalType: "uint256", name: "blockMaxVaultValue", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "depositQueue()": {
              inputs: [],
              name: "depositQueue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "gasOwedToOperator()": {
              inputs: [],
              name: "gasOwedToOperator",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "investStrategyHash()": {
              inputs: [],
              name: "investStrategyHash",
              outputs: [{ internalType: "bytes32", name: "", type: "bytes32" }],
              stateMutability: "view",
              type: "function",
            },
            "maxVaultValueJump()": {
              inputs: [],
              name: "maxVaultValueJump",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "optyMinterContract()": {
              inputs: [],
              name: "optyMinterContract",
              outputs: [{ internalType: "contract OPTYMinter", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "pendingDeposits(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "pendingDeposits",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "pendingWithdraws(address)": {
              inputs: [{ internalType: "address", name: "", type: "address" }],
              name: "pendingWithdraws",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "profile()": {
              inputs: [],
              name: "profile",
              outputs: [{ internalType: "string", name: "", type: "string" }],
              stateMutability: "view",
              type: "function",
            },
            "queue(uint256)": {
              inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              name: "queue",
              outputs: [
                { internalType: "address", name: "account", type: "address" },
                { internalType: "bool", name: "isDeposit", type: "bool" },
                { internalType: "uint256", name: "value", type: "uint256" },
              ],
              stateMutability: "view",
              type: "function",
            },
            "riskManagerContract()": {
              inputs: [],
              name: "riskManagerContract",
              outputs: [{ internalType: "contract RiskManager", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "strategyManagerContract()": {
              inputs: [],
              name: "strategyManagerContract",
              outputs: [{ internalType: "contract StrategyManager", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "underlyingToken()": {
              inputs: [],
              name: "underlyingToken",
              outputs: [{ internalType: "address", name: "", type: "address" }],
              stateMutability: "view",
              type: "function",
            },
            "vaultValue()": {
              inputs: [],
              name: "vaultValue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "withdrawQueue()": {
              inputs: [],
              name: "withdrawQueue",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
            "withdrawalFee()": {
              inputs: [],
              name: "withdrawalFee",
              outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
              stateMutability: "view",
              type: "function",
            },
          },
        },
      },
      _t = new ze({
        routes: [
          { path: "/", component: vt, props: () => ({ json: ht }) },
          { path: "*", component: ct, props: e => ({ json: ht[e.path.slice(1)] }) },
        ],
      });
    new a.a({
      el: "#app",
      router: _t,
      mounted() {
        document.dispatchEvent(new Event("render-event"));
      },
      render: e => e(Xe),
    });
  },
  function (e, t, n) {
    "use strict";
    function a(e, t) {
      for (var n = [], a = {}, s = 0; s < t.length; s++) {
        var i = t[s],
          r = i[0],
          o = { id: e + ":" + s, css: i[1], media: i[2], sourceMap: i[3] };
        a[r] ? a[r].parts.push(o) : n.push((a[r] = { id: r, parts: [o] }));
      }
      return n;
    }
    n.r(t),
      n.d(t, "default", function () {
        return m;
      });
    var s = "undefined" != typeof document;
    if ("undefined" != typeof DEBUG && DEBUG && !s)
      throw new Error(
        "vue-style-loader cannot be used in a non-browser environment. Use { target: 'node' } in your Webpack config to indicate a server-rendering environment.",
      );
    var i = {},
      r = s && (document.head || document.getElementsByTagName("head")[0]),
      o = null,
      d = 0,
      p = !1,
      u = function () {},
      l = null,
      y = "undefined" != typeof navigator && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase());
    function m(e, t, n, s) {
      (p = n), (l = s || {});
      var r = a(e, t);
      return (
        c(r),
        function (t) {
          for (var n = [], s = 0; s < r.length; s++) {
            var o = r[s];
            (d = i[o.id]).refs--, n.push(d);
          }
          t ? c((r = a(e, t))) : (r = []);
          for (s = 0; s < n.length; s++) {
            var d;
            if (0 === (d = n[s]).refs) {
              for (var p = 0; p < d.parts.length; p++) d.parts[p]();
              delete i[d.id];
            }
          }
        }
      );
    }
    function c(e) {
      for (var t = 0; t < e.length; t++) {
        var n = e[t],
          a = i[n.id];
        if (a) {
          a.refs++;
          for (var s = 0; s < a.parts.length; s++) a.parts[s](n.parts[s]);
          for (; s < n.parts.length; s++) a.parts.push(f(n.parts[s]));
          a.parts.length > n.parts.length && (a.parts.length = n.parts.length);
        } else {
          var r = [];
          for (s = 0; s < n.parts.length; s++) r.push(f(n.parts[s]));
          i[n.id] = { id: n.id, refs: 1, parts: r };
        }
      }
    }
    function T() {
      var e = document.createElement("style");
      return (e.type = "text/css"), r.appendChild(e), e;
    }
    function f(e) {
      var t,
        n,
        a = document.querySelector('style[data-vue-ssr-id~="' + e.id + '"]');
      if (a) {
        if (p) return u;
        a.parentNode.removeChild(a);
      }
      if (y) {
        var s = d++;
        (a = o || (o = T())), (t = v.bind(null, a, s, !1)), (n = v.bind(null, a, s, !0));
      } else
        (a = T()),
          (t = h.bind(null, a)),
          (n = function () {
            a.parentNode.removeChild(a);
          });
      return (
        t(e),
        function (a) {
          if (a) {
            if (a.css === e.css && a.media === e.media && a.sourceMap === e.sourceMap) return;
            t((e = a));
          } else n();
        }
      );
    }
    var b,
      g =
        ((b = []),
        function (e, t) {
          return (b[e] = t), b.filter(Boolean).join("\n");
        });
    function v(e, t, n, a) {
      var s = n ? "" : a.css;
      if (e.styleSheet) e.styleSheet.cssText = g(t, s);
      else {
        var i = document.createTextNode(s),
          r = e.childNodes;
        r[t] && e.removeChild(r[t]), r.length ? e.insertBefore(i, r[t]) : e.appendChild(i);
      }
    }
    function h(e, t) {
      var n = t.css,
        a = t.media,
        s = t.sourceMap;
      if (
        (a && e.setAttribute("media", a),
        l.ssrId && e.setAttribute("data-vue-ssr-id", t.id),
        s &&
          ((n += "\n/*# sourceURL=" + s.sources[0] + " */"),
          (n +=
            "\n/*# sourceMappingURL=data:application/json;base64," +
            btoa(unescape(encodeURIComponent(JSON.stringify(s)))) +
            " */")),
        e.styleSheet)
      )
        e.styleSheet.cssText = n;
      else {
        for (; e.firstChild; ) e.removeChild(e.firstChild);
        e.appendChild(document.createTextNode(n));
      }
    }
  },
]);
