import abi from "ethereumjs-abi";
import { BigNumber, BigNumberish } from "ethers";
import hre, { ethers } from "hardhat";
import { SignerWithAddress } from "@nomiclabs/hardhat-ethers/dist/src/signer-with-address";
import {
  AaveV1Adapter,
  AaveV1ETHGateway,
  AaveV2Adapter,
  AdminUpgradeabilityProxy,
  APROracle,
  CompoundAdapter,
  CompoundETHGateway,
  CurveDepositPoolAdapter,
  CurveSwapETHGateway,
  CurveSwapPoolAdapter,
  ERC20,
  HarvestCodeProvider,
  InitializableImmutableAdminUpgradeabilityProxy,
  InvestStrategyRegistry,
  Registry,
  RegistryProxy,
  RiskManager,
  RiskManagerProxy,
  StrategyManager,
  StrategyProvider,
  Vault,
  VaultV2,
} from "../typechain";
import fs from "fs";
import { AxiosRequestConfig, Method } from "axios";

// function to get the equivalent hash (as generated by the solidity) of data passed in args
export function getSoliditySHA3Hash(argTypes: string[], args: any[]): string {
  const soliditySHA3Hash = "0x" + abi.soliditySHA3(argTypes, args).toString("hex");
  return soliditySHA3Hash;
}

export function amountInHex(fundAmount: BigNumber): string {
  const amount: string = "0x" + Number(fundAmount).toString(16);
  return amount;
}

export function delay(ms: number): Promise<unknown> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

export function removeDuplicateFromStringArray(list: string[]): string[] {
  return list.filter((x, i, a) => a.indexOf(x) == i);
}

export interface Signers {
  admin: SignerWithAddress;
  owner: SignerWithAddress;
  deployer: SignerWithAddress;
  alice: SignerWithAddress;
  bob: SignerWithAddress;
  financeOperator: SignerWithAddress;
  riskOperator: SignerWithAddress;
  strategyOperator: SignerWithAddress;
  operator: SignerWithAddress;
  governance: SignerWithAddress;
  eve: SignerWithAddress;
}

declare module "mocha" {
  export interface Context {
    signers: Signers;
    registry: Registry;
    registryProxy: RegistryProxy;
    harvestCodeProvider: HarvestCodeProvider;
    compoundAdapter: CompoundAdapter;
    compoundEthGateway: CompoundETHGateway;
    aavev1Adapter: AaveV1Adapter;
    aaveV1EthGateway: AaveV1ETHGateway;
    aaveV2Adapter: AaveV2Adapter;
    curveDepositPoolAdapter: CurveDepositPoolAdapter;
    curveSwapPoolAdapter: CurveSwapPoolAdapter;
    curveSwapEthGateway: CurveSwapETHGateway;
    investStrategyRegistry: InvestStrategyRegistry;
    strategyProvider: StrategyProvider;
    riskManager: RiskManager;
    riskManagerProxy: RiskManagerProxy;
    aprOracle: APROracle;
    strategyManager: StrategyManager;
    vault: Vault;
    vaultProxy: InitializableImmutableAdminUpgradeabilityProxy;
    opUSDCgrow: Vault;
    opUSDCgrowProxy: InitializableImmutableAdminUpgradeabilityProxy;
    opWETHgrow: Vault;
    opWETHgrowProxy: InitializableImmutableAdminUpgradeabilityProxy;
    vaultV2: VaultV2;
    vaultProxyV2: AdminUpgradeabilityProxy;
    opUSDCgrowV2: VaultV2;
    opWETHgrowV2: VaultV2;
    erc20: ERC20;
  }
}

export function capitalizeFirstLetter(string: string): string {
  return string.charAt(0).toUpperCase() + string.slice(1);
}

export function to_10powNumber_BN(decimals: BigNumberish): BigNumber {
  return BigNumber.from(10).pow(decimals);
}

export function createDir(_dirPath: string): void {
  if (!fs.existsSync(_dirPath)) {
    try {
      fs.mkdirSync(process.cwd() + _dirPath, { recursive: true });
    } catch (error) {
      console.error(`An error occurred: `, error);
    }
  }
}

export function createFile(filePath: string, fileContent: string | NodeJS.ArrayBufferView): void {
  try {
    fs.writeFileSync(filePath, fileContent);
  } catch (error) {
    console.error(`An error occurred: `, error);
  }
}

export function getMoralisConfig(
  method: Method,
  functionName: string,
  args: { [key: string]: any },
): AxiosRequestConfig {
  const BASE_DATA_OPTIONS = {
    _ApplicationId: process.env.MORALIS_APP_ID,
    _ClientVersion: "js0.0.120",
    _InstallationId: "a4e82bcc-1ef9-4379-a92f-59f2ecd557db",
  };
  const config = {
    method,
    url: `${process.env.MORALIS_SERVER_URL}/functions/${functionName}`,
    headers: {
      "Content-Type": "application/json",
    },
    data: JSON.stringify({
      ...args,
      ...BASE_DATA_OPTIONS,
    }),
  };

  return config;
}

const setStorageAt = (address: string, slot: string, val: string): Promise<any> =>
  hre.network.provider.send("hardhat_setStorageAt", [address, slot, val]);

const tokenBalancesSlot = async (token: ERC20) => {
  const val: string = "0x" + "12345".padStart(64, "0");
  const account: string = ethers.constants.AddressZero;

  for (let i = 0; i < 100; i++) {
    let slot = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(["address", "uint256"], [account, i]));
    while (slot.startsWith("0x0")) slot = "0x" + slot.slice(3);

    const prev = await hre.network.provider.send("eth_getStorageAt", [account, slot, "latest"]);
    await setStorageAt(token.address, slot, val);
    const balance = await token.balanceOf(account);
    await setStorageAt(token.address, slot, prev);
    if (balance.eq(ethers.BigNumber.from(val))) {
      return { index: i, isVyper: false };
    }
  }

  for (let i = 0; i < 100; i++) {
    let slot = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(["uint256", "address"], [i, account]));
    while (slot.startsWith("0x0")) slot = "0x" + slot.slice(3);

    const prev = await hre.network.provider.send("eth_getStorageAt", [account, slot, "latest"]);
    await setStorageAt(token.address, slot, val);
    const balance = await token.balanceOf(account);
    await setStorageAt(token.address, slot, prev);
    if (balance.eq(ethers.BigNumber.from(val))) {
      return { index: i, isVyper: true };
    }
  }
  throw "balances slot not found!";
};

// Source : https://github.com/Opty-Fi/defi-adapter-kit/blob/e41ab7607f737b9322b3d19d2144b0f94efc692d/test/utils.ts
export async function setTokenBalanceInStorage(token: ERC20, account: string, amount: string): Promise<number | void> {
  const balancesSlot = await tokenBalancesSlot(token);
  if (balancesSlot.isVyper) {
    return setStorageAt(
      token.address,
      ethers.utils.keccak256(
        ethers.utils.defaultAbiCoder.encode(["uint256", "address"], [balancesSlot.index, account]),
      ),
      "0x" +
        ethers.utils
          .parseUnits(amount, await token.decimals())
          .toHexString()
          .slice(2)
          .padStart(64, "0"),
    );
  } else {
    return setStorageAt(
      token.address,
      ethers.utils.keccak256(
        ethers.utils.defaultAbiCoder.encode(["address", "uint256"], [account, balancesSlot.index]),
      ),
      "0x" +
        ethers.utils
          .parseUnits(amount, await token.decimals())
          .toHexString()
          .slice(2)
          .padStart(64, "0"),
    );
  }
}
